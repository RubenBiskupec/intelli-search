Algorithmica (2020) 82:3521-3565
https://doi.org/10.1007/s00453-020-00736-0

m)

Check for
updates

The Power of Linear-Time Data Reduction for Maximum
Matching

George B. Mertzios'® - André Nichterlein?® - Rolf Niedermeier

Received: 18 January 2019 / Accepted: 13 June 2020 / Published online: 6 July 2020
© The Author(s) 2020

Abstract

Finding maximum-cardinality matchings in undirected graphs is arguably one of the
most central graph primitives. For m-edge and n-vertex graphs, it is well-known to
be solvable in O(my/n) time; however, for several applications this running time is
still too slow. We investigate how linear-time (and almost linear-time) data reduc-
tion (used as preprocessing) can alleviate the situation. More specifically, we focus
on linear-time kernelization. We start a deeper and systematic study both for gen-
eral graphs and for bipartite graphs. Our data reduction algorithms easily comply (in
form of preprocessing) with every solution strategy (exact, approximate, heuristic),
thus making them attractive in various settings.

Keywords Maximum-cardinality matching - Bipartite graphs - Linear-time
algorithms - Kernelization - Parameterized complexity analysis - FPT in P

A short version of this article appeared in the Proceedings of the 42nd International Symposium on
Mathematical Foundations of Computer Science (MFCS 17), pages 46:1-46:14. Schloss Dagstuhl
- Leibniz-Zentrum fiir Informatik, 2017. This article now contains all proofs in full detail. Supported
by the EPSRC grant EP/P020372/1, by the DFG project FPTinP, NI 369/16, and by a postdoc
fellowship of the German Academic Exchange Service (DAAD) while the second author was at
Durham University.

b) André Nichterlein
andre.nichterlein @tu-berlin.de

George B. Mertzios
george.mertzios @ durham.ac.uk

Rolf Niedermeier
rolf.niedermeier @ tu-berlin.de

Department of Computer Science, Durham University, Durham, UK

Algorithmics and Computational Complexity, Faculty IV, TU Berlin, Berlin, Germany

Q) Springer
3522 Algorithmica (2020) 82:3521-3565

1 Introduction

“Matching is a powerful piece of algorithmic magic” [24]. In the MAximum Matcnu-
ING problem, given an undirected graph, one has to compute a maximum-cardinality
set of nonoverlapping edges. Maximum matching is arguably among the most fun-
damental graph-algorithmic primitives allowing for a polynomial-time algorithm.
More specifically, on an n-vertex and m-edge graph a maximum matching can be
found in O(my/n) time [21]. Improving this upper time bound resisted decades of
research. Recently, however, Duan and Pettie [8] presented a linear-time algorithm
that computes a (1 — €)-approximate maximum-weight matching, where the running
time dependency on ¢€ is €~! log(e~!). For the unweighted case, the O(my/n) algo-
rithm of Micali and Vazirani [21] implies a linear-time (1 — €)-approximation, where
in this case the running time dependency on ¢ is e~! [8]. We take a different route:
First, we do not give up the quest for optimal solutions. Second, we focus on effi-
cient—more specifically, linear-time executable—data reduction rules, that is, not
solving an instance but significantly shrinking its size before actually solving the
problem.! In the context of decision problems and parameterized algorithmics this
approach is known as kernelization; this is a particularly active area of algorithmic
research on NP-hard problems.

The spirit behind our approach is thus closer to the identification of efficiently
solvable special cases of MAxiImuM Matcuinc. There is quite some body of work
in this direction. For instance, since an augmenting path can be found in linear
time [10], the standard augmenting path-based algorithm runs in O(s(n + m)) time,
where s is the number of edges in the maximum matching. Yuster [26] developed
an O(rn* log n)-time algorithm, where r is the difference between maximum and
minimum degree of the input graph. Moreover, there are linear-time algorithms for
computing maximum matchings in special graph classes, including convex bipartite
[25], strongly chordal [7], chordal bipartite graphs [6], and cocomparability graphs
[20].

All this and the more general spirit of “parameterization for polynomial-time
solvable problems” (also referred to as “FPT in P” or “FPTP” for short) [12] forms
the starting point of our research. Remarkably, Fomin et al. [9] recently developed an
algorithm to compute a maximum matching in graphs of treewidth k in O(k*n log” n)
randomized time. Afterwards, Iwata, Ogasawara, and Ohsaka [16] provided an ele-
gant algorithm computing a maximum matching in graphs of treedepth 7 in O(¢ - m)
time. This implies an O(k*nlogn)-time algorithm where k is the treewidth, since
m € O(kn) and @ < (k + 1) logn [23]. Recently, Kratsch and Nelles [19] presented a
O(r? log(r)n + m)-time algorithm where r is the modular-width.

Following the paradigm of kernelization, that is, provably effective and efficient
data reduction, we provide a systematic exploration of the power of not only poly-
nomial-time but actually linear-time data reduction for MAximuM MATCHING. Thus,
our aim (fitting within FPTP) is to devise problem kernels that are computable in

 

' Doing so, however, we focus on the unweighted case.

Q) Springer
Algorithmica (2020) 82:3521-3565 3523

Table 1 Our kernelization results

Parameter k Running time Kernel size

Results for MATCHING
Feedback edge number O(n + m) time O(k) vertices and edges (Theorem 1)
Feedback vertex number O(kn) time 2° vertices and edges (Theorem 2)
Results for BirartTitE MATCHING

Distance to chain graphs O(n + m) time O(k?) vertices (Theorem 3)

linear time. In other words, the fundamental question we pose is whether there is
a very efficient preprocessing that provably shrinks the input instance, where the
effectiveness 1s measured by employing some parameters. The philosophy behind
is that if we can design linear-time data reduction algorithms, then we may employ
them for free before afterwards employing any super-linear-time solving algorithm.
We believe that this sort of question deserves deeper investigation and we initiate it
based on the Maximum Matcuinc problem. In fact, in follow-up work we demon-
strated that such linear-time data reduction rules can significantly speed-up state-of-
the-art solvers for MATCHING [18].

As kernelization is usually defined for decision problems, we use in the remain-
der of the paper the decision version of MAxIMUM Matcuinc. In the rest of the paper
we call this decision version MATCHING. In a nutshell, a kernelization of a decision
problem instance is an algorithm that produces an equivalent instance whose size
can solely be upper-bounded by a function in the parameter (preferably a polynomial
function). The focus on decision problems is justified by the fact that all our results,
although formulated for the decision version, in a straightforward way extend to the
corresponding optimization version (as also done in our follow-up work [18]).

(MaAxXIMUM-CARDINALITY) MATCHING

Input: An undirected graph G = (V, £) and a nonnegative integer s.
Question: Is there a size-s subset Mg C E of nonoverlapping (i.e. disjoint)
edges?

Note that, for any polynomial-time solvable problem, solving the given instance
and returning a trivial yes- or no-instance always produces a constant-size kernel in
polynomial time. Hence, we are looking for kernelization algorithms that are faster
than the algorithms solving the problem. The best we can hope for is linear time.
For NP-hard problems, each polynomial-time kernelization algorithm is faster than
any solution algorithm, unless P=NP. While the focus of classical kernelization for
NP-hard problems is mostly on improving the size of the kernel, we particularly
emphasize that for polynomially solvable problems it is mandatory to also focus on
the running time of the kernelization algorithm. Indeed, we can consider linear-time
kernelization as the holy grail and this drives our research when studying kerneliza-
tion for MATCHING.

Our contributions. We present three kernels for MATCHING (see Table | for an
overview). All our parameterizations can be categorized as “distance to triviality”

Q) Springer
3524 Algorithmica (2020) 82:3521-3565

[5, 13]. They are motivated as follows. First, note that it is important that the param-
eters we exploit can be computed, or well approximated (within constant factors), in
linear time regardless of the parameter value. Next, note that maximum-cardinality
matchings can be trivially found in linear time on trees (or forests). That is why we
consider the edge deletion distance (feedback edge number) and vertex deletion dis-
tance (feedback vertex number) to forests. Notably, there is a trivial linear-time algo-
rithm for computing the feedback edge number and there is a linear-time factor-4
approximation algorithm for the feedback vertex number [1]. We mention in passing
that the parameter vertex cover number, which is lower-bounded by the feedback
vertex number, has been frequently studied for kernelization. In particular, Gian-
nopoulou, Mertzios, and Niedermeier [12, 14] provided a linear-time computable
quadratic-size kernel for MATCHING with respect to the parameter solution size (or
equivalently vertex cover number). Coming to bipartite graphs, we parameterize by
the vertex deletion distance to chain graphs which is motivated as follows. First,
chain graphs form one of the most obvious easy cases for bipartite graphs where
MATCHING can be solved in linear time [25]. Second, we show that the vertex dele-
tion distance of any bipartite graph to a chain graph can be 4-approximated in linear
time. Moreover, vertex deletion distance to chain graphs lower-bounds the vertex
cover number of a bipartite graph.

An overview of our main results is given in Table 1. We study kernelization for
MATCHING parameterized by the feedback vertex number, that is, the vertex deletion
distance to a forest (see Sect. 3). As a warm-up we first show that a subset of our
data reduction rules for the “feedback vertex set kernel” also yields a linear-time
computable linear-size kernel for the typically much larger parameter feedback edge
number (see Sect. 3.1). As for BiPARTITE MATCHING no faster algorithm is known than
on general graphs, we kernelize BiIpARTITE MATCHING with respect to the vertex dele-
tion distance to chain graphs (see Sect. 4).

Seen from a high level, our two main results (Theorems 2 and 3, see Table 1)
employ the same algorithmic strategy, namely upper-bounding (as a function of
the parameter) the number of neighbors in the appropriate vertex deletion set (also
called modulator) X; that is, in the feedback vertex set or in the deletion set to chain
graphs, respectively. To achieve this we develop new “irrelevant edge techniques”
tailored to these two kernelization problems. More specifically, whenever a ver-
tex v of the deletion set X has large degree, then we efficiently detect edges inci-
dent to v whose removal does not change the size of the maximum matching. Then
the remaining graph can be further shrunk by scenario-specific data reduction rules.
While this approach of removing irrelevant edges is natural, the technical details
and the proofs of correctness become quite technical and combinatorially challeng-
ing. Note that there exists a trivial O(km)-time solving (not only kernelization) algo-
rithm, where k is the feedback vertex number. Our kernel has size 22“). Therefore,
only if k = o(logn) our kernelization algorithm provably shrinks the initial instance.
However, our result is still relevant: First, our data reduction rules might assist in
proving a polynomial upper bound—so our result is a first step in this direction.
Second, the running time O(kn) of our kernelization algorithm is a kind of “half
way” between O(km) (which could be as bad as O(kn)) and O(n + m) (which is best
possible). Finally, note that this work focuses on theoretical and worst-case analysis;

Q) Springer
Algorithmica (2020) 82:3521-3565 3525

in practice, our kernelization algorithm might achieve much better upper bounds
on real-world input instances. In fact, in experiments using the kernelization with
respect to the feedback edge number, the observed kernels were always significantly
smaller than the theoretical bound [18].

As a technical side remark, we emphasize that in order to achieve a linear-time
kernelization algorithm, we often need to use suitable data structures and to care-
fully design the appropriate data reduction rules to be exhaustively applicable in lin-
ear time, making this form of “algorithm engineering” much more relevant than in
the classical setting of mere polynomial-time data reduction rules.

2 Preliminaries and Basic Observations

Notation and Observations. We use standard notation from graph theory. A feed-
back vertex (edge) set of a graph G is a set X of vertices (edges) such that G — X is
a tree or forest. The feedback vertex (edge) number denotes the size of a minimum
feedback vertex (edge) set. All paths we consider are simple paths. Two paths in a
graph are called internally vertex-disjoint if they are either completely vertex-dis-
joint or they overlap only in their endpoints. A matching in a graph 1s a set of pair-
wise disjoint edges. Let G = (V, E) be a graph and let M C E be a matching in G.
The degree of a vertex is denoted by deg(v). A vertex v € V is called matched with
respect to M if there is an edge in M containing v, otherwise v is called free with
respect to M. If the matching M is clear from the context, then we omit “with respect
to M”’. An alternating path with respect to M is a path in G such that every second
edge of the path is in M. An augmenting path is an alternating path whose endpoints
are free. It is well known that a matching M is maximum if and only if there is no
augmenting path for it. Let MW C E and M’ C E be two matchings in G. We denote
by G(M, M') :=(V,M /\ M’) the graph containing only the edges in the symmetric
difference of M and M’, that is, M /\ M’ :=MUM'\(MonM’). Observe that every
vertex in G(M, M’) has degree at most two.

For a matching M C E for G we denote by M™*(M) a maximum matching in G
with the largest possible overlap (in number of edges) with M. That is, Me™) 1s
a maximum matching in G such that for each maximum matching M’ for G it holds
that |M /\ M’| > |M ZA M?**(M)|. Observe that if M is a maximum matching for G,
then Me(M ) = M. Furthermore observe that G(M, M G MM )) consists of only odd-
length paths and isolated vertices, and each of these paths is an augmenting path
for M. Moreover the paths in G(M, Me"(M )) are as short as possible:

Observation 1 For any path VisVo, +009 Vy in G(M, Me") it holds

that {v>;_1,V2;} € E for every 1 <i<j <p/2.

Proof Assume that {v,;_1,V.;} € E. Then vy, V9, ..., Voj95 Vaj-1s Vaj> Vajzi> +++ >» Vp IS a
shorter path which is also an augmenting path for M in G. The corresponding maxi-
mum matching M’ satisfies |M A M™**(M)| > |M A. M’|, a contradiction to the
definition of M GC. (M). O

Q) Springer
3526 Algorithmica (2020) 82:3521-3565

It is easy to see that removing k vertices in a graph can reduce the maximum
matching size by at most k:

Observation 2 Let G = (V, E) be a graph with a maximum matching Mg, let X C V
be a vertex subset of size k, and let Mg_y be a maximum matching for G — X. Then,
IMc_x| < |Mgl < |Mg_xl + &.

Kernelization. A parameterized problem is a set of instances (/, k) where J € 2*
for a finite alphabet 2, and k € N is the parameter. We say that two instances (/, k)
and (/’,k’) of parameterized problems P and P’ are equivalent if (I, k) is a yes-
instance for P if and only if (/’, k’) is a yes-instance for P’. A kernelization is an algo-
rithm that, given an instance (/, k) of a parameterized problem P, computes in poly-
nomial time an equivalent instance (/’, k’) of P (the kernel) such that |J’| + k’ < f(k)
for some computable function f. We say that f measures the size of the kernel, and
if f(k) € kK°™, then we say that P admits a polynomial kernel. Typically, a kernel
is achieved by applying polynomial-time executable data reduction rules. We call a
data reduction rule R correct if the new instance (/’, k’) that results from applying R
to U/, k) is equivalent to (/, k). An instance is called reduced with respect to some
data reduction rule if further application of this rule has no effect on the instance.

3 Kernelization for Matching on General Graphs

In this section, we investigate the possibility of efficient and effective preprocessing
for MATCHING. As a warm-up, we first present in Sect. 3.1 a simple, linear-size kernel
for MATCHING with respect to the parameter feedback edge number. Exploiting the
data reduction rules and ideas used for this kernel, we then present in Sect. 3.2 the
main result of this section: an exponential-size kernel for the almost always signifi-
cantly smaller parameter feedback vertex number.

3.1 Warm-Up: Parameter Feedback Edge Number

We provide a linear-time computable linear-size kernel for MATCHING parameter-
ized by the feedback edge number, that is, the size of a minimum feedback edge
set. Observe that a minimum feedback edge set can be computed in linear time via a
simple depth-first search or breadth-first search. The kernel is based on the next two
simple data reduction rules due to Karp and Sipser [17]. These rules deal with verti-
ces of degree at most two.

Reduction Rule 1 Let v € V. If deg(v) = 0, then delete v. If deg(v) = 1, then delete v
and its neighbor and decrease the solution size s by one (v is matched with its

neighbor).

Reduction Rule 2 Let v be a vertex of degree two and let u, w be its neighbors. Then
remove v, merge u and w, and decrease the solution size s by one.

Q) Springer
Algorithmica (2020) 82:3521-3565 3527

The correctness was stated by Karp and Sipser [17]. For the sake of complete-
ness, we give a proof.

Lemma1 Reduction Rules | and 2 are correct.

Proof If v has degree zero, then clearly v cannot be in any matching and we can
remove v.

If v has degree one, then let uw be its single neighbor. Let M be a maximum
matching of size at least s for G. Then u is matched in M since otherwise adding
the edge {u,v} would increase the size of the matching. Thus, a maximum match-
ing in G’ = G—u-—v has size at least s — 1. Conversely, a maximum matching of
size s — 1 in G’ can easily be extended by the edge {u, v} to a maximum matching of
size sin G.

If v has degree two, then let u and w be its two neighbors. Let M be a maxi-
mum matching of size at least s. If v is matched in M (..e. either with the edge {u, v}
or with the edge {v,w}), then deleting v and merging u with w decreases the size
of M by one. Similarly, if v is not matched in M, then both u and w are matched
in M, since otherwise adding the edge {u,v} (resp. {v,w}) would increase the size
of the matching, a contradiction. Thus, in this case, deleting v and merging u with w
decreases again the size of M by one (M looses either the edge incident to v or one
of the edges incident to u and w). Hence, the resulting graph G” has a maximum
matching of size at least s — 1. Conversely, let M” be a matching of size at least s — 1
for G’’. If the merged vertex vw is free, then M := M” U {{u,v}} is a matching of
size s in G. Otherwise, vw is matched to some vertex y in M”’. Then matching y in G
with either v or w (at least one of the two vertices is a neighbor of y) and matching u
with the other vertex yields a matching of size at least s for G. oO

While it is easy to exhaustively apply Reduction Rule | in linear time, applying
Reduction Rule 2 exhaustively in linear time is nontrivial [2]. Note that applying
Reduction Rule 2 might create new degree-one vertices and thus Reduction Rule |
might become applicable again. To show our problem kernel, in the following theo-
rem it is sufficient to first apply Reduction Rule | exhaustively and afterwards apply
Reduction Rule 2 exhaustively.

Theorem 1 Marcuinc admits a linear-time computable linear-size kernel with
respect to the parameter feedback edge number k.

Proof Let G be the input graph. First we apply Reduction Rule | to G exhaustively,
obtaining graph G, = (V,,£,), and then we apply Reduction Rule 2 to G, exhaus-
tively, obtaining graph G, = (V>, E,). Note that both G, and G, can be computed in
linear time [2]. We will prove that G, has at most 6k vertices and 7k edges. Denote
with X, C E, and X, C E, the minimum feedback edge sets for G, and G, respec-
tively. Note that |X,| < |X,| <k. For any graph H, denote with V/,, V2, and V7? the
vertices of H that have degree one, two, and more than two, respectively (in our case
H will be replaced by G, — X, or G, — X,, respectively). Observe that all vertices

Q) Springer
3528 Algorithmica (2020) 82:3521-3565

in G, have degree at least two, since G, is reduced with respect to Reduction Rule 1.
Thus Vox, | < 2k, as each leaf in G, — X, has to be incident to an edge in X,. Next,
since G, — X, is a forest, we have that Vex | < Vox, |, and thus Vex | < 2k.
Note that the number of degree-two vertices in G, cannot be upper-bounded by a
function of k. However, observe that the exhaustive application of Reduction Rule 2
to G, removes all vertices that have degree-two in G, and possibly merges some of
the remaining vertices. Thus, G, contains no vertices with degree two and thus,
IVo-x, | <2k. Altogether, the number of vertices in G, is at most

1 2 >3 : : .
Vex, | + Vox, | + Vex, | < 6k. Since G, — X, is a forest, it follows that G, has
at most|V,| + k < 7k edges. O

Applying the O(my/n)-time algorithm for MATCHING [21] on the above kernel
yields the following.

Corollary 1 Marcuine can be solved in O(n + m+ k'») time, where k is the feedback
edge number.

3.2 Parameter Feedback Vertex Number

We next provide for Matcuinc a kernel of size 2? computable in O(kn) time
where k is the feedback vertex number. Using a known linear-time factor
4-approximation algorithm [1], we can compute an approximate feedback vertex
set and use it in our kernelization algorithm.

Roughly speaking, our kernelization algorithm extends the linear-time com-
putable kernel with respect to the parameter feedback edge set. Thus, Reduction
Rule | and 2 play an important role in the kernelization. Compared to the other
kernels presented in this paper, the kernel presented here comes at the price of
higher running time O(kn) and bigger kernel size (exponential). It remains open
whether MATCHING parameterized by the feedback vertex number admits a linear-
time computable kernel (possibly of exponential size), or whether it admits a pol-
ynomial kernel computable in O(kn) time.

Subsequently, we describe our kernelization algorithm which keeps in the ker-
nel all vertices in the given feedback vertex set X and shrinks the size of G—X.
Before doing so, we need some further notation. In this section, we assume that
each tree is rooted at some arbitrary (but fixed) vertex such that we can refer to
the parent and children of a vertex. A leaf in G—X is called a bottommost leaf
either if it has no siblings or if all its siblings are also leaves. (Here, bottom-
most refers to the subtree with the root being the parent of the considered leaf.)
The outline of the algorithm is as follows (we assume throughout this section
that k < logn since otherwise the input instance is already a kernel of size O(2*)):

1. Reduce G wrt. Reduction Rule 2 and 1.

Q) Springer
Algorithmica (2020) 82:3521-3565 3529

2. Compute a maximum matching Mg_,y in G — X (where X is a feedback vertex set
that 1s computed by the linear-time 4-approximation algorithm [1 ]).

Modify Mg_y, in linear time such that only the leaves of G — X are free.
Upper-bound the number of free leaves in G — X by k? (Sect. 3.2.1).
Upper-bound the number of bottommost leaves in G — X by O(k72*) (Sect. 3.2.2).
Upper-bound the degree of each vertex in X by O(k?2*). Then, use Reduction
Rule 2 and 1 to provide the kernel of size 2? (Sect. 3.2.3).

NOR YW

Whenever we reduce the graph at some step, we also show that the reduction is cor-
rect. That is, the given instance is a yes-instance if and only if the reduced one is a
yes-instance. The correctness of our kernelization algorithm then follows by the cor-
rectness of each step. We discuss in the following the details of each step.

3.2.1 Steps 1-4

In this subsection, we first discuss the straightforward Steps | to 3 and then turn to
Step 4.

Steps 1-3. As in Sect. 3.1, we perform Step | in linear time by first applying
Reduction Rule | and then Reduction Rule 2 using the algorithm due to Bartha and
Kresz [2]. By Lemma | this step is correct.

A maximum matching Mg_y in Step 2 can be computed by repeatedly matching
a free leaf to its neighbor and by removing both vertices from the graph (thus effec-
tively applying Reduction Rule | to G — X). Clearly, this can be done in linear time.

Step 3 can be done in O(n) time by traversing each tree in G — X in a BFS manner
starting from the root: If a visited inner vertex v is free, then observe that all children
are matched since Mg_y is maximum. Pick an arbitrary child uv of v and match it
with v. The vertex w that was previously matched to u is now free and since it is a
child of u, it will be visited in the future. Observe that Steps 2 and 3 do not change
the graph but only the auxiliary matching M;_ y, and thus the first three steps are
correct. The next observation summarizes the short discussion above.

Observation 3 Steps 1 to 3 are correct and can be applied in linear time.

Step 4. Our goal is to upper-bound the number of edges between vertices of X
and V\X, since we can then use a simple analysis as for the parameter feedback edge
set. Furthermore, recall that by Observation 2 the size of any maximum matching
in G is at most k plus the size of Mg_y. Now, the crucial observation here is that, if
a vertex x € X has at least k neighbors {v,, ...,v,}in V\X which are free wrt. Mc_y,
then there exists a maximum matching where x is matched to one of {v,,...,v,} since
at most k — I can be “blocked” by other matching edges. Indeed, consider otherwise
a maximum matching M in which x is not matched with any of {v,,...,v,}. Then,
since |X| = k, note that at most k — | vertices among {v,,...,v,} are matched in M
with a vertex in X; suppose without loss of generality that v, is not matched with any
vertex in X (and thus v, is not matched at all in M). If x is unmatched in M, then the
matching M U {{x, v,}}has greater cardinality than M, a contradiction. Otherwise, if

Q) Springer
3530 Algorithmica (2020) 82:3521-3565

x is matched in M with a vertex z, then M U {{x,v,}}\{{x, z}} is another maximum
matching of G, in which x is matched with a vertex among {v,, ..., v,}. Formalizing
this idea, we obtain the following data reduction rule.

Reduction Rule 3 Let G = (V, E) be a graph, let X C V be a vertex subset of size k,
and let Mg_y be a maximum matching for G — X. If there is a vertex x € X with at
least k free neighbors V, = {v,,...,v,} GC V\X, then delete all edges from x to verti-
ces in V\V,.

We first show the correctness and then the running time of Reduction Rule 3.
Lemma 2 Reduction Rule 3 is correct.

Proof Denote by s the size of a maximum matching in the input graph G = (V, E)
and by s’ the size of a maximum matching in the new graph G’ = (V’, E’), where
some edges incident to x are deleted. We need to show that s = s’. Since any match-
ing in G’ is also a matching in G, we easily obtain s > s’.

It remains to show s <s’. To this end, let Mg :=M2"*(Mc_y) be a maxi-
mum matching for G with the maximum overlap with Mc_y (see Sect. 2). If x
is free wrt. Mg or if x is matched to a vertex v that is also in G’ a neighbor of x,
then M, is also a matching in G’ (M, C E’) and thus we have s < s’. Hence, con-
sider the remaining case where x is matched to some vertex v such that {v,x} € E’,
that is, the edge {v,x} was deleted by Reduction Rule 3. Hence, x has k neigh-
bors v,,...,¥, in V\X such that each of these neighbors is free wrt. Mc¢_y and
none of the edges {v;,x},i € [k], was deleted. Observe that by the choice of Mg,
the graph G(M,_y,.M@) (the graph over vertex set V and the edges that are either
in Mg_y or in Mg, see Sect. 2) contains exactly s—|M¢_x| paths of length at
least one. Each of these paths is an augmenting path for Mg_y. By Observation 2,
we have s — |Mc-_y| < k. Observe that {v,x} is an edge in one of these augment-
ing paths; denote this path with P. Thus, there are at most k — | augmenting paths
in GMg_x, Mg) that do not contain x. Also, each of these paths contains exactly two
vertices that are free wrt. Mc_y: the endpoints of the path. This means that no ver-
tex in X is an inner vertex on such a path. Furthermore, since Mc_y is a maximum
matching, it follows that for each path at most one of these two endpoints is in V\X.
Hence, at most k — 1 vertices of v,,...,v, are contained in the k — | augmenting
paths of GW¢_y, Mg) except P. Consequently, one of these vertices, say v,, is free
wrt. M, and can be matched with x. Thus, by reversing the augmentation along P
and adding the edge {v,,x} we obtain another matching Mo of size s. Observe
that Mv. is a matching for G and for G’ and thus we have s < s’. This completes the
proof of correctness. oO

Q) Springer
Algorithmica (2020) 82:3521-3565 3531

Lemma 3 Reduction Rule 3 can be exhaustively applied in O(n + m) time.

Proof We exhaustively apply the data reduction rule as follows. First, initialize for
each vertex x € X a counter with zero. Second, iterate over all free vertices in G — X
in an arbitrary order. For each free vertex v € V\X iterate over its neighbors in X.
For each neighbor x € X do the following: if the counter is less than k, then increase
the counter by one and mark the edge {v, x} (initially all edges are unmarked). Third,
iterate over all vertices in X. If the counter of the currently considered vertex x 1s k,
then delete all unmarked edges incident to x. This completes the algorithm. Clearly,
it deletes edges incident to a vertex x € X if and only if x has k free neighbors
in V\X and the edges to these k neighbors are kept. The running time is O(n + m):
When iterating over all free vertices in V\X we consider each edge at most once.
Furthermore, when iterating over the vertices in X, we again consider each edge at
most once. LO

To finish Step 4, we exhaustively apply Reduction Rule 3 in linear time. After-
wards, there are at most k* free (wrt. to M c_x) leaves in G — X that have at least one
neighbor in X since each of the k vertices in X is adjacent to at most k free leaves.
Thus, applying Reduction Rule | we can remove the remaining free leaves that have
no neighbor in X. However, since for each degree-one vertex also its neighbor is
removed, we might create new free leaves in G — X and need to again apply Reduc-
tion Rule 3 and update the matching (see Step 3). This process of alternating appli-
cation of Reduction Rule | and 3 stops after at most k rounds since the neighborhood
of each vertex in X can be changed by Reduction Rule 3 at most once. This shows
the running time O(k(n + m)). We next show how to improve this to O(n +m). In
doing so, we arrive at the central proposition of this subsection, stating that Steps |
to 4 can be performed in linear time.

Proposition 1 Given a matching instance (G, s) and a feedback vertex set X, Algo-
rithm 1 computes in linear time an instance (G’, s') with feedback vertex set X and a
maximum matching Mg_y in G' — X such that the following holds.

— There is a matching of size s in G if and only if there is a matching of size s’ in G’.
— Each vertex in G' — X that is free wrt. Mg_y is a leaf in G’ — X.
— There are at most k? free leaves in G' — X.

Q) Springer
3532 Algorithmica (2020) 82:3521-3565

Algorithm 1: An algorithm performing Steps 1 to 4 in linear time.

Input: A matching instance (G = (V, £), s) and a feedback vertex set X C V for G
with |X| =k.
Output: An equivalent matching instance (G’, s’) such that X is also a feedback
vertex set for G’ and a maximum matching Mg _ x for G’ — X such that
only at most k? leaves in G’ — X are free with respect to Mg_x.

1 Reduce G wrt. Reduction Rules 1 and 2
2 Compute a maximum matching Mg_.x as described in Step 3 // see Observation 3
3 foreach x € X do c(x) <0 // c(x) will store the number of free neighbors for x
4 foreach e € E do marked(e) « False
5 L «+ stack containing all free leaves in G — X in any order
6 while L is not empty do
7 u < pop(L)
8 foreach x € Ne(u) NX do  _// Check if Reduction Rule 3 is applicable for x
9 c(a) + c(x) +1, marked({u,x}) < True // fix u as free neighbor of x
10 if c(z) =kthen // x has enough free neighbors: apply Reduction Rule 3
a1 foreach y € Ng(x) MX do delete {x,y}
12 foreach v € Ng(a) \ X do
13 if marked({x,v}) = False then
14 delete {x, uv}
/* Next deal with the case that v is a free leaf in G— X and x
was the last neighbor of v in X */
15 if dega(v) = dego_x(v) = 1 and v is free then push v on L
16 if dego(u) = dego_y(u) = 1 then // u has no neighbors in x
17 v © neighbor of u in G— X; w «+ matched neighbor of v
18 delete wu and v from G // apply Reduction Rule 1
19 Mea_-x « Me_x \ {{v, wh}, se s-1 // update Mg_x and s
/* augment along an arbitrary alternating path from w to a leaf in the
subtree rooted in w: */
20 while w is not a leaf in G— X do
21 w’ + arbitrary child of w; w’’ + matched neighbor of w’
22 Ma-x < (Ma_x \ {{w', wf }) U {{w, w"}}
23 we w"
24 push w to L // w is a free leaf, so add w to the list of vertices to check

25 return (G,s) and Mg_x.

Before proving Proposition 1, we explain Algorithm 1 which reduces the
graph with respect to Reduction Rules 1 and 3 and updates the matching Mg_y
as described in Step 3. The algorithm performs in Lines 1 and 2 Steps 1 to 3.
This can be done in linear time (see Observation 3). Next, Reduction Rule 3 is
applied in Lines 8 to 15 using the approach described in the proof of Lemma 3:
For each vertex in x a counter c(x) 1s maintained. When iterating over the free
leaves in G — X, these counters will be updated. If a counter c(x) reaches k, then
the algorithm knows that x has k fixed free neighbors and according to Reduc-
tion Rule 3 the edges to all other vertices can be deleted (see Line 10). Observe
that once the counter c(x) reaches k, the vertex x will never be considered again
by the algorithm since its only remaining neighbors are free leaves in G — X that

Q) Springer
Algorithmica (2020) 82:3521-3565 3533

 

Fig.1 Dealing with new degree-one vertices occurring during the application of Reduction Rule 3
within Step 4. Only vertices visited in the tree G — X in Lines 16—24 of Algorithm 1 are shown. Further
possible neighbors are indicated by edges. Left side: Vertex v is a free leaf in G — X (vertices in X are not
illustrated). The gray highlighted alternating path indicates where Algorithm | augments the maximum
matching Mg_y in G — X. Bold edges indicate edges in Mg_y. Vertex w” is the leaf where the augmenta-
tion stops (w” is matched, otherwise Mg_y would not be a maximum matching). Right side: Situation
after Algorithm 1 augmentation. Vertex w” will be added to the list L and further processed

already have been popped from the stack L. The only difference from the descrip-
tion in the proof of Lemma 3 is that the algorithm reacts if some leaf v in G—X
lost its last neighbor in X (see Line 15). If v is free, then add v to the stack L of
unmatched degree-one vertices and defer dealing with v to a second stage of the
algorithm (in Line 16 to 24). (If v is matched, then we deal with v in Step 6.)

We next discuss this second stage from Lines 16—24 (see Fig. | for an illustra-
tion): Let u be an entry in L such that u has degree one in Line 16, that is, uv is a free
leaf in G — X and has no neighbors in X. Then, following Reduction Rule 1, delete u
and its neighbor v and decrease the solution size s by one (see Lines 18 and 19).
Let w denote the previously matched neighbor of v. Since v was removed, w is now
free. If w is a leaf in G— X, then we can simply add it to LZ and deal with it later.
If w is not a leaf, then we need to update M;_y since only leaves are allowed to be
free. To this end, augment along an arbitrary alternating path from w to a leaf in the
subtree with root w (see Lines 20 to 23). This is done as follows: Pick an arbitrary
child w’ of w. Let w” be the matched neighbor of w’. Observe that w”’ has to exist
as if w’ would be free, then {w, w’} could be added to M¢_y; a contradiction to the
maximality of Mc_y. Since w is the parent of w’, it follows that w” is a child of w’.
Now, remove {w’, w’’} from M,_y, add {w’, w} and repeat the procedure with w’’
taking the role of w. Observe that the endpoint of this found alternating path, after
augmentation, always is a free leaf. Thus, this free leaf needs to be pushed to L. This
completes the algorithm description.

The correctness of Algorithm 1 (stated in the next lemma) follows in a straight-
forward way from the above discussion. For the formal proofs we introduce some
notation. We denote by G; (respectively M,) the intermediate graph (respectively
matching) stored by Algorithm 1 before the i” iteration of the while loop in Line 6,

Q) Springer
3534 Algorithmica (2020) 82:3521-3565

that is, G, is the input graph and M, is the initial matching computed in Line 2. The
following observation is easy to see but useful in our proofs.

Observation 4 For each i € {1,...,q} where g is the number of iterations of the
while loop in Line 6, we have that M; is a maximum matching for G, — X. If i > 2,
then G; is a subgraph of G,_,.

Lemma 4 Algorithm 1 is correct, that is, given a matching instance (G, s) and a
feedback vertex set X, it computes an instance (G’, s') with feedback vertex set X and
a maximum matching Mg_y in G' — X such that:

1. There is a matching of size s in G if and only if there is a matching of size s’ in G’.
2. Each vertex in G' — X that is free wrt. Mg_y is a leaf in G’ — X.
3. There are at most k? free vertices in G' — X.

Proof Observation 4 implies that the returned graph G’ is a subgraph of the input
graph G. Thus, X is a feedback vertex set for both these graphs. Moreover, by Obser-
vation 4, Mjg_y is a maximum matching for G’ — X.

As to 1, observe that Algorithm 1 obtains G’ from G by deleting edges in Line
14 according to Reduction Rule 3 and by deleting vertices in Line 18 according to
Reduction Rule 1. Thus, 1 follows from the correctness of these data reduction rules
(see Lemmas | and 2).

As to 2, observe that G—X is changed if and only if the matching Mc_, is
changed accordingly (see Lines 16 to 24 ). That is, after each deletion of vertices, the
algorithm ensures that only leaves are free. Moreover, during the algorithm M,_y, is
always a maximum matching for G — X.

As to 3, observe that any free leaf in G — X that is not removed needs to have a
neighbor in X (see Line 16). As Reduction Rule 3 is applied in Lines 8 to 15, there
are at most k* such free leaves. oO

We next show that Algorithm | runs in linear time. To this end, we need a further
technical statement.

Lemma 5 In G,, let P be an even-length alternating path wrt. M, from a free leaf r
to a matched inner vertex t of G, — X. Let u be the matched neighbor of t. Then for
each j € {1,...,t} there exists in G; an even-length alternating path P' from t to a
free leaf r’ such that the neighbor of t on P’ is either (i) u, (ii) t's parent, or (iii) a
vertex not contained in G;.

Proof We prove the statement of the lemma by induction on i. The base case i = 1 is
trivial since G, = G and thus P’ = P.

Now assume the statement is true for G,;_,, i > 2. We show that it holds for G,;
as well. By Observation 4, G; is a subgraph of G,_, (and of G). Thus, the path P is
also contained in G;_, (and in G). If r is a leaf in G,_; — X and if M, contains the
same edges of P as M,_,, then P is an even-length augmenting path in G,_, and the

Q) Springer
Algorithmica (2020) 82:3521-3565 3535

statement of the lemma follows from applying the induction hypothesis and Obser-
vation 4. Thus, assume that (a) r is not a leaf in G;_, — X or (b) M, does not contain
the same edges of P as M,_, (or both).

We start with case (a) assuming that r is not a leaf in G,_, —X. Then in
the (i — 1)‘ iteration of the while loop in Line 6, Algorithm 1 deleted the child r’
of r and the child r” of r’ in Line 18. Moreover, M,_, contained the edge {r, r’} and r”
was a free leaf in G,_, — X. Thus, extending P by the two vertices 7’, r’’ yields in G,_,
an even-length alternating path P* from ¢ to the free leaf r’’ such that the neigh-
bor of t on P* is u. Hence, the statement of the lemma follows from the induction
hypothesis and Observation 4.

We next consider case (b), assuming that M; and M,_, do not contain the same
edges of P. Thus, in the (i — 1)* iteration of the while loop in Line 6, Algorithm 1
augmented along some alternating path in Lines 20 to 23. Denote with Q this alter-
nating path and let w, be starting point of Q, that is, w, is the vertex w in Line 17.
Let v9, Ug be the two deleted vertices in Line 17. Let rg be the other endpoint of Q,
that is, rg is a leaf in G;_, and thus a free leaf in G;. Since M; and M,_, differ on P,
this implies that the two paths Q and P overlap. Let z be the vertex on P and on Q
which is closest to r. If z=r=r,, then P is a subpath of Q and in G;_, there is an
alternating path P* from ¢ to the free leaf up. (Here, P* is the part of Q that 1s not
contained in P.) Since the alternating path built in Line 20 to 23 is only extended
by selecting child vertices, this implies that w, = ¢ or w, is an ancestor of ¢. Thus,
the neighbor of ft in P* is either ?’s parent or Yo; that is, a child of ¢ not contained
in G;. Hence, the statement of the lemma follows from the induction hypothesis and
Observation 4.

It remains to consider the case that z # r. Let Zg (zp) be the neighbor of z that is
on Q but not on P (on P but not on Q); similarly let zpg be the neighbor of z that 1s
on both P and Q. Since Q is an alternating path either {2, Zp } or {Z, Zpg} 1s in Mj_,.

First consider the case that {z,Zg} 1s in M;_,. Then, since both the subpath of Q
from z to up and the subpath of P from z to r are alternating, we obtain an augment-
ing path from ug over z to r. This 1s a contradiction to the maximality of M;__.

Second, consider the case that {z, Zpg} is in M,_,. Thus, (after augmenting Q) the
edge {z, Zpg} is not in M,. Moreover, as {z, Zo} is in M,, the edge {z, zp} is also not
in M,. This contradicts the fact that P is an alternating path. O

Lemma6 Algorithm 1 runs in O(n + m) time.

Proof By Observation 3, Steps | to 3 in Lines | and 2 can be executed in linear time.
Moreover, it is easy to execute Lines 3 to 5 in one sweep over the graph, that is, in
linear time. It remains to show that Lines 6 to 24 run in linear time. To this end, we
prove that each edge in F is being processed at most two times in Lines 6 to 24.

Start with the edges with at least one endpoint in X. These edges will be inspected
at most twice by the algorithm: Once, when the edge is marked (see Line 9). The
second time is when the edge is checked and possibly deleted Lines 13 and 14. This
shows that the first part (Lines 8 to 15) runs in linear time.

Q) Springer
3536 Algorithmica (2020) 82:3521-3565

It remains to consider the edges within G — X. To this end, observe that the algo-
rithm performs two actions on the edges: deleting the edges (Line 18) and finding and
augmenting along an alternating path (Lines 20 to 23). Clearly, after deleting an edge
it will no longer be considered, so it remains to show that each edge is part of at most
one alternating path in Line 22. Assume toward a contradiction that the algorithm aug-
ments along an edge twice or more. From all the edges that are augmented twice or
more let e € E be one that is closest to the root of the tree containing e, that is, there is
no edge closer to a root. Let P, and P, be the first two augmenting paths containing e.
Assume without loss of generality that the algorithm augmented along P, in iteration i,
and along P, in iteration i, of the while loop in Line 6 withi, < i,. Let w, and w, be the
two start points (the respective vertex w in Line 17) of P, and P, respectively. Let u,
and v, (wu and v,) be the vertices deleted in Line 18 which in turn made w, (w,) free.
Observe that e does not contain any of these four vertices u,,Vv,,U,V, since before
augmenting P, (P,) the vertices u, and v, (u, and v,) are deleted in Line 18. Since e is
contained in both paths, either w, is an ancestor of w, or vice versa (or Ww, = W3).

Assume first that w, is an ancestor of w,. Thus, e = {w,,w,} where w, #v,
and w' is a child of w, (see Line 21). Consider G;, and M,, before the augmentation
along P,. Clearly, in G;, there is an alternating path of length two from w, to the
free leaf u,. Thus, by Lemma 5, in G; there is an alternating path Q, from w, to a
free leaf r such that r and w, are not in the same subtree of w,. Moreover, by choice
of e the two matchings M; and M,, contain the same edges on the path from w,
to w, in G — X. Hence, there is an alternating path Q, from w, to w, inG;. There is
also an alternating path Q, from w, to the free leaf uw, in G; (see Line 17). Combin-
ing Q;,Q),Q; gives an augmenting path from u, to r in G;; a contradiction to the
maximality of M 7 (see Observation 4).

Next, consider the case that w, = w,. By choice of e we have that e = {w,,w’}
with w’ being a child of w, in G;, and w’ # v,. Thus, after the augmentation along P,
the edge e is matched (see Line 21). This is a contradiction to the choice of P, and
the fact that {w5, v,} € M,, (see Line 17).

Finally, consider the case that w, is an ancestor of w,. By choice of e we have
that e = {w2,w,} with w), being a child of w, in G,, and w, # vj. From the argu-
mentation used in the case w, = w, above, we can infer that after augmenting P,
the edge e 1s not matched, thus e ¢ M; ,,; and e € M,. Observe that in G;, there is a
length-two alternating path from w, to the free leaf u,. Thus, by Lemma 5, there is an
even-length alternating path P from w, to a free leaf in G;. Moreover, the (matched)
neighbor Wy of w, in P is either (1) v,, (ii) the parent of w,, or (111) a vertex not in G;,.-
Since e € M,, it follows that w, is the matched neighbor of w, on P. However, w, 1s

2 2
in G;,, 1s neither the parent of w, nor of vy, a contradiction. O

Proposition | now follows from Lemmas 4 and 6.

3.2.2 Step 5

In this step we reduce the graph in O(kn) time so that at most k?(2* + 1) bottommost
leaves will remain in the forest G — X. We will restrict ourselves to consider leaves
that are matched with their parent vertex in M;_y and that do not have a sibling.
We call these bottommost leaves interesting. Any sibling of a bottommost leaf is by

Q) Springer
Algorithmica (2020) 82:3521-3565 3537

definition also a leaf. Thus, at most one of these leaves (the bottommost leaf or one
of its siblings) is matched with respect to M¢_y and all other leaves are free. Recall
that in the previous step we upper-bounded the number of free leaves with respect
to Mc_y by k?. Hence there are at most 2k” bottommost leaves that are not interest-
ing (each free leaf can be a bottommost leaf with a sibling matched to the parent).

Our general strategy for this step is to extend the idea behind Reduction Rule
3: We want to keep for each pair of vertices x,y € X at most k different inter-
nally vertex-disjoint augmenting paths from x to y. In this step, we only consider
augmenting paths of the form x, u, v, y where v is a bottommost leaf and u is v’s
parent in G — X. Assume that the parent u of v is adjacent to some vertex x € X.
Observe that in this case any augmenting path starting with the two vertices x
and u has to continue to v and end in a neighbor of v. Thus, the edge {x,u} can
be only used in augmenting paths of length three. Furthermore, for different par-
ent vertices u # uw’ the length-three augmenting paths are clearly internally vertex-
disjoint. If we do not need the edge {x,u} because we kept k augmenting paths
from x to each neighbor y € N(v) NX already, then we can delete {x, wu}. Further-
more, if we deleted the last edge from u to X (or u had no neighbors in X in the
beginning), then uw is a degree-two vertex in G and can be removed by applying
Reduction Rule 2. As the child v of uw is a leaf in G— X, it follows that v has at
most k+ 1 neighbors in G. We show below (Lemma 7) that the application of
Reduction Rule 2 to remove u takes O(k) time. As we remove at most 7 vertices,
at most O(kn) time is spent on Reduction Rule 2 in this step.

We now show that, after a simple preprocessing, one application of Reduction
Rule 2 in the algorithm above can indeed be performed in O(k) time.

Lemma 7 Let u be a leaf in the tree G — X, v be its parent, and let w be the parent
of v. If v has degree two in G, then applying Reduction Rule 2 to v (deleting v, merg-
ing u and v, and setting s := s — 1) can be done in O(k) time plus O(kn) time for an
initial preprocessing.

Proof The preprocessing is to simply create a partial adjacency matrix for G with
the vertices in X in one dimension and V in the other dimension. This adjacency
matrix has size O(kn) and can clearly be computed in O(kn) time.

Now apply Reduction Rule 2 to v. Deleting v takes constant time. To merge u
and w iterate over all neighbors of u. If a neighbor uv’ of u is already a neighbor of w,
then decrease the degree of u’ by one, otherwise add wv’ to the neighborhood of w.
Then, relabel w to be the new merged vertex uw.

Since uw is a leaf in G — X and its only neighbor in G — X, namely y, is deleted, it
follows that all remaining neighbors of u are in X. Thus, using the above adjacency
matrix, one can check in constant time whether w’ is a neighbor of w. Hence, the
above algorithm runs in O(deg(u)) = O(k) time. O

The above ideas are used in Algorithm 2 which we use for this step (Step 5). The

algorithm is explained in the proof of the following proposition stating the correct-
ness and the running time of Algorithm 2.

Q) Springer
3538 Algorithmica (2020) 82:3521-3565

Algorithm 2: An algorithm performing Step 5 in O(kn) time.

Input: A matching instance (G = (V, E),s), a feedback vertex set X C V of size k
for G with k < logn, and a maximum matching Mg_x for G— X with at
most k? free vertices in G — X that are all leaves.

Output: An equivalent matching instance (G’, s’) such that X is also a feedback
vertex set for G’ and G’ — X is a tree with at most k?(2* 4+ 1)
bottommost leaves, and a maximum matching Mg_ x for G’ — X with
at most k? free vertices in G’ — X that are all leaves.

1 Fix an arbitrary bijection f: 2* > {1,...,2*}
2 foreach v € V \ X do
3 L Set fx(v) — f(N(v) AX) // The number fx(v) <n can be read in constant

time.

a Initialize a table Tab of size k - 2" with Tab[zx, f(Y)] <0 for alla Ee X,OCY CX
5 P< list containing all parents of interesting bottommost leaves
6 while P is not empty do

7 u + pop(P)
8 v < child vertex of u in G—-— X
9 foreach x € N(u)N X do
10 if Tab[x, fx (v)] < k then
11 | Tabla, fx (v)] <— Tabla, fx (v)] +1
12 else
13 [ delete {z, u}
14 if u has now degree two in G then
15 Apply Reduction Rule 2 to u // This decreases s by one.
16 vw + vertex resulting from merging v and the parent w of u
17 if vw is now an interesting bottommost leaf then
18 [ add the parent of vw to P

19 return (G,s) and Mg_x.

Proposition 2 Let (G = (V,E),s) be a Matcuina instance, let X C V be a feedback
vertex set, and let Mg_y be a maximum matching for G— X with at most k* free
vertices in G—X that are all leaves. Then, Algorithm 2 computes in O(kn) time
an instance (G',s') with feedback vertex set X and a maximum matching Mg_x
in G’ — X such that the following holds.

— There is a matching of size s in G if and only if there is a matching of size s’ in G’.
— There are at most 2k*(2* + 1) bottommost leaves in G! — X.
— There are at most k* free vertices in G' — X and they are all leaves.

Proof We start with describing the basic idea of the algorithm. To this end,
let {u,v} € E be an edge such that v is an interesting bottommost leaf, that is, v
has no siblings and is matched to its parent u by Mg_y. Counting for each
pair x € N(u)NX and y € N(v)NX one augmenting path in a simple worst-case
analysis gives O(k) time per edge, which is too slow for our purposes. Instead, we
count for each pair consisting of a vertex x € N(u) NX and a set Y = N(v) NX one
augmenting path. In this way, we know that for each y € Y there is one augmenting

Q) Springer
Algorithmica (2020) 82:3521-3565 3539

path from x to y without iterating through all y € Y. This comes at the price of con-
sidering up to k2* such pairs. However, we will show that we can do the computa-
tions in O(k) time per considered edge in G — X. The main reason for this improved
running time is a simple preprocessing that allows for a bottommost vertex v to
determine N(v) NX in constant time.

The preprocessing is as follows (see Lines 1 to 3): First, fix an arbitrary bijec-
tion f between the set of all subsets of X to the numbers {1,2,...,2*}. This can be
done for example by representing a set Y CX = {x,,...,x,} by a length-& binary
string (a number) where the i position is 1 if and only if x, € Y. Given a set Y C X
such a number can be computed in O(k) time in a straightforward way. Thus, Lines
1 to 3 can be performed in O(kn) time. Furthermore, since we assume that k < logn
(otherwise the input instance has already at most 2* vertices), we have that f(Y) <n
for each Y C X. Thus, reading and comparing these numbers can be done in constant
time. Furthermore, in Line 3 the algorithm precomputes for each vertex the number
corresponding to its neighborhood in X.

After the preprocessing, the algorithm uses a table Tab where it counts an aug-
menting path from a vertex x € X to a set Y C X whenever a bottommost leaf v has
exactly Y as neighborhood in X and the parent of v is adjacent to x (see Lines 4
to 18). To do this in O(kn) time, the algorithm proceeds as follows: First, it com-
putes in Line 5 the set P which contains all parents of interesting bottommost leaves.
Clearly, this can be done in linear time. Next, the algorithm processes the vertices
in P. Observe that further vertices might be added to P (see Line 18) during this
processing. Let u be the currently processed vertex of P, let v be its child vertex, and
let Y be the neighborhood of v in X. For each neighbor x € N(u) NX, the algorithm
checks whether there are already k augmenting paths between x and Y with a table
lookup in Tab (see Line 10). If not, then the table entry is incremented by one (see
Line 11) since u and v provide another augmenting path. If yes, then the edge {x, u}
is deleted in Line 13 (we show below that this does not change the maximum match-
ing size). If u has degree two after processing all neighbors of u in X, then, by apply-
ing Reduction Rule 2, we can remove u and merge its two neighbors v and w. It
follows from Lemma 7 that this application of Reduction Rule 2 can be done in O(k)
time. Hence, one iteration of the while loop requires O(k) time and thus Algorithm 2
runs in O(kn) time.

Recall that all vertices in G—X that are free wrt. Mc_y are leaves. Thus, the
changes to Mc_y by applying Reduction Rule 2 in Line 15 are as follows: First,
the edge {u,v} is removed and second the edge {w,q} is replaced by {vw,q} for
some g € V. Hence, the matching Mg_y after running Algorithm 2 has still at
most k? free vertices and all of them are leaves.

It remains to prove that

(a) the deletion of the edge {x, uw} in Line 13 results in an equivalent instance and
(b) that the resulting instance has at most 2k?(2* + 1) bottommost leaves.

First, we show (a). To this end, assume towards a contradiction that the new

graph G’ := G — {x,u} has a smaller maximum matching than G (clearly, G’ can-
not have a larger maximum matching). Thus, any maximum matching M, for G has

Q) Springer
3540 Algorithmica (2020) 82:3521-3565

to contain the edge {x,u}. This implies that the child v of u in G—X is matched
in Mg with one of its neighbors (except u): If v is free wrt. MG, then deleting {x, u}
from M¢ and adding {v, uv} yields another maximum matching not containing {x, uv},
a contradiction. Recall that N(v) = {u} UY where Y C X since vis a leaf inG—X.
Thus, each maximum matching M;, for G contains for some y € Y the edge {y, y}.
Observe that Algorithm 2 deletes {x, u} only if there are at least k other interesting
bottommost leaves v,,...,v, in G—X such that their respective parent is adjacent
to x and N(v;) NX = Y (see Lines 9 to 13). Since |Y| < k, it follows by the pigeon-
hole principle that at least one of these vertices, say v;, is not matched to any ver-
tex in Y. Thus, since v; is an interesting bottommost leaf, it is matched to its only
remaining neighbor: its parent vu; in G— X. This implies that there is another maxi-
mum matching

Mo = (Mco\{{v.y}, {x,U}, {uj;,V;}}) U {{Vi VI; {x, U;}; {u, V}},

a contradiction to the assumption that all maximum matchings for G have to con-
tain {x, uv}.

We next show (b) that the resulting instance has at most 2k*(2* + 1) bottom-
most leaves. To this end, recall that there are at most 2k* bottommost leaves that
are not interesting (see discussion at the beginning of this subsection). Hence, it
remains to upper-bound the number of interesting bottommost leaves. Observe that
each parent u of an interesting bottommost leaf has to be adjacent to a vertex in X
since otherwise u would have been deleted in Line 15. Furthermore, after running
Algorithm 2, each vertex x € X is adjacent to at most k2* parents of interesting bot-
tommost leaves (see Lines 10 to 13). Thus, the number of interesting bottommost
leaves is at most k?2*. Hence, the number of bottommost leaves is upper-bounded
by 2k?(2* + 1). oO

3.2.3 Step 6

In this subsection, we provide the final step of our kernelization algorithm. Recall
that in the previous steps we have upper-bounded the number of bottommost leaves
in G— X by O(k?2*). We also computed a maximum matching M,_y for G — X such
that at most k? vertices are free wrt. M,_y and all free vertices are leaves in G — X.
Using this, we next show how to reduce G to a graph of size O(k*2*). To this end
we need some further notation. A leaf in G — X that is not bottommost is called a
pendant. We define T to be the pendant-free tree (forest) of G — X, that is, the tree
(forest) obtained from G — X by removing all pendants. The next observation shows
that G — X is not much larger than 7. This allows us to restrict ourselves on giving
an upper bound on the size of T instead of G — X.

Observation 5 Let G — X be as described above with vertex set V\X and let T be the
pendant-free tree (forest) of G — X with vertex set V. Then, |V\X| < 2|V;| + k’.

Q) Springer
Algorithmica (2020) 82:3521-3565 3541

Proof Observe that V\X is the union of all pendants in G— X and V,. Thus, it suf-
fices to show that G — X contains at most |V,-| + k* pendants. To this end, recall that
we have a maximum matching for G — X with at most k* free leaves. Thus, there are
at most k* leaves in G — X that have a sibling which is also a leaf since from two
leaves with the same parent at most one can be matched. Hence, all but at most k?
pendants in G — X have pairwise different parent vertices. Since all these parent ver-
tices are in V;, it follows that the number of pendants in G — X is |V,-| + k’. O

We use the following observation to provide an upper bound on the number of
leaves of T.

Observation 6 Let F be a forest, let F’ be the pendant-free forest of F, and let B be
the set of all bottommost leaves in F’. Then, the set of leaves in F’ is exactly B

Proof First observe that each bottommost leaf of F is a leaf of F’ since no bottom-
most leaf is removed and F’ is a subgraph of F. Thus, it remains to show that each
leaf v in F’ is a bottommost leaf in F.

We distinguish two cases of whether or not v is a leaf in F: First, assume that v
is not a leaf in F. Thus, all of its child vertices have been removed. Since we only
remove pendants to obtain F’ from F and since each pendant is a leaf, it follows
that v is in F the parent of one or more leaves u,,...,u~. Thus, by definition, all
these leaves u,,...,u, are bottommost leaves, a contradiction to the fact that they
were deleted when creating F’.

Second, assume that v is a leaf in F. If v is a bottommost leaf, then we are done.
Thus, assume that v is not a bottommost leaf and hence a pendant. However, since
we remove all pendants to obtain F” from F, it follows that v is not contained in F’, a
contradiction. O

From Observation 6 it follows that the set B of bottommost leaves in G — X
is exactly the set of leaves in JT. In the previous step we reduced the graph such
that |B] < 2k?(2* + 1) (see Proposition 2). Thus, T has at most 2k*(2* + 1) vertices
of degree one and, since T is a tree (a forest), T also has at most 2k7(2* + 1) ver-
tices of degree at least three. Let Ve be the vertices of degree two in T and let vir
be the remaining vertices in T. From the above it follows that \Vz"| < 4k7(2* + i).
Hence, it remains to upper-bound the size of Ve. To this end, we ‘will upper-bound
the degree of each vertex in X by O(k*2*) and then use Reduction Rule | and 2.
We will check for each edge {x,v} € E with x € X and v € V\X whether we
“need” it. This check will use the idea from the previous subsection where each
vertex in X needs to reach each subset Y C X at most k times via an augmenting
path. Similarly as in the previous subsection, we want to keep “enough” of these
augmenting paths. However, this time the augmenting paths might be long and
different augmenting paths might overlap. To still use the basic approach, we use
the following lemma stating that we can still somehow replace augmenting paths.

Q) Springer
3542 Algorithmica (2020) 82:3521-3565

Lemma 8 Let Mc_y be a maximum matching in the forest G — X. Let P,,,, be an aug-
menting path for Mg_y in G from u to v. Let P,,,, Py,, and P,,. be three internally
vertex-disjoint augmenting paths from w to x, y, and z, respectively, such that P,,,,
intersects all of them. Then, there exist two vertex-disjoint augmenting paths with

endpoints u, v, w, and one of the three vertices x, y, and z.

Proof Label the vertices in P,,,, alternating as odd or even with respect to P,,,, so that
no two consecutive vertices have the same label, u is odd, and v is even. Analo-
gously, label the vertices in P,,,, P,,,, and P,,. as odd and even with respect to P,,.,
Py. and P,,., respectively, so that w is always odd. Since all these paths are aug-
menting, it follows that each edge from an even vertex to its succeeding odd vertex
is in the matching M,_y and each edge from an odd vertex to its succeeding even
vertex is not in the matching. Observe that P,,,, intersects each of the other paths at
least at two consecutive vertices, since every second edge must be an edge in Mc_y.
Since G — X is a forest and all vertices in X are free with respect to M,_y, it follows
that the intersection of two augmenting paths is connected and thus a path. Since P,,,
intersects the three augmenting paths from w, it follows that at least two of these
paths, say P,,, and P,,,, have a “fitting parity”, that is, in the intersections of P,,,
with P,,, and with P,,, the even vertices with respect to P,,, are either even or odd
with respect to both P,,, and P,,,,.

Assume without loss of generality that in the intersections of the paths the ver-
tices have the same label with respect to the three paths (if the labels differ, then
revert the ordering of the vertices in P,,,,, that is, exchange the names of u and v and
change all labels on P,,, to their opposite). Denote with v and v/ the first and the last
vertex in the intersection of P,,,, and P,,,. Analogously, denote with ve and v? the first
and the last vertex in the intersection of P,,, and P,,,. Assume without loss of gener-
ality that P,,, intersects first with P,,, and then with P,,,. Observe that v! and v2 are
even vertices and vi and ve are odd vertices since the intersections have to start and
end with edges in Mg_y (see Fig. 2 for an illustration). For an arbitrary path P and
for two arbitrary vertices p,,p, of P, denote by p, — P — p, the subpath of P from p,
to p. Observe that u—P,,,—v) —P,,—x and w—P,, —v? — P,,, —v are vertex-
disjoint augmenting paths. oO

Algorithm description. We now provide the algorithm for Step 6 (see Algo-
rithm 3 for pseudocode). The algorithm uses the same preprocessing (see
Lines | to 3) as Algorithm 2. Thus, the algorithm can determine whether two
vertices have the same neighborhood in X in constant time. As in Algorithm 2,
Algorithm 3 uses a table Tab which has an entry for each vertex x € X and
each set Y C X. The table is filled in such a way that the algorithm detected for
each y € Y at least Tab [x, Y] internally vertex-disjoint augmenting paths from x
to y. The main part of the algorithm is the boolean function ‘Keep-Edge’ in Line
13 to 22 which makes the decision on whether to delete an edge {x, v} forv € V\X
and x € X. The function works as follows for edge {x,v}: Starting at v the graph
will be explored along possible augmenting paths until a “reason” for keeping

Q) Springer
Algorithmica (2020) 82:3521-3565 3543

Fig.2 The situation in the proof of Lemma 8. The augmenting path from u to v intersects the two aug-
menting paths P,,, and P,,, from w to x and y, respectively. Bold edges indicate edges in the matching,
dashed edges indicate odd-length alternating paths starting with the first and last edge not being in the
matching. The gray paths in the background highlight the different augmenting paths: the initial paths
from u to v, w to x, and x to y as well as the new paths from u to x and w to v as postulated by Lemma 8

 

Fig.3 Illustration of the graph exploration of the function Keep-Edge in Algorithm 3: The vertices x and
y are vertices in the feedback vertex set X. The vertices v,,...,V,g are part of G— X where vj, is a free
leaf. The matching Mg_y is denoted by the thick edges. Three alternating paths are highlighted; each
path represents an exploration of Keep-Edge from x that returns true: First, the path via v3 ends in v;—a
vertex with degree more than two in G — X (see Line 14). The second path via v, ends in v;—a vertex
connected to two vertices in X (here we assume that there are less than 6k’ paths from x to vertices adja-
cent to y and z; see Lines 17-19). The third path via vg ends in the free leaf v,, (see Line 14)

the edge {x,v} is found or no further exploration is possible (see Fig. 3 for an
ulustration).

Q) Springer
3544 Algorithmica (2020) 82:3521-3565

Algorithm 3: An algorithm for computing Step 6 in O(kn) time.

Input: A matching instance (G = (V, E), s), a feedback vertex set X C V of size k
for G with k < logn and at most k?(2* + 1) bottommost leaves in G— X,
and a maximum matching Mg_x for G— X with at most k? free vertices
in G — X that are all leaves.

Output: An equivalent matching instance (G’, s’) such that G’ contains at

most O(k°2*) vertices and edges.
1 Fix an arbitrary bijection f: 2* > {1,...,2*}
2 foreach v € V \ X do
L Set fx(v) <— f(N(v) AX) // The number fx(v) <n can be read in constant
time.

»d

Initialize a table Tab of size k- 2* with Tab[x, f(Y)] <0 forx E X,OCY CX
5 T + pendant-free tree (forest) of G— X

Viz3 < vertices in T with degree > 3

6

7 foreach x € X do

8 foreach v € N(x) \ X do

9 if Keep-Edge(x,v) = false then // Is {x,v} needed for an augmenting
path?

10 [ delete {x,v}

11 Exhaustively apply first Reduction Rule 1 and then Reduction Rule 2
12 return (G,s).

13 Function Keep-Edge(x € X,v EV \ X)

14 if v is free wrt. Mg_x orve Vz" then return true

15 w < matched neighbor of v in Mg_x

16 if w € Vz3 or w is adjacent to a free leaf in G— X then return true

17 if w has at least one neighbor in X and Tab[z, fx (w)] < 6k? then

18 Tab|x, fx (w)] <— Tab[x, fx (w)] +1

19 return true

20 foreach u € N(w) \ {vu} that is matched wrt. Mg_x and fulfills {u,x} € E do
21 [ if Keep-Edge(u,x) = true then return true

22 return false

If the vertex v is free wrt. Mc_y, then {x,v} is an augmenting path and we
keep {x,v} (see Line 14). Observe that in Step 4 (see Proposition 1) we upper-
bounded the number of free vertices by k? and all these vertices are leaves. Thus, we
keep a bounded number of edges incident to x because the corresponding augment-
ing paths can end at a free leaf. We provide the exact bound below when discussing
the size of the graph returned by Algorithm 3. In Line 14, the algorithm also stops
exploring the graph and keeps the edge {x, v} if v has degree at least three in T. The
reason is to keep the graph exploration simple by following only degree-two verti-
ces in 7. This ensures that the running time for exploring the graph from x does not
exceed O(n). Since the number of vertices in T with degree at least three is bounded
(see discussion after Observation 6), it follows that only a bounded number of such
edges {x, v} are kept.

If v is not free wrt. Mc_y, then it is matched with some vertex w. If w is adja-
cent to some leaf u in G — X that is free wrt. Mc_y, then the path x, v, w, uv is an
augmenting path. Thus, the algorithm keeps in this case the edge {x,v}, see Line

Q) Springer
Algorithmica (2020) 82:3521-3565 3545

16. Again, since the number of free leaves is bounded, only a bounded number
of edges incident to x will be kept. If w has degree at least three in T, then the
algorithm stops the graph exploration here and keeps the edge {x,v}, see Line 16.
Again, this is to keep the running time at O(kn) overall.

Let Y C X denote the neighborhood of w in X. Thus the partial augmenting
path x, v, w can be extended to each vertex in Y. Thus, if the algorithm did not
yet find 6k* paths from x to vertices whose neighborhood in X is also Y, then the
table entry Tab [x, f,(w)] (where f,(w) encodes the set Y = N(w) NX) is increased
by one and the edge {x, v} will be kept (see Lines 18 and 19). (Here we need 6k
paths since these paths might be long and intersect with many other augmenting
paths, see proof of Proposition 3 for the details of why 6k’ is enough.) If the algo-
rithm already found 6k* “augmenting paths” from x to Y, then the neighborhood
of w in X is irrelevant for x and the algorithm continues.

In Line 20, all above discussed cases to keep the edge {x, v} do not apply and
the algorithm extends the partial augmenting part x, v, w by considering the
neighbors of w except v. Since the algorithm dealt with possible extensions to
vertices in X in Lines 17 and 19 and with extensions to free vertices in G—X
in Line 14, it follows that the next vertex on this path has to be a vertex u that
is matched wrt. M,_y. Furthermore, since we want to extend a partial augment-
ing path from x, we require that wu is not adjacent to x: otherwise the length-one
path x, u would be another, shorter partial augmenting path from x to u and we do
not need the currently stored partial augmenting path.

Statements on Algorithm 3. To show that Algorithm 3 indeed performs Step 6,
we need further lemmas. For each edge {x,z} with x € X and z € V\X we denote
by P(x, z) the induced subgraph of G — X on the vertices that are explored in the
function Keep-Edge when called in Line 9 with x and z. More precisely, we ini-
tialize P(x, z) := @. Whenever the algorithm reaches Line 14, we add v to P(x, z).
Furthermore, whenever the algorithm reaches Line 17, we add w to P(x, z). Simi-
larly, when the recursive call in Line 21 returns true, then we add u to P(x, z) in
the recursive call (with u taking the role of v).

We next show that P(x, z) is a path with at most one additional pendant.

Lemma9 Let x € X and z € V\X be two vertices such that {x,z} € E. Then, P(x, z)
is either a path or a tree with exactly one vertex z' having more than two neighbors
in P(x, z). Furthermore, z’ has degree exactly three and z is a neighbor of z’.

Proof We first show that all vertices in P(x, z) except z and its neighbor z’ have
degree at most two in P(x, z). Observe that having more vertices than z and z’
in P(x, z) requires Algorithm 3 to reach Line 20.

Let w be the currently last vertex when Algorithm 3 continues the graph explora-
tion in Line 20. Observe that the algorithm therefore dealt with the case that w has
degree at least three in the pendant-free tree Tin Line 16. Thus, w is either a pendant
leaf inG-—X orw¢€ ve (that is, w has degree at most two in 7). In the first case,
there is no candidate to continue and the graph exploration stops. In the second case,
w has degree at most two in T.

Q) Springer
3546 Algorithmica (2020) 82:3521-3565

We next show that any candidate u for continuing the graph exploration in Line
21 is not a leaf in G— X. Assume toward a contradiction that u is a leaf inG—X.
Since the parent w of u is matched with some vertex v ¥ u (this is how w is chosen,
see Line 15), it follows that u is not matched. This implies that the function ‘Keep-
Edge’ would have returned true in Line 16 and would not have reached Line 20, a
contradiction. Thus, the graph exploration follows only vertices in T. Furthermore,
the above argumentation implies that w is not adjacent to a leaf unless this leaf is its
predecessor v in the graph exploration.

We now have two cases: Either w is not adjacent to a leaf inG-—X orv=zisa
leaf and w = z’ is its matched neighbor. In the first case, w has at most one neigh-
bor u # v since w ¢ ve>, Hence, w has degree two in P(x, z). In the second case,
w = Z’ has at most two neighbors u # v and u’ # v. Thus, z’ has degree at most three.

oO

For x € X let
P, := {Pa v) | {xv} EE AVE V\X}

be the union of all induced subgraphs that Algorithm 3 explores from x.

Lemma 10 There exists a partition of P,, into P,, = =P! U Pe such that all graphs
within Pp and within P? are pairwise disjoint.

Proof Since G — X is a tree (or forest), G — X is also bipartite. Let A and B be its two
color classes (so AU B = V\X). We define the two parts Pe and P? as follows: A
subgraph P € P, is in Pp if the neighbor v of x in P is contained i in A, otherwise P is
in P®.

We show that all subgraphs in Pe and Pe are pairwise vertex-disjoint. To this end,
assume toward a contradiction that two graphs P,QE Pp share some vertex. (The
case P,Q € Poi is completely analogous.) Let p, and q, be | the first vertex in P and Q
respectively, that j iS, p, and q, are adjacent to x in G. Observe that p, # q,. Letu #x
be the first vertex that is in P and in Q. By Lemma 9, P and @ are paths or trees with
at most one vertex of degree more than two and this vertex has degree three and
is the neighbor of p, or g,, respectively. This implies together with g,,p, € A that
either u = p, or u = q,. Assume without loss of generality that u = p,. Since p, € A
and gq, € A and wis a vertex in Q, it follows that Algorithm 3 followed u in the graph
exploration from q, in Line 21. However, this is a contradiction since the algorithm
checks in Line 20 whether the new vertex u in the path is not adjacent to x. Thus, all
subgraphs in Pe and P? are pairwise vertex-disjoint. O

We next show that if Tab [x,f(Y)] = 6k* for some x € X and Y C X (recall that f

maps Y to a number, see Line 1), then there exist at least 3k2 internally vertex-dis-
joint augmenting paths from x to Y.

Lemma 11 /f in Line 17 of Algorithm 3 it holds for xEX and YCX
that Tab [x, f(Y)] = 6k, then there exist in G wrt. Mg_y at least 3k2 alternating

Q) Springer
Algorithmica (2020) 82:3521-3565 3547

paths from x to vertices V1, ...,V3,2 such that all these paths are pairwise vertex-
disjoint (except x) and N(v,) NX = N(Ww) NX foralli € [3k7].

Proof Note that each time Tab[x,f(Y)] is increased by one (see Line 18), the
algorithm found a vertex w such that there is an alternating path P from x to w
and N(w)N X = Y. Furthermore, since the function Keep-Edge returns true in this
case, the edge from x to its neighbor on P is not deleted in Line 10. Thus, there
exist at least 6k* alternating paths from x to vertices whose neighborhood in X is
exactly Y. By Lemma 10, it follows that at least half of these 6k? paths are vertex-
disjoint. O

The next lemma shows that Algorithm 3 is correct and runs in O(kn) time.

Proposition 3 Let (G=(V,E),s) be a matching instance, let X C V be a feed-
back vertex set of size k with k <logn and at most 2k*(2* + 1) bottommost leaves
in G — X, and let Mg_y be a maximum matching for G — X with at most k? free verti-
ces inG — X that are all leaves. Then, Algorithm 3 computes in O(kn) time an equiv-
alent instance (G', s’) of size O(k>2*).

Proof We split the proof into three claims, one for the correctness of the algorithm,
one for the returned kernel size, and one for the running time. O

Claim 1 The input instance (G, s) is a yes-instance if and only if the instance (G’, s’)
produced by Algorithm 3 is a yes-instance.

Proof Observe that the algorithm changes the input graph only in two lines: Lines
10 and 11. By Lemma 1, applying Reduction Rules | and 2 yields an equivalent
instance. Thus, it remains to show that deleting the edges in Line 10 1s correct, that
is, it does not change the size of a maximum matching. To this end, observe that
deleting edges does not increase the size of a maximum matching. Thus, we need to
show that the size of the maximum matching does not decrease. Assume toward a
contradiction that it does.

Let {x,v} be the edge whose deletion decreased the maximum match-
ing size. Redefine G to be the graph before the deletion of {x,v} and G’ to be
the graph after the deletion of {x,v}. Recall that Algorithm 3 gets as addi-
tional input a maximum matching Mg_y for G—X. Let Mg :=Me"(Mc_y)
be a maximum matching for G with the largest possible overlap with Mg_y and
letG” := G(Mc_y,M.) = (V.Mg_y LA Mg) (see Sect. 2). Since {x, v} € Mo\Mc_y
and x is free wrt. M,_y, it follows that there is a path P in G” with one endpoint
being x.

Recall (see Sect. 2) that since P is a path in G” it follows that P is an augmenting
path for Mc_y. Since all vertices in X are free wrt. Mg_y, it follows that all vertices
in P except the endpoints are in V\X. Let z be the second endpoint of this path P.
We call a vertex on P an even (odd) vertex if it has an even (odd) distance to x on P.
(So x is an even vertex and v and z are odd vertices). Observe that v is the only odd

Q) Springer
3548 Algorithmica (2020) 82:3521-3565

vertex in P adjacent to x: Otherwise there would be another augmenting path from x
to z which only uses vertices from P. This would imply the existence of another
maximum matching that does not use {x, v}, a contradiction.

Let u be the neighbor of z in P. Since no odd vertex on P except v is adjacent
to x, it follows that the graph exploration in the function Keep-Edge starting from x
and v in Line 9 either reached u or returned true before. If z € V\X, then in both
cases, the function Keep-Edge would have returned true in Line 9 and Algorithm 3
would not have deleted {x, v}, a contradiction. Thus, assume that z € X. Therefore,
the function Keep-Edge considered the vertex u in Line 17 but did not keep the
edge {x,v}. Thus, when considering u, it holds that Tab [x, f,(u)] = 6k*, where fy(w)
encodes Y := N(u) NX and ze Y.

By Lemma 11, it follows that there are 3k* pairwise vertex-disjoint (except x)
alternating paths from x to vertices u,,...,U3,. with N(u;) NX = Y. Thus, there
is a set O of 3k* internally vertex-disjoint paths from x to y in G. If one of the
paths Q € Q does not intersect any path in G”, then reverting the augmentation
along P and augmenting along Q would result in another maximum matching not
containing {x, v}, a contradiction. Thus, assume that each path in Q intersects at least
one path in G™.

For each two paths Q,,Q, € Q that intersect the same path P’ in G™” it holds that
each further path P” in G” can intersect at most one of Q, and Q,: Assume toward
a contradiction that P’”’ does intersect both Q, and Q,. Since no path in G” except P
contains x and z it follows that all intersections between the paths are within G — X.
Since P’ and P” are vertex-disjoint and Q, and Q, are internally vertex-disjoint, it
follows that there is a cycle in G — X, a contradiction to the fact that X is a feedback
vertex set.

Since 3k* > 3k +k’, it follows from the pigeon hole principle that there is a
path P’ € G” that intersects at least three paths Q,, Q,,Q3 € Q such that no further
path in G” intersects them. We can now apply Lemma 8 and obtain two vertex-dis-
joint augmenting paths Q and Q’. Thus, reverting the augmentation along P and P”
and augmenting along Q and Q” yields another maximum matching for G which
does not contain {x, v}, a contradiction. oO

Claim 2 The graph G' returned by Algorithm 3 has O(k°2*) vertices and edges.

Proof We first show that each vertex x € X has degree O(k*2*") in G’. To this end, we
need to count the number of neighbors v € N(x)\X where the function Keep-Edge
returns true in Line 9. By Lemma 9, the function Keep-Edge explores the graph
along one or two paths (essentially growing from one starting point into two direc-
tions). Recall that P,. denotes the subgraphs induced by the graph exploration of
Keep-Edge for the neighbors of x. By Lemma 10 there is a partition of P, into Pe
and P? such that within each part the subgraphs are pairwise vertex-disjoint. We
consider the two parts independently. We start with bounding the number of graphs
in Pp where the function ‘Keep-Edge’ returned true (the analysis is completely anal-
ogous for P?).

Q) Springer
Algorithmica (2020) 82:3521-3565 3549

Since all explored subgraphs are disjoint and all free vertices in G — X wrt. Mc_y
are leaves, it follows that Algorithm 3 returned at most k? times true in Line 16 due
to w being adjacent to a free leaf in G—X. Also, the algorithm returns at most k?
times true in Line 14 due to v being free. Furthermore, the algorithm returns at
most 6k? - 2* times true in Line 19. Finally, we show that the algorithm returns at
most 8k? - (2* — 1) times true in Line 14 and 16, respectively. It follows from the
discussion below Observation 6 that 7, the pendent-free tree of G—X, has at
most 2k*(2* + 1) leaves (denoted by V7) and 2k?(2* + 1) vertices of degree at least
three (denoted by v2"), Let V; be the vertices of T. Since Tis a tree (or forest), it has
more vertices than edges and hence

>) deg;(v) < 2|VzI

veV,

which implies

>) degr(v) < 2+ [V2] + [Val

>3
ve Ve

Thus, Algorithm 3 returns at most 2 (Ve Sy) 4 [Vi] < 6k7(2* +1) times
true in Line 16 due to w being a vertex in ver, Also, Algorithm 3 returns at
most |V2°| < 2k?(2* + 1) times true in Line 14 due to v being a vertex in V2"

Summarizing, considering the graph explorations in P* Algorithm 3 returns at
most

ke +k? + 6k? 2 + 8k (2* +1) € O(K2*)

times true in the function Keep-Edge. Analogously, considering the graph explora-
tions in RP, Algorithm 3 also returned at most O(k*2*) times true. Hence, each ver-
tex x € X has degree at most O(k*2") in G’.

We now show that the exhaustive application of first Reduction Rule | and then
Reduction Rule 2 indeed results in a kernel of the claimed size. To this end, denote
with Very Vox , and v2 _ the vertices that have degree one, two, and at least
three in G’ "We have |V \vi 'y_y| © O(k?2*) since each vertex in X has degree at
most O(k?2*) wn G’ is reduced wrt. Reduction Rule 1. Next, since G’ — X is a for-
est (or tree), we have [v= | <|Vi,_y| and thus \v= | € O(k>2*). Finally, each
degree-two vertex in G’ needs at least one neighbor of degree at least three since G’
is reduced with respect to Reduction Rule 2. Thus, each vertex in Von-x | 1S ane
incident to a vertex in X or adjacent to one of the at most O(k?2*) vertices in G’ —
that have degree at least three. Thus, | Very! € O(k°2*). Summarizing, G’ contains at

most O(k>2*) vertices and edges. oO
Claim 3 Algorithm 3 runs in O(kn) time.
Proof First, observe that Lines 1 to 6 can be done in O(kn) time: The preprocess-

ing and table initialization can be done in O(kn) time as discussed in Sect. 3.2.2.
Furthermore, T and ve can clearly be computed in O(n + m) < O(kn) time. Second,

Q) Springer
3550 Algorithmica (2020) 82:3521-3565

applying Reduction Rule | in O(1 + m) time is straightforward and Bartha and Kresz
[2] showed how to apply Reduction Rule 2 in O(n + m) time. Thus, it remains to
show that each iteration of the foreach-loop in Line 7 can be done in O(n) time.

By Lemma 10, the graphs P, explored from x can be partitioned into two
parts such that within each part all subgraphs are vertex-disjoint. Thus, each ver-
tex in G — X is visited only twice during the execution of the function Keep-Edge.
Furthermore, observe that in Line 17 and 18 the table can be accessed in constant
time. Thus, the function Keep-Edge only checks once whether a vertex in V\X
has a neighbor in X, namely in Line 20. This single check can be done in constant
time. Since the rest of the computation is done on G — X which has less than |V\X|
edges, it follows that each iteration of the foreach-loop in Line 7 can indeed be done
in O(n) time.

This completes the proof of Proposition 3. O

This completes the description of Step 6. Combining Steps 1 to 6 we obtain our
kernelization algorithm for the parameter feedback vertex number.

Theorem 2 Marcuine parameterized by the feedback vertex number k admits a ker-
nel of size 2°. It can be computed in O(kn) time.

Proof First, using the linear-time factor-four approximation of Bar-Yehuda et al.
[1], we compute an approximate feedback vertex set X with |X| < 4k. Then, we
apply Step 1 to 6 using Algorithms 1 to 3. By Propositions | to 3, this can be done
in O(kn) time and results in a kernel of size O((4k)°2*) = 20), oO

Applying the O@m s/n)-time algorithm for MatTcHING [21] on the kernel yields the
following.

Corollary 2 Marcuinc can be solved in O(kn + 2°) time, where k is the feedback
vertex number.

4 Kernelization for Matching on Bipartite Graphs

In this section, we investigate the possibility of efficient and effective preprocessing
for BiparRTITE MATCHING. More specifically, we show a linear-time computable poly-
nomial-size kernel with respect to the parameter distance to chain graphs. In the first
part of this section, we provide the definition of chain graphs and describe how to
compute the parameter. In the second part, we discuss the kernelization algorithm.

Definition and computation of the parameter. We first define chain graphs which
are a subclass of bipartite graphs with special monotonicity properties.

Definition 1 [4] Let G = (A,B, E) be a bipartite graph. Then G is a chain graph
if each of its two color classes A, B admits a linear ordering wrt. neighborhood

Q) Springer
Algorithmica (2020) 82:3521-3565 3551

Fig.4 A chain graph. Note that the ordering <, of the vertices in A is going from left to right while the
ordering >, of the vertices in B is going from right to left. The reason for these two orderings being
drawn in different directions is that a maximum matching can be drawn as parallel edges, see e. g. the
bold edges. In fact, Algorithm 4 computes such matchings with the matched edges being parallel to each
other

inclusion, that is, A= {d,,...,a,} and B={b,,... Dg} Where N(a;) C N(a;)
and N(b;) € N(b;) whenever i < j.

Observe that if the graph G contains twins, then there is more than one linear
ordering wrt. neighborhood inclusion. To avoid ambiguities, we fix for the vertices
of the color class A (resp. B) in a chain graph G = (A, B, E) one linear ordering <,
(resp. <p) such that, for two vertices u,v € A (resp. u,v € B), if u <, v (resp. if
u <p, v) then N(u) C N(v). In the remainder of the section we consider a bipartite
representation of a given chain graph G = (A, B, E) where the vertices of A (resp. B)
are ordered according to <, (resp. <,) from left to right (resp. from right to left), as
illustrated in Fig. 4.

For simplicity of notation we use in the following < to denote the orderings <,
and <, whenever the color class is clear from the context. Note that we use the
direction left/right to indicate the ordering <. That is, for a vertex a’ € A to the right
(left) of a € A we have a < a’ (a’ > a). In contrast, for a vertex b’ € B to the right
(left) of b € B we have b > b’ (b < b’).

We next show that we have a constant-factor approximation for the parameter and
the corresponding vertex subset working in linear time. To this end, we use the fol-
lowing characterization of chain graphs. Here, 2K, denote the one-regular graph on
four vertices (with disjoint two edges).

Lemma 12 [4] A bipartite graph is a chain graph if and only if it does not contain an
induced 2K,.

Lemma 13 There is a linear-time factor-4 approximation for the problem of deleting
a minimum number of vertices in a bipartite graph in order to obtain a chain graph.

Proof Let G = (A, B,E) be a bipartite graph. We compute a set S C AUB such
that G — S is a chain graph and S is at most four times larger than a minimum size of

D) Springer
3552 Algorithmica (2020) 82:3521-3565

such a set. The algorithm iteratively tries to find a 2K, and deletes the four correspond-
ing vertices until no further 2K, is found. Since in each 2K,, by Lemma 12, at least one
vertex needs to be removed, the algorithm yields the claimed factor-4 approximation.

The details of the algorithm are as follows: First, it initializes S$ = @ and sorts
the vertices in A and in B by their degree; the vertices in A = {a,,...,a,} in
increasing order and the vertices in B= {b,,...,b gh in decreasing order, that
is, deg(a,) < ... < deg(a,) and deg(b,) >... = deg(b,). Since the degree of each
vertex is at most max{a, /}, this can be done in linear time with e. g. Bucket Sort. At
any stage the algorithm deletes all vertices of degree zero and all vertices which are
adjacent to all vertices in the other partition. The deleted vertices are not added to S$
since these vertices cannot participate in a 2K,. Next, the algorithm recursively pro-
cesses the vertices in A in a nondecreasing order of their degrees. Let a € A be a min-
imum-degree vertex and let b € B be a neighbor of a. Since D is not adjacent to all
vertices in A (otherwise b would be deleted), there is a vertex a’ € A that is not adja-
cent to b. Since deg(a) < deg(a’) it follows that a’ has a neighbor b’ that is not adja-
cent to a. Hence, the four vertices a, a’, b, b’ induce only two edges: {a, b} and {a’, b’}
and thus form a 2K,. Thus, the algorithm adds the four vertices to S, deletes them
from the graph, and continues with a vertex in A that has minimum degree.

As to the running time, we now show that, after the initial sorting, the algorithm
considers each edge only twice: Selecting a and b as described above can be done
in O(1) time. To select a’, the algorithm simply iterates over all vertices in A until
it finds a vertex that is not adjacent to b. In this way at most deg(b) + 1 vertices are
considered. Similarly, by iterating over the neighbors of a’, one finds b’. Hence, the
edges incident to a, a’, b, and b’ are used once to find the vertices and a second time
when these vertices are deleted. Thus, using appropriate data structures, the algo-
rithm runs in O(n + m) time. O

Kernelization overview. In the rest of this section, we provide a linear-time com-
putable kernel for BrparTITE MATCHING with respect to the parameter vertex deletion
distance k to chain graphs. On a high level, our kernelization algorithm consists of
two steps: First, we upper-bound by O(k) the number of neighbors of each vertex in
the deletion set. Second, we mark O(k7) special vertices and we use the monotonic-
ity properties of chain graphs to upper-bound the number of vertices that lie between
any two consecutive marked vertices, thus bounding the total size of the reduced
graph to O(k*) vertices.

Step I. Let G=(A,B,E) be the bipartite input graph, where V =A UB, and
let X C V be a vertex subset such that G — X is a chain graph. By Lemma 13, we
can compute an approximate X in linear time. Our kernelization algorithm uses a
specific maximum matching Mc_y € E inG—X with Algorithm 4 where all edges
in Mg_y are “parallel” and all matched vertices are consecutive in the ordering <,
and <p, see also Fig. 4. Since in convex graphs matching is linear-time solvable [25]
and convex graphs are a superclass of chain graphs, this can be done in O(n + m)
time. We use M;_, in our kernelization algorithm to obtain some local information
about possible augmenting paths. For example, each augmenting path has at least
one endpoint in X. Forming this into a data reduction rule, with s denoting the size
of a maximum matching, yields the following.

Q) Springer
Algorithmica (2020) 82:3521-3565 3553

Algorithm 4: An algorithm computing a maximum matching M in
the chain graph G such that all edges in M are “parallel” (see Figure 4
for a visualization. )
Input: A chain graph G = (V, FE), V=AUB, A= {ai,...,a@a} and
B= {bj,...,bg} with N(a;) C N(a;) and N(b;) C N(b;) for 2 < j.
Output: A maximum matching of G where all matched edges are parallel.

1 Compute the size s of a maximum matching in G using an algorithm of Steiner and
Yeomans [25]

2Mec {{da—s+1; bg}, {@a—s+2; be_1}, wey {aa, bg—s+i}}
3 return M.

Reduction Rule 4 If|M-_y| > s, then return a trivial yes-instance; if s > |Mg_y| +k,
then return a trivial no-instance.

The correctness of Reduction Rule 4 follows from Observation 2.

We will show next that there is a maximum matching M¢ for G in which each
vertex in X is either matched with another vertex in X or with a “small-degree ver-
tex” in G — X. This means that an augmenting path starting at some vertex in X will

“enter” the chain graph G — X in a small-degree vertex. We now formalize this con-
cept. Recall that uv < vimplies N(u) C N(v). For a vertex x € X we define Nv \* (x) to
be the set of the k neighbors of x in V\X with the smallest degree, formally,

smal

nv
N small

(x) := {we N(x)\X |k> |{u Ee N@\X | u < wh]}.

Lemma 14 Let G=(V,£) be a bipartite graph and let X C V be a vertex set such
that G — X is a chain graph. Then, there exists a maximum matching Mg, for G such
that every matched vertex x € X is matched to a vertex in N. Wr) UX.

Proof Assume, towards a contradiction, that there is no such matching Mg.
Let Mo ’ be a maximum matching for G that maximizes the number of verti-
ces x E X that are matched to a vertex in N VW) UX, that is, let M. maxi-

mize eX | (ux) EM! WEN UX}L Let x€X be a vertex that

V\X

is not matched with any vertex in N(x) UX, that is, x is matched to a ver-

texu € V\(N ae (x) UX). If there is an unmatched vertex w € Nyy (x) in M”,, then the
matching M G :=M 6 U {{x,w}}\{{u, x} }1s a maximum matching with more vertices

x € X (compared to M’ G) that are matched to a vertex in N VW) U X, a contradiction.
Hence, assume that there is no free vertex in N V\" (2): Since |N. NYY (| = = |X| =k, it
follows that at least one vertex w € NYS (xi is matched to a vertex v € V\X. Observe
that, by definition of NYY (x), we have Ng_y(w) © Nc_y(u). Thus, we have {u,v} € E

and thus, Mo = Mo U {{x,w}, {uv} }\{{u, x}, {w, v}} is amaximum matching with
more vertices in X (compared to M 6) fulfilling the condition of the lemma, a contra-
diction. O

Q) Springer
3554 Algorithmica (2020) 82:3521-3565

 

Fig.5 A chain graph with a maximum matching (thick edges) and two additional vertices x and y. An
augmenting path P = x,a,,b,,d,b),...,a7,b7,y with a, < ay implies that there is a shorter augment-
ing path P’ = x,a,,b,,a,,b,,y of length five (indicated by the gray background) in the input graph
since N(a,) € N(a7)

Based on Lemma 14, we can provide our next data reduction rule.

Reduction Rule 5 Let (G, s) be an instance reduced with respect to Reduction Rule 4
and let x € X. Then delete all edges between x and V\NI (2).

Clearly, Reduction Rule 5 can be exhaustively applied in O(n + m) time by one
iteration over A and B in the ordering <.

Step 2. For the second step of our kernelization algorithm, we first mark a set K
of O(k*) vertices that are kept in the graph (and thus will end up in the kernel): Keep
all vertices of X. For each vertex x € X keep all vertices in NY“ (x) and if a kept
vertex is matched wrt. Mg_y, then keep also the vertex with which it is matched.
Formally, we have:

(x) V ({u,v} € Mg_y AUE NY ())}.

small

K :=Xu{v|areX: ven
Observe that exhaustively applying Reduction Rule 5 ensures that K is of size at
most 2k’.

Next, we use the monotonicity properties of the chain graph to show that it suf-
fices to keep for each vertex v € K at most k vertices to the right and to the left of v.
Consider an augmenting path P = x,a,,b,,...,a,,b,,y from a vertex x E BN X
to a vertex y€ANX. Observe that if a; < ay, then also {b,,a,} € E and thus
P! = x,a,,b,,a/,b7,y is an augmenting path (see Fig. 5 for a visualization). Fur-
thermore, the vertices in the augmenting path P’ are a subset of K UX and, thus, by
keeping these vertices (and the edges between them), we also keep the augment-
ing path P’ in our kernel. Hence, it remains to consider the more complicated case
that a, < a, (see Fig. 6). To this end, we next show that in certain “areas” of the
chain graph G — X the number of augmenting paths “passing through” such an area
is upper-bounded. To specify an “area”, we need the following definition.

Definition 2 Let G = (A, B, E) be a chain graph and let M be a matching in G. Fur-
thermore let a € A, b € B with {a,b} € M. Then #lmv (b, M) (resp. #rmv (a, M)) is

D) Springer
Algorithmica (2020) 82:3521-3565 3555

#Imv(b4, M) =

 

Fig.6 The graph from Fig. 5 with the only difference being that the positions of x and y are exchanged
(and the vertex names are adjusted accordingly, so x is still adjacent to a,). Again, the thick, black edges
denote a maximum matching M for the chain graph (containing all vertices except x and y). The graph
contains an augmenting path P = x,a,,b,,d),b,...,a,,b7,y with a, > a,. In contrast to the example
displayed in Fig. 5, there is no augmenting x—y-path of length five. The shortest augmenting x—y-path is
displayed. For the edge {a,,b,} € M the vertices certifying that #lmv(b,,M) = | and #rmv (a,,M) = 2
are highlighted by dashed boxes (see Definition 2)

the number of neighbors of b (resp. of a) that are to the left of a (resp. to the right
of b); formally:

#Imv (b, M) := |{a’ € N(b) | a’ < a}|,#rmv (a, M) := |{b’ € N(a) | b’ < Db} |.

In Definition 2 the terms “left” and “right” refer to the ordering of the vertices of
A and B in the bipartite representation of G, as illustrated in Fig. 6. The abbreviation
#rmv (#lmv) stands for “number of vertices right (left) of the matched vertex”. We
set

#lmv (a,M) := #lmv (b, M)
and

#rmv (b,M) := #rmv(a,M),.
Finally, we define

#rmv(d,,da5,M) := , min {#rmv(a’, M)}
1 2

for a,,d, € A and
#Imv(b,,b,,M) := min {#lmv(b’,M)}
b, <b! <b,
for b,,b,€B. For example, in the graph displayed in Fig. 6, we
have #lmv (b,,b3;,M) = 2 and #lmv (b3, bg, M) = 1.

With these definitions, we can show a limit on the number of augmenting paths
that can “cross” an edge in Mc_y.

D) Springer
3556 Algorithmica (2020) 82:3521-3565

Lemma 15 Let G = (A, B, E) be a chain graph and M be a maximum matching for G
computed by Algorithm 4. Let a,b € V with {a,b} € M. Then the number of vertex-
disjoint alternating paths that (1) start and end with edges not in M and that (2)
have endpoints left of a and right of b is at most min{ #lmv (b, M), #rmv (a, M)}.

Proof We prove the case #lmv (b,M) < #rmv (a, M), that 1S,
min{ #lmv (b, M), #rmv (a, M)} = #lmv (b, M). The case #lmv (b, M) > #rmv (a, M)
follows by symmetry (with switched roles of a and b). Let #aug denote the number
of vertex-disjoint alternating paths from {a’ € A | a’ < a} to {b’ © B| b’ < b} such
that the first and last edge are not in M (see Fig. 6 for an example with #aug = 1

for a = a, and b = b,). Furthermore, let a’ yeees a’. bM be the neighbors of b that
. b b b mv (6, es G . hai hi
are to the left of a, that is, ad, <da,<...< Cty (b.M) < a. Since G is a chain graph it

follows that no vertex a’ €A with a’ < a’ is adjacent to any vertex b’ EB
with b’ < b. Furthermore, for any edge {a’, b’} € E with a < a’ and b < D’ it follows
from the construction of M (see Algorithm 4) that {a’, b’} € M. Hence, any of these

alternating paths has to contain at least one vertex from @ a? Since the

17000? “dimy (b,My"
alternating paths are vertex-disjoint it follows that #aug < #lmv (5, M). O

From the previous lemma, we directly obtain the following.

Lemma 16 Let G=(A,B,E) be a chain graph and let M be the maximum
matching for G computed by Algorithm 4. Let a,,a,€A and b,,b,€B
with {a,,b,}, {a,b} € M with a, < a,. Then there are at most #lmv (b,, bo, M)
vertex-disjoint alternating paths that (1) start and end with edges not in M and that
(2) have endpoints left of a, and right of by.

Lemma 16 states that the number of augmenting paths passing through the
“area” between a, and a, is bounded. Using this, we want to replace this area by
a gadget with O(k) vertices. To this end, we need further notation. For each kept
vertex v € K, we may also keep some bounded number of vertices to the right
and to the left of v. We call these vertices the left buffer (right buffer) of v.

Definition 3 Let G=(A,B,E) be a chain graph and let M be the maxi-
mum matching for G computed by Algorithm 4. Let a,,a, €A and b,,b, EB
with {a,,b,}, {a),b,} € M and a, < a,. Then the (at most) #lmv (b,, b,, M) vertices
to the right of a, form the right buffer B’(a,, M) of a,; formally,
B'(a,,M) :={aE€A|la,<an
l{a’ EA] a, <a’ <a}| < min{ #mv(d,,D,,M),k}}.

Analogously,

Q) Springer
Algorithmica (2020) 82:3521-3565 3557

 

 

B* (bz, Mg_x)

OO &) O© Cot) (os) C2)

ay EY HW &® OO

Fig.7 An example for the application of Reduction Rule 6. Top: A part of a chain graph G — X is dis-
played and the thick edges indicate parts of the maximum matching Mg_y. There are two vertex-disjoint
augmenting paths from the two vertices left of a, to the two vertices right of b, highlighted by gray back-
ground. Moreover, #lmv (b,,b, Mg_y) = 2. Bottom: The part of the graph after applying Reduction Rule
6 and the corresponding two vertex-disjoint augmenting paths. Note that the only edges that are in the
graph below but not above are the edges from vertices in B’(a,, Mg_y) to B“(b5,Mg_y)

B’(a,,M) :={aEAla<aa
l{a’ EA]|a<a' <a,}| < min{ Hmv(b,,b,,M),k}},
B'(b,,M) := {bE B|b<b,
l{b' EB| b <b’ <b,}| < min{ Amv (b,,b,,M), k}},
B’(b,,M) := {bE B|b, < ba
[{b' € B| b, <b’ < b}| < min{ #mv (b,,b,,M), k}}.
Note that in Definition 3 each of the sets B’(a,,M), Be (a,,M), B’(b,,M), and
B“(by,M) depends on all four vertices a,,a5,b,,b5; we omit these dependencies
from the names for the sake of brevity.

The basic idea is now to delete vertices “outside” these buffers. See Fig. 7 for an
illustrating example of the following data reduction rule formalizing this idea.

Reduction Rule 6 Let (G,s) be an instance reduced with respect to Reduc-
tion Rule 4. Let a,,a, € KNA with a, <a, and {a,,b,}, {a,,b,} € Mg_y such
that A’ := {aE A| a, < a <a,} is of size at least 2 - min{ #lmv(b,,b,,M),k} +1
and A’ 1 K = . Then delete all vertices in A’, := A’\(B’(a,, Mg_y) U BY (dy, Mg_x))

Q) Springer
3558 Algorithmica (2020) 82:3521-3565

and their matched neighbors in B, add all edges between the vertices in the right
buffer of a, and the vertices in the left buffer of b,, and decrease s by |A‘, .

Lemma 17 Reduction Rule 6 is correct and can be exhaustively applied in O(n + m)
time.

Proof We first introduce some notation and provide some general observations.
Then we show the correctness in two separate claims. Finally, we discuss the run-
ning time.

Let a,, ad, b,, and b, be as stated in Reduction Rule 6. Denote by A’ (resp. B’)
the set of vertices between a, and a, (resp. between b, and b,). Further denote
by Aj, CA’ and B, CB" the sets of deleted vertices. Note that |A’| = |B’|
and |A’ | = |B, since Mc¢_y was produced by Algorithm 4. Denote the vertices in

D
the buffers of a,,a,,b,, and b, by

X ._ X X
B (y,,Mg_x) — {Yy> a > Ynin{ #lmv (by .byMo_x).k) 3

for x € {r,0},y € {a,b},z € [2], andx=r <— z= 1 (see Fig. 7 for examples of
the concrete variable identifier).

Since the input instance is reduced with respect to Reduction Rule 4, it follows
that s—k < |M,_xy| <s. Denote by Mg_y :=Mc_yNE’ the matching obtained
from Mg_y by deleting all edges not in the reduced graph G’. Recall that s’ = s — |A} |.
We next show in Claims 4 and 5 that the input instance (G = (V, £),s) is a yes-
instance if and only if the produced instance (G’ = (V’, E’),s’) is a yes-instance.
Before we present these two claims, observe that there is a perfect matching between
the vertices in Ab and Bp: and thus

So |Mo_x| = s! —_ |Mor_yl- (1)

Claim 4 Jf(G,s) is a yes-instance, then (G’, s’) is a yes-instance.

Proof Recall that M7*“(M,_ x) is a maximum matching for G minimizing the size
of Mc_y AA Ma" (Mg_x). Since(G, s)is a yes-instance it holds that|Me"(Mg_y)| 2 5.
For brevity we set GY := G(Mg_y,M2™(Mg_x)) = (V,Mg_xy LAA MG**(MG_x))-
Note that G” is a graph that only contains odd-length paths (see Sect. 2). We will
show that there are as many vertex-disjoint augmenting paths for Mj_y in G’ as
there are paths in G”. This will show that G’ contains a matching of size

|Mg—x| + IMe"(Mg_x)| — [Mg-_xl 2 Me-xl + 5 - |[Mg_xl

(1) 1 1
= |Mo_xl +s —|Moe_xl=s'.
To this end, observe that all paths that do not use vertices in V\V’ = A, UB, are
also contained in G’. Thus, consider the paths in G” that use vertices in V\V’.
Denote by P” the set of all paths in GY using vertices in V\V’ and set t := |P”|.
Consider now an arbitrary i € [t], and let pm ep”

Q) Springer
Algorithmica (2020) 82:3521-3565 3559

Denote by vi, . Vi _the vertices in PM in the corresponding order, that is, v’
Vor} € Mcg_ x for all 7 € [p;/2].
Observe that exactly one endpoint of PM i isinA and the other endpoint is in B, since
Pri is an odd-length path. Assume without loss of generality that v, € A and Ys, EB.
Thus, the vertices in pm with odd (even) index are in A (B).

We next show that for any two vertices Vi, vi, of py with j < ¢ <p, — land both
being in A\X, it follows that vi <y' ms First, observe that if j = 1, then vi EA\X isa
free vertex wrt. Mc_y. Since " is matched wrt. Mg_y and since Mg_y 1s computed
by Algorithm 4, it follows that v; < vi. Thus, assume that j > land¢ > I (thus j > 3
and j > 1). Assume toward a contradiction that v, < Vi. Since ¢ < Pig 1, we

lekE,a

1
and vi are the endpoines ‘of pM and we have {V5;5

have v! ra B\X and since G — X is a chain graph, it “follows that {vi, v!

contradiction to Observation |. Thus, vi < y! oO

C+1

We next show that the path pm contains at least one vertex vi left of a, and at least

one vertex vy right of b,. Recall that M¢_y was computed by Algorithm 4 and, thus,
the free vertices are the smallest wrt. the ordering < (see also Fig. 4). Thus, if one
endpoint of PM i is in (A UB)\X, then this vertex is either v, and left of a, or it is vi

and right of by. Thus, assume that the endpoints of pi are in X. We showed in the

previous paragraph that V3, <V5<...< Vv, 3 Thus, we also

have vi >< Ys, <... < vi, since Mo. y is computed by Algorithm 4. Since we

—4
assumed § some ‘vertices of pil to be in V\V’, it follows that for at least one ver-

tex Vy ,, 1t holds that a, < vs 41 ~ %,. Furthermore since by assumption no vertex

between a, and a, or between b, and by, is in K, it follows that v, < a, (since vs EK)
and Vv, > < by (since vy, ,€ x).

For each i i € [t] denote by avi i the last vertex on the path pm that is not right of a,,
that is, a?’ is the vertex on uP? such that for each vertex a’ ‘€ A\X that 1 Is in Pw it
holds that a, < a’ not a’ <a’: . It follows from the previous paragraph that a’ exists.
Analogously to a’ i, for each i € [¢] denote by b”" the first vertex on the path pM that
is not left of b,, that i is, bP’ is the vertex on pi such that for each vertex b’ € B that is
in P” it holds that b, < b’ or b! <b”. This means that in G” there is for each i € [7]
an alternating path from a? to bP starting and ending with non-matched edges and
all these paths are pairwise vertex-disjoint. We show that also in G’ there are pair-
wise vertex-disjoint alternating J paths from a Pi to bP. Assume without loss of gener:
ality that a PY ag ght <...<ahi Since | in each path PM, i € [t], the successor of a’
is to the right of b,, it follows that a’ has at least i neighbors right of b,. Since the
right buffer of b, contains the #Ilmv (b,,b,,Mc_y) = t (see Lemma 16) vertices to
the right of b,, we have {abi i,b'} € E. By symmetry, we have {bei a} € E. Recall
that Mo_y forms a perfect matching between B’(b,,Mc-_y) and B’(a,,Mcg_y) as well
as between B’ (a,,M,_y) and B“(b,, Mg_y). Since Reduction Rule 6 added all edges
between B’(a,,Mc_y) and Be (02, Mg- y) to E’, it follows that each path pM can be
completed as follows: a’ Dr, a,b’ a’, bP’; note that exactly the edges {b’,a’}
and {b’,a e ; } are in Mg_y. Thus. each path i in P™ can be replaced by an augmenting
path for Mo_x in G’ and all these augmenting paths are vertex-disjoint. Thus, there

Q) Springer
3560 Algorithmica (2020) 82:3521-3565

are as many augmenting paths for M;,_, in G’ as there are paths in G” and therefore
(G’,s’) is a yes-instance. O

Claim 5 If(G’,s’) is a yes-instance, then (G,s) is a yes-instance.

Proof Let Mj, a maximum matching for G’. Observe that |M,,| > s’. We construct a
matching M,¢ for G as follows. First, copy all edges from Mg, N E into Mg. Second,
V\V’
2
is added to Mg. Observe that if all edges in M,, are also in FE, then Mg is a matching
of size s in G. Thus, assume that some edges in M~ are not in E, that is,
{ay , bf Voeees (aj, be} EMa\E for some té[#lmv(b,,b,,Mc¢_y)]. Observe

/

add all edges from Mg_y N D

, that is, a perfect matching between Ay and B

that s — |M,| < t. Clearly, the vertices di Lee a; b, Lee by are free with respect
to Mc.

We show that there are ¢f pairwise vertex-disjoint augmenting paths
from (dj 5 - +a; } to {bi yeees bt }; note, however, that these paths are not necessarily

from a: to 6, where re€[t]. To this end, recall that, by definition

of #imv (b,, bs, Mo. x), each vertex bEB with b,<b<b, has at
least #lmv (b,,b,,Mc¢_x) neighbors to the left of its matched neighbor. This allows
us to iteratively find augmenting paths as follows: To create the g'" augmenting
path P, start with some vertex bi. Denote by v the last vertex added to P, (in the

beginning we have v = be >: If v € A, then add to P, the neighbor matched to v.
If v € B, then do the following: if v is adjacent to a vertex a € (qj » ..,@;}, then

add a to P,, otherwise add the leftmost neighbor of v to Pz. Repeat this process
until P, contains a vertex from {a; yeees a; }. After we found P., remove all vertices
1 t

of P, from G. If q < f, then continue with P,,,. Observe that any two vertices of P,
that are in A have at least #lmv (b,,b,,Mc¢_y) — 1 other vertices of A between them
(in the ordering of the vertices of A, see Fig. 4). Thus, after a finite number of steps,
P, will reach a vertex in (qj; pees qd; }. Furthermore, it follows that after removing the

vertices of P, it holds that #lmv (b,, b>, Mg_y) 1s decreased by exactly one: P, con-
tains for each vertex b € B at most one vertex among the #lmv (b,, b,, Mc_y) neigh-
bors of b that are directly to the left of its matched neighbor in Mg_y. Thus, in each
iteration we have #lmv (b,,b,, Mg_y) > 0. It follows that the above procedure con-
structs ¢ vertex-disjoint augmenting paths from (q; » bees a; } to {bi pene be }. Hence,
G contains a matching of size s and thus (G, s) is a yes-instance. O

The correctness of the data reduction rule follows from the previous two
claims. It remains to prove the running time. To this end, observe that the match-
ing Mg_y is given. Computing all degrees of G can be done in O(n +m) time.
Also #lmv(v,Mg_y) can be computed in linear time: For each vertex bE B
one has to check for each neighbor of b whether it is to the left of b’s matched
neighbor and to adjust #lmv(b,M,_y) accordingly. Furthermore, comput-
ing #lmv(b,,b,,Mg_y) and removing the vertices in Aj, and Bi, can be done

Q) Springer
Algorithmica (2020) 82:3521-3565 3561

in O(Y pep deg(b) + Yi c4r deg(a)) time. Thus, Reduction Rule 6 can be exhaus-
tively applied in O(n + m) time. O
We next upper-bound the number of free vertices with respect to Mg_y. Let

Agee := {4 € A | ais free with respect to Mg_y}
and

Ak

free

[= {a © Agee | [{a’ € Afree | aX a’ }| < kK},

that is, At contains the k rightmost free vertices in A\X. Observe that all vertices
in At are lett of Mc-x. Analogously, denote by Br oe the set containing the k left-
most free vertices in B\X.

Reduction Rule 7 Let (G,s) be an instance reduced with respect to Reduction Rule
4. Then delete all vertices in (Afro \(K UAF.,.)) U (Biree \(K U BF,.))-

free

Lemma 18 Reduction Rule 7 is correct and can be applied in O(n + m) time.

Proof The running time is clear. It remains to show the correctness. Let (G,s)
be the input instance reduced with respect to Reduction Rule 4 and let (G’,s) be
the instance produced by Reduction Rule 7. We show that deleting the vertices
iN Agee \(K U At.) yields an equivalent instance. It then follows from symmetry that
deleting the vertices in By... \(K U Br.) yields also an equivalent instance.

We first show that if (G,s) is a yes-instance, then also the produced
instance (G’,s) is a yes-instance. Let (G,s) be a yes-instance and M, be a maxi-
mum matching for G. Clearly, |M,| >.s. Observe that for each removed ver-
tex a € A, \(K UA‘) it holds that every vertex a’ € At ne is to the right of a,
that is, a <a’ and thus No_y(a) C Nc_y(a’). Since (G,s) is reduced with respect
to Reduction Rule 4, it follows that |M¢_y| > |Mc¢| —k. Thus, there exist at most k
augmenting paths for Mg_, in G. If none of these augmenting paths ends in a ver-
tex a € Ageg\(K UA‘..), then all augmenting paths exist also in G’ and thus (G’, s)
is a yes-instance. If one of these augmenting paths, say P, ends in a, then at least
one vertex a’ € At is not endpoint of any of these augmenting paths. Since a € K,
it follows from the definition of K that the neighbor b of a on P is indeed in B\X.
Since Ng_y(a) C Nc_x(a’), it follows that {a’,b} © E and thus we can replace a
by a’ in the augmenting path. By exhaustively applying the above exchange argu-
ment, it follows that we can assume that none of the augmenting paths uses a vertex
in Agree \(K UAK ). Thus, all augmenting paths are also contained in G’ and hence
the resulting instance (G’, s) is still a yes-instance.

Finally observe that if (G’, s) is a yes-instance, then also (G,s) is a yes-instance:
any matching of size s in G’ is also a matching in G since G’ isa subgraphofG. O

We have now all statements that we need to show our second main result.

Q) Springer
3562 Algorithmica (2020) 82:3521-3565

S 2k free vertices < 4k? vertices

 

2k free vertices

< Ak? vertices

IA

Fig.8 Schematic representation of the situation in the proof of Theorem 3; only the chain graph G — X is
shown. The vertices within the dashed boxes are bounded by the applications of Reduction Rules 5 to 6.

Moreover, the vertices ak, at ; bk, and bt are all adjacent to vertices in X. It remains to upper-bound the

vertices right of aX + r and left of bt

Theorem 3 Marcuinc on bipartite graphs admits a cubic-vertex kernel with respect
to the vertex deletion distance to chain graphs. The kernel can be computed in linear
time.

Proof Let (G,s) be the input instance with G = (V, E), the two partitions V = A UB,
and X C V such that G — X is a chain graph. If X is not given explicitly, then use
the linear-time factor-four approximation provided in Lemma 13 to compute X.
The kernelization is as follows: First, compute the matching M;¢_y in linear time
with Algorithm 4. Next compute the set of kept vertices K. Then, apply Reduction
Rules 5 to 7. By Lemmas 17 and 18, this can be done in linear time. Let bt the
leftmost vertex in K NB and a rightmost vertex in AN K. Let a} and b* be their
matched neighbors. Since we reduced the instance with respect to Reduction Rule 5,
we have |K| < 2k*. Moreover, as we reduced the instance with respect to Reduction
Rule 6, it follows that the number of vertices between a’ and ak as well as the num-
ber of vertices between bt and b* is at most 4k°, respectively. Furthermore, there
are at most 2k free vertices left in V\X since we reduced the instance with respect
to Reduction Rule I. It remains to upper-bound the number of matched vertices left
of b¢ and right of af (see Fig. 8).

Observe that all vertices left of bt are matched with respect to Mc_y. If there
are more than 2k vertices to the left of bY, then do the following: Add four ver-
tices ay, by, X%, x? to V. The idea is that (a,.b,} should be an edge in Mg_y such
that a, € A and b, € B are in K and there is no vertex left of by. This means we add
these vertices to simulate the situation where the leftmost vertex in B\X is also in K.
To ensure that a, and b, are in K and that they are not matched with some vertices
in G, we add x% and x? to X and make x? respectively x? to their sole neighbors. In
this way, we ensure that there is maximum matching in the new graph that is exactly
two edges larger than the maximum matching in the old graph. In this new graph
we can then apply Reduction Rule 6 to reduce the number of vertices between b,
and bt. Formally, we add the following edges. Add {ay, x7}, {by,x? } to E. Add all

edges “between b, and the vertices in B\X. Let a be the rightmost vertex in Ate

Q) Springer
Algorithmica (2020) 82:3521-3565 3563

Then, add edges between a, and Ng_y(a). Set b’ < b, for each b’ € B\X, seta < ay
for each vertex a € A,,., and set a, < a’ for each matched vertex in A\X. Further-
more, add {a,,b,} to Mc_y and add a, and b; to K. Finally, increase s by two. Next,
apply Reduction Rule 6 in linear time, then remove ay, bp, xX4,x? and reduce s by
two. After this procedure, it follows that there are at most 2k vertices left of bt ,
If there are more than 2k vertices right of the rightmost vertex ax in AN K, then
use the same procedure as above. Thus, the total number of vertices in the remain-
ing graph is at most |X| + 2k + 4k? = O(k>). Furthermore, observe that adding and
removing the four vertices as well as applying Reduction Rule 6 can be done in lin-
ear time. Thus, the overall running time of the kernelization is O(n + m). O

Applying an O(n*>)-time algorithm for Brpartire Matcuina [15] on the kernel
yields the following.

Corollary 3 Brrartire Marcuine can be solved in O(k'> +n +m) time, where k is the
vertex deletion distance to chain graphs.

Using the randomized O(n”)-time algorithm for MATCHING [22], one would obtain
a randomized algorithm with running time O(k°? +n+m). Here, w < 2.373 is
the matrix multiplication coefficient, that is, two n Xn matrices can be multiplied
in O(n”) time.

5 Conclusion

We focussed on kernelization results for unweighted (BiPARTITE) Matcuinc. There
remain numerous challenges for future research as discussed in the second part of
this concluding section. First, however, let us discuss the closely connected issue of
FPTP algorithms for MATCHING . There is a generic augmenting path-based approach
to provide FPTP algorithms for Matrcuinc: Note that one can find an augmenting
path in linear time [3, 11, 21]. Now the solving algorithm for MATCHING parameter-
ized by some vertex deletion distance k works as follows:

1. Use aconstant-factor linear-time (approximation) algorithm to compute a vertex
set X such that G — X is a “trivial” graph (where MATCHING is linear-time solv-
able).

2. Compute in linear time an initial maximum matching M inG — X.

3. Start with M as a matching in G and increase the size at most |X| = k times to
obtain in O(k - (n + m)) time a maximum matching for G.

From this we can directly derive that MATCHING can be solved in O(k(n + m)) time,
where k is one of the following parameters: feedback vertex number, feedback edge
number, and vertex cover number. Moreover, BIPARTITE MATCHING can be solved
in O(k(n + m)) time, where k is the vertex deletion distance to chain graphs. Using
our kernelization results, the multiplicative dependence of the running time on

Q) Springer
3564 Algorithmica (2020) 82:3521-3565

parameter k can now be made an additive one. For instance, in this way the run-
ning time for BiparRTITE MATCHING parameterized by vertex deletion distance to chain
graphs “improves” from O(k(n + m)) to O(k’? +n + m).

We conclude with some questions and tasks for future research. Can the size
or the running time of the kernel with respect to feedback vertex set (see Sect. 3)
be improved? In particular, can the exponential upper bound on the kernel size be
decreased to a polynomial upper bound? Is there a linear-time computable kernel
for MATCHING parameterized by the treedepth @ (assuming that 7 is given)? This
would complement the recent O(/m) time algorithm [16]. Can one extend the kernel
of Sect. 4 from BipartirE MATCHING to MATCHING parameterized by the distance to
chain graphs?

Acknowledgements Open Access funding provided by Projekt DEAL. We thank anonymous reviewers
of Algorithmica for their valuable feedback.

Open Access This article is licensed under a Creative Commons Attribution 4.0 International License,
which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as
you give appropriate credit to the original author(s) and the source, provide a link to the Creative Com-
mons licence, and indicate if changes were made. The images or other third party material in this article
are included in the article’s Creative Commons licence, unless indicated otherwise in a credit line to the
material. If material is not included in the article’s Creative Commons licence and your intended use is
not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission
directly from the copyright holder. To view a copy of this licence, visit http://creativecommons.org/licen
ses/by/4.0/.

References

1. Bar-Yehuda, R., Geiger, D., Naor, J., Roth, R.M.: Approximation algorithms for the feedback vertex
set problem with applications to constraint satisfaction and Bayesian inference. SIAM J. Comput.
27(4), 942-959 (1998)

2. Bartha, M., Kresz, M.: A depth-first algorithm to reduce graphs in linear time. In: Proceedings of
the 11th International Symposium on Symbolic and Numeric Algorithms for Scientific Computing
(SYNASC’ 09). IEEE, pp. 273-281 (2009)

3. Blum, N.: A new approach to maximum matching in general graphs. In: Proceedings of the 17th
International Colloquium on Automata, Languages, and Programming (ICALP ’90). Vol. 443.
LNCS. Springer, pp. 586-597 (1990)

4. Brandstadt, A., Le, V.B., Spinrad, J.P.: Graph Classes: a Survey, vol. 3. SIAM, SIAM Monographs
on Discrete Mathematics and Applications (1999)

5. Cai, L.: Parameterized complexity of vertex colouring. Discrete Appl. Math. 127(1), 415-429
(2003)

6. Chang, M.: Algorithms for maximum matching and minimum fill-in on Chordal bipartite graphs.
In: Proceedings of the 7th International Symposium on Algorithms and Computation (ISAAC ’96).
Vol. 1178. LNCS. Springer, pp. 146-155 (1996)

7. Dahlhaus, E., Karpinski, M.: Matching and multidimensional matching in chordal and strongly
chordal graphs. Discrete Appl. Math. 84(1—-3), 79-91 (1998)

8. Duan, R., Pettie, S.: Linear-time approximation for maximum weight matching. J. ACM 61(1), 1:1-
1:23 (2014)

9. Fomin, F.V., Lokshtanov, D., Pilipczuk, M., Saurabh, S., Wrochna, M.: Fully polynomial-time
parameterized computations for graphs and matrices of low Treewidth. ACM Trans. Algorithms
14(3), 34:1-34:45 (2018)

Q) Springer
Algorithmica (2020) 82:3521-3565 3565

10.

11.

12.

13.

14.

15.

16.

17.

18.

19.

20.

21.

22.

23.

24.
25.

26.

Gabow, H.N., Tarjan, R.E.: A linear-time algorithm for a special case of disjoint set union. J. Com-
put. Syst. Sci. 30(2), 209-221 (1985)

Gabow, H.N., Tarjan, R.E.: Faster scaling algorithms for general graph-matching problems. J. ACM
38(4), 815-853 (1991)

Giannopoulou, A.C., Mertzios, G.B., Niedermeier, R.: Polynomial fixed-parameter algorithms: a
case study for longest path on interval graphs. Theor. Comput. Sci. 689, 67—95 (2017)

Guo, J., Hiiffner, F., Niedermeier, R.: A structural view on parameterizing problems: distance from
triviality. In: Proceedings of the Ist International Workshop on Parameterized and Exact Computa-
tion (IWPEC ’04). Vol. 3162. LNCS. Springer, pp. 162—173 (2004)

Gupta, M., Peng, R.: Fully Dynamic (1+ e)-Approximate Matchings. In: Proceedings of the 54th
Annual IEEE Symposium on Foundations of Computer Science (FOCS ’13). IEEE, pp. 548-557
(2013)

Hopcroft, J.E., Karp, R.M.: Ann °/? algorithm for maximum matchings in bipartite graphs. SIAM J.
Comput. 2(4), 225-231 (1973)

Iwata, Y., Ogasawara, T., Ohsaka, N.: On the power of tree-depth for fully polynomial FPT algo-
rithms. In: 35th Symposium on Theoretical Aspects of Computer Science (STACS 718). Vol. 96.
LIPlIcs. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 41:1-41:14 (2018)

Karp, R. M., Sipser, M.: Maximum matchings in sparse random graphs. In: Proceedings of the 22nd
Annual IEEE Symposium on Foundations of Computer Science (FOCS ’81). IEEE, pp. 364-375
(1981)

Korenwein, V., Nichterlein, A., Niedermeier, R., Zschoche, P.: Data reduction for maximum match-
ing on real-world graphs: theory and experiments. In: Proceedings of the 26th Annual European
Symposium on Algorithms (ESA 2018). Vol. 112. LIPIcs. Schloss Dagstuhl - Leibniz- Zentrum fuer
Informatik, 53:1-53:13 (2018)

Kratsch, S., Nelles, F.: Efficient and Adaptive Parameterized Algorithms on Modular Decomposi-
tions. In: Proceedings of the 26th Annual European Symposium on Algorithms (ESA 2018). Vol.
112. LIPIcs. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik, 55:1-55:15 (2018)

Mertzios, G.B., Nichterlein, A., Niedermeier, R.: Linear-time algorithm for maximum-cardinality
matching on cocomparability graphs. SIAM J. Discrete Math. 32(4), 2820-2835 (2018)

Micali, S., Vazirani, V. V.: An O( VIVI |E|) algorithm for finding maximum matching in general
graphs. In: Proceedings of the 21st Annual IEEE Symposium on Foundations of Computer Science
(FOCS ’80). IEEE, pp. 17-27 (1980)

Mucha, M., Sankowski, P.: Maximum matchings via Gaussian elimination. In: Proceedings of the
45th Annual IEEE Symposium on Foundations of Computer Science (FOCS ’04). IEEE, pp. 248-
255 (2004)

NeSetril, J., de Mendez, P.O.: Sparsity—Graphs, Structures, and Algorithms, vol. 28. Springer,
Algorithms and Combinatorics (2012)

Skiena, S.S.: The Algorithm Design Manual. Springer, Berlin (2010)

Steiner, G., Yeomans, J.S.: A linear time algorithm for maximum matchings in convex bipartite
graphs. Comput. Math. Appl. 31, 91-96 (1996)

Yuster, R.: Maximum matching in regular and almost regular graphs. Algorithmica 66(1), 87-92
(2013)

Publisher’s Note Springer Nature remains neutral with regard to jurisdictional claims in published
maps and institutional affiliations.

Q) Springer
