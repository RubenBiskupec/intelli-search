Journal of Parallel and Distributed Computing 146 (2020) 201-211

 

 

ELSEVIER

Contents lists available at ScienceDirect

PARALLEL AND
DISTRIBUTED
COMPUTING

J. Parallel Distrib. Comput.

 

journal homepage: www.elsevier.com/locate/jpdc

 

Self-stabilizing token distribution on trees with constant space” ®

Yuichi Sudo”, Ajoy K. Datta>', Lawrence L. Larmore °, Toshimitsu Masuzawa?

Check for
updates

* Graduate School of Information Science and Technology, Osaka University, 1-5 Yamadaoka, Suita, Osaka, Japan
> Department of Computer Science, University of Nevada, Las Vegas, 4505 S, Maryland Pkwy, Las Vegas, NV, USA

ARTICLE INFO

Article history:

Received 18 June 2019

Received in revised form 11 June 2020
Accepted 26 July 2020

Available online 24 August 2020

MSC:
68W15
Distributed algorithms

Keywords:

Token distribution
Self-stabilization
Constant space algorithm

ABSTRACT

Self-stabilizing and silent distributed algorithms for token distribution in rooted tree networks are
given. Initially, each process of a graph holds at most ¢ tokens. Our goal is to distribute the
tokens uniformly in the whole network so that every process holds exactly k tokens. In the initial
configuration, the total number of tokens in the network may not be nk where n is the number of
processes in the network. The root process is given the ability to create a new token or remove a
token from the network. We aim to minimize the convergence time, the number of token moves,
and the space complexity. First, a self-stabilizing token distribution algorithm that converges within
O(n£) asynchronous rounds and needs ©(nhe ) redundant (or unnecessary) token moves is given, where
€ = min(k, € — k) and h is the height of the tree network. Next, two novel mechanisms to reduce the
number of redundant token moves are presented. One reduces the number of redundant token moves
to O(nh) without any additional costs while the other reduces the number of redundant token moves
to O(n), but increases the convergence time to O(nhé). All given algorithms have constant memory at

each process and each link register.
© 2020 The Author(s). Published by Elsevier Inc. This is an open access article under the CC BY license

1. Introduction

The token distribution problem was originally defined by Peleg
and Upfal in their seminal paper [14]. Consider a network of n
processes and n tokens. Initially, the tokens are arbitrarily dis-
tributed among processes but with up to a maximum of ¢ tokens
in any process. The problem is to distribute the tokens among the
processes such that every process ends up with exactly one token.
The above problem was redefined in another paper by the same
authors [13] by considering m tokens instead of n tokens. The goal
in this case is to reach a configuration at which each process has
either |m/n| or [m/n] tokens. The token distribution problem is
considered as the load balancing problem in distributed systems.
A token can be considered to represent a unit of task (or load) of a
process. The solution to the token distribution problem provides
a solution of the load balancing problem, where the goal is to
maintain the loads of process as evenly as possible.

The fault-tolerant (self-stabilizing) version of the problem of
load balancing in distributed systems was first considered by

* An extended abstract of this paper, omitting proofs and some other details,
appears in the proceedings of the 22nd International Conference on Principles
of Distributed Systems (OPODIS 2018) (Sudo et al., 2018) [15].

* Corresponding author.

E-mail addresses: y-sudou@ist.osaka-u.ac.jp (Y. Sudo), ajoy.datta@unlv.edu
(A.K. Datta), lawrence.larmore@unlv.edu (L.L. Larmore),
masuzawa@ist.osaka-u.ac.jp (T. Masuzawa).

1 Ajoy Kumar Datta died May 26, 2019. Rest in Peace, Ajoy.

https://doi.org/10.1016/j.jpdc.2020.07.007

(http://creativecommons.org/licenses/by/4.0/).

Arora and Gouda [2]. A self-stabilizing algorithm has two proper-
ties, convergence and stability. The convergence property states
that regardless of the initial distribution of loads among the pro-
cesses, when the faults cease to occur (i.e.,if the environment no
longer changes the load), the computation reaches a configuration
where the loads of processes are balanced, within finitely many
steps. Stability guarantees that the computation cannot shift any
unit of load between two processes forever.

In [2] and many other papers on token distribution, a special
property (referred to as constraint in |2]) is maintained. This prop-
erty specifies that during any computation of the load balancing
or token distribution algorithm, no new tokens are produced and
no tokens are consumed by any process. However, that constraint
cannot be maintained in our work due to the nature of the
problem. The token distribution problem solved in this paper
requires storing a fixed number (k) of tokens at each process.
As we deal with self-stabilizing systems, the network (a tree
rooted at a designated root process in this paper) can start in an
arbitrary configuration where the total number of tokens in the
network may not be exactly equal to nk. Instead, each process
holds an arbitrary number, from zero to @, of tokens in the initial
configuration. Thus, our algorithm must make an exception to the
constraint above; we assume that the root process can put (get)
tokens to (from) an external store to decrease (increase) the total
number of tokens in the network, but that the constraint holds
for all other processes. We can think of the external store as the
parent of the root process.

0743-7315/© 2020 The Author(s). Published by Elsevier Inc. This is an open access article under the CC BY license (http://creativecommons.org/licenses/by/4.0/).
202 Y. Sudo, A.K. Datta, L.L. Larmore et al. / Journal of Parallel and Distributed Computing 146 (2020) 201-211

In this paper, we define three silent self-stabilizing token dis-
tribution algorithms for rooted tree networks. The performances
of these algorithms are summarized in Table 1. We allow them
to use only constant space. Specifically, the work space of all our
algorithms, i.e., the amount of memory needed to store informa-
tion other than tokens, is constant, both per process and per link
register.

We first give a self-stabilizing token distribution algorithm
Basic which has the convergence time of O(né) (asynchronous)
rounds. As we will show in Section 3, any self-stabilizing to-
ken distribution algorithm requires convergence time of §2(n¢)
rounds (even if it uses arbitrarily large amount of memory space).
Thus, Basic achieves the optimal convergence time despite that it
uses only constant work space.

Basic may have redundant token moves. Informally, a token
move is said to be redundant if it will later be reversed. Formally,
If u, v are neighboring processes, and if, during the computation
of the algorithm i tokens move from u to v and j tokens move
from v to u, where i > j, then all of the moves from v to u are
redundant, as well as j of the i moves from u to v. In the worst
case, Basic makes ©@(nhe) redundant token moves, where h is the
height of the tree network and € = min(k, @ — k).

Our second algorithm is SyncTokenDist, which combines the
Basic with a Z3 synchronizer, and our third algorithm is
PIFTokenDist, which combines Basic with PIF (Propagation of In-
formation with Feedback) waves. SyncTokenDist has round com-
plexity O(n) and has O(nh) redundant moves, while PIFTokenDist
has round complexity O(nhé) and O(n) redundant moves. The
third algorithm PIFTokenDist is optimal in terms of the number
of redundant token moves.

1.1. Related work

The token distribution problem was introduced by Peleg and
Upfal in [14]. Another solution to the same problem was given
by the same authors in [13]. In these papers, the problem is
defined for general bounded degree graphs. Herley [7] gave an-
other solution to the problem and claims that his solution is more
efficient if the time needed for the local computation steps is not
ignored. Another version of the problem, called the near-perfect
token distribution problem, was introduced in [3]. In this problem,
at the termination of the algorithm, no more than O(1) tokens can
be present at any process. There is a variation of the near-perfect
token distribution problem, where the maximum difference of
the number of tokens between any pair of processes at the
termination of the algorithm is not constant, that is, the difference
depends on some network parameter. Algorithms in [6,9,10] are
in this category. Algorithms for general networks were given
in [6], for complete binary trees in [9], and for meshes and torus
networks in [10].

The token distribution problem for tree networks that we
solve in this paper was given without a solution by Peleg in [12].
Another version of the token distribution problem on trees was
given in [11], where t, the total number of tokens, and n, the
number of processes, are computed by the algorithm. The tokens
are then distributed perfectly among the processes in O(td) time,
where d is the diameter of the tree. Although the asynchronous
message passing model is used, they use stronger communication
primitives than the typical send/receive primitives. The result
in [8] is for tree networks in another model called Dimension-
exchange under the assumption that processes are given the
knowledge of n.

Arora and Gouda [2] gave self-stabilizing load balancing al-
gorithms for ring and tree networks; starting from an arbitrary
initial assignment of load (or tasks), their algorithms are guaran-
teed to converge to a configuration at which the loads of any two
processes differ by at most one.

Table 1
Token distribution algorithms for rooted trees. (« = min(k, € — k)).
Convergence time Redundant Work space
token moves (Process, Link)

Basic O(né) rounds @(nhe) 0, O(1)
SyncTokenDist O(né) rounds O(nh) O(1), O(1)
PIFTokenDist O(nh€) rounds O(n) O(1), O(1)
Lower bounds §2(n€) rounds 2(n) -

2. Preliminaries

We consider a tree network T = (V,E) where V is a set of n
processes and E is a set of n — 1 edges, each consisting of a pair
{u, v} of processes. Let root be the root process of T, and let p(v)
be the parent of any process v £ root. Let N(v) be the set of
neighbors of a process v, and C(v) the set of children of v, i.e., all
neighbors of v except its parent. For any v € V, let T, be the sub-
tree of T consisting of v and its descendants, and let n, = |T,|.
Let h, be the height of T,, the length of the longest simple path
through T between v and a leaf of T,, and let h = hyoot, the height
of T.

For each edge {u, v} € E, there are two link registers, r,,,, and
Ty.y. We call ry», an output register of u and an input register of
v. Variables of r,,, can be read by both v and u but can be written
only by v.

2.1. Model of computation

We use the composite atomicity model of computation. A
process u can read and write its local variables, can read and write
the variables of its output registers, and can read the variables of
its input registers.

The state of process or link register is defined by the values of
its variables. The global state, or configuration of T is defined to be
the states of all processes and link registers. We also define the
neighborhood state of a process to consist of its state together with
the states of all its output and input registers. We let \V(y, v) be
the neighborhood state of v if the configuration is y.

An algorithm A specifies a set of variables in processes, a set
of variables in link registers, and an atomic action (or program
code) that defines how a process v updates local variables and
variables of the output registers and sends and/or receives tokens
at each step according to its neighborhood state. We say a process
is enabled if the execution of the atomic action would change the
value of at least one variable or send/receive tokens; otherwise,
the process is disabled.

At each step, the daemon, or scheduler, selects a non-empty
set of enabled processes. Each selected process executes the
atomic action at the step. If there are no enabled processes, the
computation halts.

2.2. Problem specification

We now formally specify the version of the token distribution
problem on a tree that we address in this paper. Given parameters
0 < k < £, we must construct a self-stabilizing distributed
algorithm A on T which has the properties that there can be no
more than ¢ tokens in the local memory of any process, there can
be no more than one token in any link register, and no tokens can
be lost or gained by the network except by root, which can push
(pull) a token to (from) a fictitious external store. As mentioned
above, we can think of the external store as the parent of the root
process and sometimes denote it by p(root).

A configuration of A is legitimate if the local memory of each
process contains exactly k tokens and there are no tokens in any
Y. Sudo, A.K. Datta, L.L. Larmore et al. / Journal of Parallel and Distributed Computing 146 (2020) 201-211 203

link register. Let £ be the set of the legitimate configurations of
A. We require that A be self-stabilizing, meaning that there exists
a subset £2’ C £ such that £’ is closed and is a universal attractor,
ie, if y > y’ is a step of Aandy e€ CL’, then y’ € CZ’, and
every computation of A eventually reaches £’ starting from any
configuration. We say that A is silent if every computation of A is
finite, i.e, eventually reaches a configuration at which no process
is enabled.

2.2.1. Movement of tokens

If u, v are neighboring processes, it must be possible to move a
token from u to v, despite the fact that there is no variable which
can be written by both processes. We use a simple 2-way switch
for passing tokens. A process v can send a message x € 2? to u,
but only if there is no message in the register r,,,. There must be
a predicate HasToken(v, u), computable by both processes, which
is true if and only if v has sent a token to u which has not yet
been read by u. Thus, v must be able to change HasToken(v, u)
from false to true, while u must be able to change HasToken(v, u)
from true to false. To send a token, v writes a token into r,,, then
“flips” HasToken(v, u) to true. Seeing that HasToken(v, u) is true,
u copies the token to its token store, then flips HasToken(v, u) to
false.

The predicate HasToken must have the following properties:
(i) both u and v can calculate HasToken(u, v), (ii) if HasToken(u, v),
then u may not put a token to r,,,, and when u does put a token
to ry,y, HasToken(u, v) becomes true, (ili) if ~HasToken(u, v), then
v may not get a token from r,,, and when v does get a token
from ry», HasToken(u, v) becomes false.

Tokens can also be moved by root to or from the external
store. root can send a token to the external store if
NumStore(root) > 0, while if NumStore(root) < £@, the root can
get a token from the external store. However, we allow root to
get (resp., send) a token from (resp., to) the external store only
once at each step.

2.3. Complexities

We evaluate token distribution algorithms with three metrics
— time complexity, space complexity, and the number of token
moves.

We measure the time complexity in terms of (asynchronous)
rounds. Let IX = yo, y1,... be a computation of A, and let € be
the set of processes which are enabled at yo. We define the first
round of computation I” to be the smallest prefix, say yo,...,%,
of I such that every member of € either executes or becomes
disabled during the first t steps. Let I”’ be the suffix of ” starting
from y;,. The second round of I" is defined to be the first round
of I’, and so forth.

We measure the space complexity in terms of work space, that
is, the amount of memory needed to store information other than
tokens, per process and link register.

In our analysis, we focus on the number of redundant token
moves. Intuitively, a move is redundant if it is unnecessary. Given
v € V and configuration y of A, let NumStore(y, v) be the number
of tokens stored in the local memory of v at that configuration.
and let NumIn(y, v) be the number of tokens in input registers of
v at y, and let Diff(y, v) = NumStore(y, v)+NumIn(y, v)—k. We
define A(y,v) = Do yer, Diff(y,u). That is v must send A(y, v)
tokens to p(v) if A(y, v) > 0; otherwise v must receive —A(y, v)
from p(v) to achieve the goal of k tokens at each process, starting
from the configuration y. Thus, any computation of A starting
from y must have at least A(y) = >_,,-y |A(y, v)| token moves.
A computation which has A(y) token moves we call an optimal
computation. The redundancy of a computation starting at y is
defined to be the number of token moves of that computation,
minus the number of token moves of an optimal computation.

While writing the functions defined above, we will suppress
the parameter y if the configuration is understood from context.

root

(n — 1)/2 processes
with no tokens

(n — 1)/2 processes
with (n — 1)l/2 tokens

 

Fig. 1. A tree to prove Theorem 1.

root

 

Fig. 2. A tree to prove Theorem 2.

3. Lower bounds

In this section we let A be an arbitrary algorithm, in the
composite atomicity model with link registers which solves the
token distribution problem on all tree networks.

Theorem 1. For any n, there exist a tree T and a computation of
A on T that takes 82(n€) rounds to reach a legitimate configuration.

Proof. We can assume n is odd. Let root have two children, v and
v’ where n, = ny = (n — 1)/2. Consider a configuration of A on
T where T, holds n, - € tokens in total and T,, holds zero tokens
(Fig. 1). Process u must be selected by the scheduler 2(n(¢ — k))
times to send n,(@ — k) tokens to root and process v’ must be
selected by the scheduler (2(nk) times to receive nk tokens from
root. Thus, there exists a computation of A starting from this
configuration which takes §2(max{n(é — k), nk}) = (2(n€) rounds
to achieve the final token distribution.

 

 

 

 

Lemma 1. /f a tree network T contains a process u which has
exactly one child v, there must be a configuration y of T such that
(i) Diff (vy, u) < 2 and (ii) u is enabled to send a token to a neighbor.

Proof. Let = y,y,... be a computation of such that
Diff(yvo,u) = 1. There must be a step % — y%4 1 at which
Diff(u) changes from positive to non-positive. Pick t such that
Diff(u, 7%) > O and Diff(u, y41) < 0. At step y% > 41, u sends
a token to either ry,u) OF Ty,». Since u has only two neighbors,
Diff(v%, u) < 2.

 

 

 

 

Theorem 2. For any n, there is a tree network T with n processes
and a computation of A on T which contains §2(n) redundant token
moves.

Proof. We can assume that n — 1 is a multiple of 3. Let m =
(n—1)/3. Let T be the tree where root has m children, uj, ..., Um,
where each u; has one child, v;, and each v; has one child,
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

204 Y. Sudo, A.K. Datta, L.L. Larmore et al. / Journal of Parallel and Distributed Computing 146 (2020) 201-211
X3
u|X4 u|X4 u|X4 u u
Xs Xs 5 Xs Xs
O00] tru 1)0] *tvu 1)[0| vu Ol0) *tvu Ol0] tru
out | in out | in out | i out | in out] in
x token x token x token X token x4] token
2 3 3 4 4
token X4| token x 1 token X4| token X4| token X4|
in | out in | out in | out in | out in | out
Tuy) [1]\[1 Tuv| [aja Tuy) [oll Tuv| [oll Tuy) [ilifa
X4
V Vv v|X3 v|X3 v|X3
Xo Xo 2 Xo Xo
t t+1 +2 t+3 {+4

Fig. 3. At step t, NumStore(u) = 3, NumStore(v) = 1, and both registers are empty, as indicated by the fact that r,,,.out A r,,.in and ry,.0ut A r,,y.in, which implies
that HasToken(u, v) and HasToken(v,u) are both false. Since no token is sent from v to u during the next four steps, HasToken(v,u) will remain false. Although
Ty,y-token = xj, that token does not exist. At step t+ 1, u writes the token x3 to r,,.token and reversing the value of r,,,.out, so that HasToken(u, v) changes from
false to true. At step t+ 2, v reads the token and copies it into v.tokenStore, reversing the value of r,,.in so that HasToken(u, v) changes back to false. The same

procedure is then repeated, passing the token x, from u to v in two steps.

w;, which is a leaf (Fig. 2). We construct a computation J7
9, 71,... Of A on T. For each i, let the neighborhood state
N (200, uj) be a copy of \(y;, uw) as given by Lemma 1. We specify
that all u; and no other processes be selected to execute at the
first step of [7. By Lemma 1, at the first round, each u; sends a
token to v; or each u; sends a token to root. For all i, Diff (zo, uj) <
2 holds. Furthermore, each v; and w; can have arbitrary state in 719
because each (zo, u;) is determined only by the state of u; and
the states of all its input and output registers. We now consider
two cases.

Case 1. Each u; sends a token to v; at the first step of J7. We let
there be @ tokens each in the local memories of v; and w;
at mp. Then A(z, v;) = 20 — 2k+ 1 > O. It follows that, at
some later step, v; will send a token to u;. That move and
the initial move of a token from u; to v; will be redundant.

Case 2. Each u; sends a token to root, and does not send a token
to v;, at the first step of J7. We let there be no tokens in the
local memories of v; and w; at zo. Then A(z, uj) < 1—2k <
0. It follows that, at some later step, root will send a token
to u;. That move and the initial move of a token from u; to
root will be redundant.

IT will thus contain at least 2(n — 1)/3 redundant moves in both
cases.

 

 

 

 

4. The basic algorithm

In this section, we define our simplest algorithm, Basic, which
is self-stabilizing and silent.

4.1. Overview of Basic

In a bottom-up computation, each process u estimates whether
there are too many or too few tokens in its subtree, T,. If u
estimates that A(u) > O, meaning that T, has too many tokens,
u sends a token to its parent. If u estimates that T, has too
few tokens for some v € C(u), that is, that A(v) < O, then u
sends a token down to u. If root estimates that T has too (too
few) tokens, it sends a token to (receives a token from) external
storage. Eventually, each process will have exactly k tokens and
Basic halts.

4.2. Variables and functions of basic

1. Each process v has a structure v.tokenStore, which holds
between zero and @ tokens, each of which is a bit string of
length b. We denote the number of tokens in
v.tokenStore by NumStore(v).

2. Each link register r,, has a variable r,,.token, which
holds a token.

3. Each link register r,, has Boolean variables r,,.in and
Ty,y-out, which are used for communication between u and
OF

4. lf v root, the output register ry) has a variable
Ty pv)-est € {—1,0°,0,0*, 1, 1}, which is an estimate
of the sign of A(u). If v is a leaf, ry 71) € {—1, 0, 1}. The
values of these estimation variables are computed bottom-
up, and their intuitive meaning is as follows: —1 means
that v needs to receive a token from its parent, 1 means
that v needs to send a token to its parent, and 0 means that
it needs to neither send nor receive a token. The values 07
and O* are used instead of —1 and 1 in situations where
sending a token to or receiving a token from p(v) could be
a redundant move. The value | simply means that v lacks
the information to estimate A(v).

true ifr, ,.out =f, ,.in
5. HasToken(u, v) = woe vu
false otherwise

6. NumIn(v) = |{w € N(v) | HasToken(w, v)}|
7. Diff(v) = NumStore(v) + NumIn(v) — k

Functions of basic

1. Push(v, x) inserts the token x into v.tokenStore.

2. Pop(v) deletes a token from v.tokenStore and returns
that token.

3. exPut(x) puts the token x to the external store.

4. exGet() gets a token from the external store and returns
that token.

4.3. Passing tokens in Basic

In this subsection, we present the way to pass tokens between
two processes in Basic, which is similar to a self-stabilizing bit
alternating algorithm | 1].

Passing a token from a process u to a neighboring process
v is done in two steps (Fig. 3). If ~HasToken(u, v) and there is
a token named x in u.tokenStore, then u is able to execute
Y. Sudo, A.K. Datta, L.L. Larmore et al. / Journal of Parallel and Distributed Computing 146 (2020) 201-211 205

Put(v, x), deleting x from u.tokenStore, writing to r,,.token,
and reversing the value of r,,.out, causing HasToken(u, v) to
become true. The second step is executed by v. If HasToken(u, v),
Ty,y-token = x, and NumStore(v) < _ k, v is able to execute
Get(u), copying the token x to v.tokenStore and reversing
ry,y.in, Causing HasToken(u, v) to become false.

Tokens can also be passed between root and the external
store; root can move a token from its token store to the external
store if NumStore(root) > O, and can move a token from the
external store to its token store if NumStore(root) < @.

4.4, Algorithm Basic

In this section, we present our self-stabilizing token distribu-
tion algorithm, which we call Basic. The work space complexity
of Basic in each process (resp. on each register) is zero (resp. con-
stant). Its convergence time is O(n@) rounds and it makes @(nhe)
redundant token moves where € = min(k, @ — k).

We use the standard notation sgn(x), that is, sgn(x) = 1,
sen(x) = O, and sgn(x) = —1if x > 0,x = O, andx < Q,
respectively.

During a computation of Basic, each process v tries to estimate
sgn( A(v)), that is, tries to find whether A(v) is positive, negative,
or just zero. Each process v ¥ root reports that estimate to its
parent p(v) using a shared variable r, »;»).est. When its estimate
is negative, p(v) sends a token to v if p(v) holds a token and
—HasToken(p(v), v). When the estimate is positive, v sends a
token to its parent p(v) if v holds a token and —HasToken(v, p(v)).
root always gets a new token from the external store to increase
A(root) when its estimate is negative, and puts a token to the
external store to decrease A(root) when the estimate is positive.
If all processes v correctly estimate sgn(A(v)), each of them
eventually holds k tokens. After that, no process sends a token.

Thus, estimating sgn(A(v)) is the key of algorithm Basic. Each
process v computes Est(v), its estimate of sgn( A(v)) as follows.

1 = (Diff(v) > OA Wu € C(v) : ry,y-est € {1, O*, 0})
ot (Diff(v) =O A Vu € C(v): ry.y-est € {1, 0*, 0}
Adw € C(v):Ty.y».est € {0T, 1})
0 (Diff(v) =OA Vu € C(v): tv.est = 0)
(Diff(v) =O A Vu € C(v): ryy.est € {—1, 0°, 0}
Adw € C(v) : Tw.y.est € {0° ,—1})
—1 (Diff(v) < OA Vu € C(v): Myy-est € {—1, 07, 0})
| (otherwise),

Est(v) =
0-

where the candidate values 1, 0°, 0, O°, —1, and of Est(v)
represent that the estimate is positive, “never negative”, zero,
“never positive”, negative, and “unsure”, respectively. A process
sends a token to its parent only when its estimate is 1, and it
sends a token to its child only when the child’s estimate is —1.
Note that A(v) = ouer, Diff(u). For process v € V \ {root}, the
domain of variable r, ,;»).est is {1, 0°, 0,0, —1} if v is not a leaf,
and is {1, 0, —1} if v is a leaf.

Algorithms 1 and 2 give the pseudo code of Basic. When v
executes, it first checks whether each input register r,, holds a
token, and receives that token by invoking GetToken(u) unless
v.tokenStore is full, using the token-passing mechanism (Lines
16, 1-4). Then, v sends a token to each child u € C(v) such that
—HasToken(v,u) and ry,,.est = —1 (ie, A(u) is estimated to
be negative) by invoking PutToken(u) unless v.tokenStore is
empty (Lines 17, 5-9). Next, v € V \ {root} and root perform
different action. If v #4 root, it sends a token to its parent if
—HasToken(v, p(v)) and Est(v) = 1, ie, A(v) is estimated to be
positive, and reports the latest estimate of sgn(A(v)) to its parent
by storing Est(v) into ry p»).est (Lines 21-22). Note that Diff(v)
decreases when v sends a token to its parent, hence the values

of Est(v) may differ in Lines 21 and 22. Process root invokes
AdjustTokens() which may increase or decrease the number of
tokens in the tree (Lines 19, 10-15): root gets a token from the
external store and stores it to its token store if Est(root) = —1,
and it pops a token from its token store and puts the token to the
external store if Est(root) = 1.

In the algorithm description, we have used several functions
which take a process as an argument, such Est(v) and Diff(v).
The values of these functions also depend on the current con-
figuration. In what follows, we denote such functions with an
explicitly specified configuration when that configuration is not
clearly understood from context, such as Est(y, v) and Diff(y, v).

During a step, a process can use each link register at most
once to send/receive a token, and can send to or receive from the
external store at most one token. Subject to those constraints, a
process will send and receive as many tokens as possible, as we
state in Remark 1. We first define:

NumChildOut(v)
= |{u € C(v) | sHasToken(v, u) A ryy.est = —1}|
NumParentOut(v)

_ | 1if Est(v) = 1A (v = root V —HasToken(v, p(v)))
~ | O otherwise

NumOut(v) = NumChildOut(v) + NumParentOut(v)

Remark 1. Ifa process v is selected, then during that step: (a)
the number of executions of GetToken by v is min{NumIn(v), €—
NumStore(v) + NumOut(v)}, and (b) the number of executions of
PutToken by v is min{NumOut(v), NumStore(v) + NumIn(v)}.

In what follows, we show the correctness and evaluate the
number of redundant token moves and the convergence time of
algorithm Basic. First, we show that every computation of Basic
is finite (Lemma 2). The correctness of Basic immediately follows.
(Theorem 3).

Algorithm 1 Actions of Basic for Process v or root
[GetToken(u) for u € N(v)|:

1: if |v.ctokenStore|< ¢ then

2: Push(ry».token)

3: Reverse r, ,.in

4: end if

[PutToken(u) for u € N(v)]:

5: if |v.tokenStore|> O then

6: Ty,y.token < Pop()

7: Reverse ry ,.out

8:  GetToken(w) if dw € N(v) : HasToken(w, v)
9: end if

[AdjustTokens()

root)|:

10: if Est(root) = —1 then
11: Push(exGet())

12: else if Est(root) = 1 then

13: exPut(Pop())

14: GetToken(u) if du € C(root) : HasToken(u, root)
15: end if

(executed only by

Lemma 2. Every computation of Basic is finite.

Proof. Fix a computation I = yo, ,... of Basic. For any v € V,
we define a predicate Prinite(V) = PriniteMove( V) A Prinitegst(V), where
PriniteMove(V ) and Priniteest(V) are also predicates: PriniteMove(V ) holds
206 Y. Sudo, A.K. Datta, L.L. Larmore et al. / Journal of Parallel and Distributed Computing 146 (2020) 201-211

Algorithm 2 Code of Basic for Process v

16: GetToken(w) for all w € N(v) such that HasToken(w, v)

17: PutToken(u) for all u € C(v) such that r,,.est = —1A
—HasToken(v, u)

18: if v = root then

19: AdjustTokens()

20: else

21:  PutToken(p(v)) if Est(v) = 1 A —HasToken(v, p(v))

22: Ty,p(v)-eSt < Est(v)

23: end if

 

if and only if v sends and receives tokens only finitely many
times in J’, and Pniterst(v) Holds if and only if v = root or v
changes the value of r, »;»).est only finitely many times in J”. In
the remainder of this proof, we prove (Vu € C(v) : Prinite(u)) =>
Pénite(v) for all v € V. This proposition guarantees that every leaf
w Satisfies Prnite(w) because it has no children (BASE), and every
process v with height i > O satisfies Prnite(v) if every process u
with height smaller than i satisfies Prnite(u) (INDUCTION). Thus,
this proposition implies Prrite(v) for all v, which gives the lemma.

Let v € V, and suppose Pynite(u) holds for all u € C(v).
Then, v sends or receives no token to or from its children, and
Ty,y-eSt remains unchanged for all u € C(v) after some point
of the computation. Let y% bt y%4 1 be the first step that v is
selected after that point. (The unfair daemon may never select v
after that point, but we need not consider this case because then
Prinite(v) Clearly holds.) Consider a computation after that step,
say It41 = Vr4+1, %42,.... Process v sends a token to p(v) only
if Diff(v) > 0, and p(v) sends a token to v only if Diff(v) < 0.
Hence, v sends and receives tokens at most |Diff(}:+41, v)| times
in [41, which implies Pfinitemove(v). Thus, there exists t’ > t such
that v never sends or receives a token after ). Since Diff(v)
never changes after };, Est(v) also never changes after jj. This
means that r,,).est never changes after +1, which implies
Péiniterst(v). Thus (Vu € C(v) : Prinite(U)) => Prinite(v) holds for any
v, which gives the lemma from the above discussion.

 

 

 

 

Theorem 3. Algorithm Basic is a silent self-stabilizing token
distribution algorithm.

Proof. Let 7 = yw, ,... be a computation of Basic. Lemma 2
guarantees that y ends at its final configuration y;, that is, 7 =
Yo, ¥1,---, ¥f- No process is enabled in yr. Hence, every process
holds k tokens in its token store and no token exists in registers
in ys because otherwise some process must be enabled.

 

 

 

 

We now give an asymptotically tight bound on the number of
redundant token moves of Basic. Recall that « = min(k, £ — k).

Lemma 3. The number of redundant token moves in any compu-
tation of Basic is O(nhe).

Proof. For any process v, let At(v) = douer, max(Diff(u), 0)
and A(v) = deuer, max(—Diff(u), 0). During the computation
I = y,v1,... Of Basic, each v sends a token to p(v) at most
A*(yo,v) + n, times. This is because A*t(v) is monotonically
non-increasing, except for the case that the parent of a process
u € T, sends a token to u before the first time u is selected
by the scheduler, and At(v) decrements by one every time v
sends a token to p(v). Similarly, p(v) sends a token to v at most
A~(yo, v) times in I’. Since A(yo, v) = At(yo, v) — A7(y, v)
and ovev n, < nh, the number of redundant token moves in I”
is at most )>,<y(A*(yo, v) + A~(Yo, ¥) +My) — Dyey |A(Yo. v)| =

root

    

 

 

ecm Serr rrw |] ero
~~
ee ee ee

me fee fee

BES 3. |

x

Fig. 4. A tree to prove Lemma 4.

Dvev(2 min(A*(yo, v), A(yo, v)) + My) < Voyey(2 min(n,(¢ —
k), ny -k) +n,) = O(nhe).

 

 

 

 

Lemma 4. The number of redundant token moves in some compu-
tation of Basic is §2(nhe).

Proof. Consider the network shown in Fig. 4 where 2x - 2y
processes except for root are divided into four sets A, B, C, and D,
each of which consists of xy processes. Consider a configuration yo
where each process v in AUD holds no token (i.e., Diff(v) = —k),
each process u in BUC holds @ tokens (i.e., Diff(u) = € — k), and
Tu;,p(uj)-eSt = Tw;,p(w;) = 0 holds for alli=1,2,...,y.

Consider a computation 7 = y,y1,..., 7 such that the
scheduler selects no process in CUD until a computation reaches
a configuration, say y;,, where no process AUBU {root} is enabled.
Denote the prefix of [ with length ¢, ie,yo,4,...,%, by I’.
If k < €—k, A(y,v) => O holds for every process v in A.
Then, a process in A should not send a token to its child in I”
because this results in increasing | A(v)| by one. However, in I’,
the processes in A send tokens to their children y)~_, ik =
92(x?yk) in total. If k > @€ —k, A(yo,v) < O holds for every
process v in B. Then, a process in B should not send a token to
its parent in /’’ because this results in increasing |A(v)| by one.
However, in J’, the processes in B send tokens to their parents
y>._, (€ — k) = Q(x*y(€ — k)) in total. Therefore, we have
Yrev AC. v1 — Lyev |A(yo. v)| = 2(x*y - min(k, £ — k)) =
§2(nhe). This means that the number of redundant token moves
is §2(nhe) in computation I’.

 

 

 

 

Finally, we analyze the convergence time of Basic. We first
show that every computation of Basic satisfies predicate P.<¢(v),
which is defined as follows, within 2h, rounds for any process
v € V \ {root}:

Pest(v) = /\j-t.2.3,4Pilv) A Ajai.2.3 G(v) A Vu € Cv) : Pest(u)
Pi(v) = Ty pw)-est € {1,07} => A(v) > 0A Diff(v) = 0
Po(v) = MN pr)-est =O => A(v) =0A Diff(v) = 0
P3(v) = Tp). est =O => Alv) < 0A Diff(v) < 0
Pa(v) = Ty pv)-est = —-1 => (Av) < 0

V (A(v) = 0 A HasToken(p(v), v))) A Diff(v) < 0,
Y. Sudo, A.K. Datta, L.L. Larmore et al. / Journal of Parallel and Distributed Computing 146 (2020) 201-211 207

Qi(v) = Py po)-est € {1, OT} => WeT, > Tu p(u)-est
€ {1, 07, 0},
Qo(v) = TM po)-est =O > WeTy: up ee

Q3(v) = Ty po)-est € {0,-1} > We T,
€ {0,0°, —]}.

Lemma 5. Let v 4 root and let y +> y’ be a step of Basic where
Pest(v, v) holds. Then, the following three statements hold:

Y (Ty pv))-est =0> y'(rpv))-est = 0 (1)
Y(Ty.pv)).est € {1,07} > y'(Typu)).est € {1, OF, 0} (2)
V(Tupvy).est € {0°,-1} > Y'(Typ(v))-est € {0,0 ,—1} (3)

Proof. If y(ry,,v)).est = 0, then y'(ry,,»)).est = O because
Pes(yv, v) implies that Diff(y,v) = O and y(ry,,).est = O for
all u € C(v). If y(Tupw).est € {1,07}, then y’(rypv)).est €
{1,0*,0} because Pe t(y,v) implies that Diff(y,v) > O and
Vu € C(v) : y(Tuv).est € {1, 0%, 0}. Similarly, y’(r,p)).est €
{0,0-, —1} holds if y(ry p»)).est € {O-, —1}.

 

 

 

 

Lemma 6. Let v € V. If Pest(u) always holds for all u € C(v), then
once Pest(v) holds, Pest(v) always holds.

Proof. Let y + y’ be a step of Basic where P.(y,v) holds
and Pey(y,u) and Peyt(y’, u) hold for all u € C(v). It suffices
to show P..(y’, v) to prove the lemma. First, consider the case
of y(Tupvy)est = L. If ry p).est remains | in step y t>
y’, then Pest(y’, v) trivially holds. If ry,p»).est becomes 1 or 0*
at the step, ie, y/(Typv).est) € {1,07}, then P\(y’, v) holds
and y(ry.y.est) € {1,07, 0} for all u € C(v) by the definition
of Basic. The latter statement, and Lemma 5, imply Qi(y’, v).
Hence, Pest(y’, v) holds if y’(ryp).est) € {1,07}. Similarly,
Pest(y’, v) holds if y(rypv)-est) € {0,0 -,—1}. Next, suppose
V(Ty,pv))-est #~ L. In this case, y'(ry,yv)).est #~ L holds by
Lemma 5. If y/(Ty,pv)).-est € {1, OT}, then P;(y’, v) trivially holds
by the definition of Basic, and P.¢(y, v) and Lemma 5 imply that
y'(Tu,y).est € {1, 0*, 0} for all u € C(v), which implies Q;(y’, v).
Hence, Pest(y’, v) holds if y’(ryp).est) € {1,07}. Similarly,
Pest(y’, v) holds if y’(Ty,pu)-est) € {0, 07, —1}.

 

 

 

 

Lemma 7. Let v © V. If Pes(u) always holds for all u € C(v), Pest(v)
always holds once v is selected twice by the scheduler or v becomes
disabled.

Proof. Consider a computation = yo,y,... of Basic where
Pest(%, U) holds for all t > O and all u e€ C(v). During the
computation, P.<¢(v) holds when v is disabled, by the definition of
algorithm Basic, and by the assumption that P,.¢(u) holds for all
u € C(v). Hence, by Lemma 6, it suffices to show that Pest(}4;+1, v)
OF Pest(Y/41, v) holds where y% + 41, and jr K y%;41 are the
first and the second steps at which v is selected by the scheduler
in J”. Process p(v) cannot send a token to ry), in the both steps
because HasToken(p(v), v) never holds in yj if p(v) sends a token
tO Tyv),v IN step Y% -> Y%41. ASsume that p(v) does not send a
token to ry»), in step % +> Y%41. Then, we have A(y,v) =
A(y¥%+41, v). Therefore, Pest(¥:+1, v) holds thanks to the assumption
that Pest(;, u) holds for any u € C(v). Similarly, Pest(/41, v) holds
if p(v) does not send a token to r,,),, in step yw > Yjr44.

 

 

 

 

Lemma 8. Let v € V and let [ = y,y4,... be a computation
of Basic. The predicate Pest(y%:, v) holds for any t > s(I”, 2h,), ie
Pest(v) always holds after 2(h, + 1) rounds have elapsed.

Proof. The lemma is proven by induction on h,. By Lemmas 6
and 7, every leaf process w always satisfies Pe<t(w) after the first
two rounds have elapsed, and every non-leaf process w’ always
satisfies P.<¢(w’) after the first 2(h, + 1) rounds have elapsed if
every child w” € C(w) always satisfies Post(w”) after the first 2h,
rounds have elapsed.

 

 

 

 

We define C,,¢ to be the set of all configurations where P,.¢(v)
holds for all v # root. The following corollary directly follows
from Lemmas 6 and 7.

Corollary 1. A computation of Basic reaches a configuration of Cest
within 2h rounds and never deviates from C..¢ thereafter.

Furthermore, Lemma 9 trivially holds by the definition of
Basic. Note that Lemma 9 implies that no redundant token move
can occur after a computation reaches a configuration in Cec.

Lemma 9. For any process v, |A(v)| is monotonically non-
increasing during a computation of Basic starting from a configu-
ration in Cast.

In the rest of this section, we prove that every computation
starting from a configuration in C. finishes in O(né) rounds.
Given v € V, we define

Vj=1,2,...,|A(v)|
Daecapey a » IDiff(u)l = af?

where C;(v) is the set of processes in T, whose distance from v
is no greater than i (e.g., Co(v) = {v} and Ci(v) = {v} U C(v)).
See Fig. 5. In the left tree of the figure, R(v) = 1 because C3+1(v)
holds at least j extra tokens (i.e., Dd uecys:1(0) Diff(v) > j) for all
j = 1,2, 3, but C, holds no extra token. In the right tree of the
figure, R(v) = 3 because C)j,5(v) is short at least j tokens (.e.,
Dd ueCyp5(v \(—Diff(v)) = j) for j = 1,2, 3, but CG is short only
one taken. Let = yo, ¥i1,... be a computation starting from
a configuration in Ces, and v € V \ {root} be a process such
that ry »(»).est A 1 holds for some configuration y,. Then either
Wu € Ty : Tupuy.est € {1,07, 0} or Vu € Ty, : Tupw.est €
{0,0-,—1} holds for %, y44,.... Intuitively, R(y;,v) has the
following meaning: (i) when vel Typ y).est € {1,07}, v sends
A(y%,v) tokens to p(v) within 3(R(,;, v) + A(,%, v)) rounds in
Mt» Vt+1,--. If p(v) always receives a token from r,,,) immedi-
ately after v sends a token to r, py), and (ii) when (Ty, ~v)).est €
{O-, —1}, v receives —A(};, v) tokens from p(v) within 3(R(},, v)
— A(y%;, v)) rounds in y%, %41,... if p(v) always sends a token to
rp(v),v Immediately after —HasToken(p(v), v) A Tyv),v-est = —1
becomes true. Note that R(v) = O holds when A(v) = O, by
definition of R(v). For any process v ¢€ V, we define f(v) as
follows:

R(v) = min |: >0

 

R(v) + |A(v)| + |{u € Ty | rupay-est # O}|
if v Aroot Ar, yy).est A L
C434 decir fu)

if v Aroot Ar, yy).est = L

flv) =
duec(v) f(u)

otherwise.
Lemma 10. For any configuration y, f(y, root) = O(n¢).
Proof. Let v be any process other than root. Define V’ = {u €
T, | Y (Tu pw))-est Zl1LA(uU=vvV Y (Tpw),p(p(w)) )-e St = l)}.
Then, f(v.v) < dyer, (6 + 3) + Vyew (Rv. u) + |A(y, u)) +
[{u' < Ty | Vw pw))-est A O}|) < m(€ + 3) + douev (Au + Ny -
€+ny) < n(€+ 3) + do ey mu(é + 2) < n,(2¢ + 5). Therefore,
Fly, T00t) < > ,cceroot) Mo(2l + 5) = O(nL).

 

 

 

 
  

208
percep ee ee - - - -  e e  e
o en sos
ce enna E SS SSE SSS SAN
Vay voy
’ / “C3(v){ {C,(v) ry. \
i ‘co(v) 3 pV vy
Cy (v yI 1 ry) ' 4
'Co(v), 7 1!
p9N771 I ‘1
I I I I i i ;
I I I 1 l
4 | I I
I I I Po Off Rm 14
I I I 1 ria
I I I I rig
I ! I I ria
I ! I I ria
I 1 I \ ae
I ; I ‘ / a
I 1 I Swf UY ELL 1 |
I I I 1
I l I 14
I I I 1
l I \ ty
I | \ y
I I \ ,
I I SoU LL EL LLL LL LLL LLL 7 l
I l !
I
I I
I \ |
I \ /
l ‘. 7
l \ ”
I Sen ULL LL LLL LLL LIL LL LI LLL LL re
I
\
\ /
\ +1 /

 

wee eee ee eee eee eee ee ee eee

Fig. 5. A tree network T, with A(v) > 0

Note that f(v) is monotonically non-increasing during any
computation starting from a configuration in C,,, because both
R(v) + |A(v)| and |{u € Ty | Tupw.est A O}| are monotonically
non-increasing once Ty pv) A L ‘holds in such a computation.
Moreover, f (root) decreases by at least one within a constant
number of rounds, which we will prove as Lemma 16. We first
prove Lemmas 11-15 to prove Lemma 16.

Lemma 11. Let v 4 root and I’ = yo, y1,... a computation of
Basic starting from a configuration in Cest where yo(Tv,pv)).est A
L. In the first three rounds of I’, R(v)+|A(v)| decreases by at least
one if R(yo, v) > 0 or |A(yo, v)| > |Alycr.3), V)I-

Proof. Let t = s(I’,3),c = R(yo,v), and x = |A(y, v)| —
|A(%, v)|. (x is the number of tokens that v sends to p(v) or
p(v) sends to v in yo, y1,..., %.) Assume that c > OVx > 0.
It suffices to show Dd lucCyjrerx ». ») Diff(%, u)| = j for any j €
{1,2,..., |A(%, v)|} because we then obtain R(y%,, v) <c+x—1,
which results in R(%,v) + |A(%, v)| < R(yo, v) + |A(y%, v)]. In
the rest of this proof, let us write i = 297 +c +x—-—1)-— 1.
Note that i > 1 becausec > Oorx > O, andj > 1. By
definition of c = R(y, v), Dd uec;(v) |Diff(yvo, u)| > j+x—1 holds. If

yuec(v) Diff (vo, u)| > j+x, then, trivially, yueC(v) \Diff (v%i, u)| >
j. Herice, we need consider only the case yueci(v) \ Diff (Yo, u)| =
j +x — 1. In this case, letting C_;(v) = @ for simplicity, we

have “asc \C_a(v ) Diff (vo. u)| < 1 because otherwise (i.e., if

dct) Diff. u)| > 2):

e ifj+x > 3 holds, then dueCag peta »- ») Diff(vo,u)| =
yueC,_o(v) \Diff(yo,w)| <j+rx—1-2 < 5 + x — 2, which
contradicts c = R(y, v),

e if j+x <2 holds, then >~
which contradicts )°¢./,)

j+tx-1<1,

ueC(v

) Diff (vo, 4)
Diff (yo. u)|

On the other hand, we have Dd iueCipo(v)\ ») Diff (vo, u)| = 1 since

c = Ryo, v) and Yo ec(v) Diff(0. Ww] = +x —1 < [Aly v)l
Hence, if yo(Ty,pv)).est € a. O*} (thus yo(Ty,pu))-est € {1, 0*, 0}
for all u € T,), then some process w € C41 \ C sends a token to
its parent within the first two rounds of I”, and if yo(Ty,p(»)).est €
{O~, —1} (thus yo(Tupuy).est € (0,07, —1} for all u ¢€ T,), then
some process w € C; \ G_1 sends a token to some of its children
w’ with ry ,y.est —1 within the first three rounds of I.

Thus, deuec, |Diff (1, u)| = j if Yo(Ty,p(v))-est € {1, Or, 0'" —1}.

>?
Ge 2(v —

eS

(Left) A tree network with A(v) < 0 (Right). The signed integer with process w indicates Diff(w

Y. Sudo, A.K. Datta, L.L. Larmore et al. / Journal of Parallel and Distributed Computing 146 (2020) 201-211

esse

oe “aol s(v)l ‘ca(v)! Cv)
CoP) !

      

l
l
l
l
l
l
l
\

~~ ee ele ee ee fee ee _—

ww = ee Be ee ee ee ee ee eS eS =

mee eee ee a

ee ee ee Be Be eB eB eB eB eB eB eB eB eB eB ee eB eB ee ee

), omitted when Diff(w) = 0.

The lemma holds because c > 0 Vx > O and yw © Ces imply
Yo(Tv,p(v)).est A 0.

 

 

 

 

Lemma 12. Let v 4 root and let y +» y’ be a step of Basic where
Vv € Ces If y(v).est = L and y’(v).est # L hold, then we have

flv v) <fly, v).

Proof. Since y © Cest, we have R(y’, w)+ |A(y
|A(yv, w)| for all w € V \ {root}. Moreover, y'(v
y(u).est # L for all u € C(v). Therefore:

‘,w)| < Ry, w)+
).e st ~ | implies

<
of

f(y, v)
= Ry’, v) + |A(y’, v)| + l{u € Ty | v(tupw)-est 4 0}|

 

 

 

 

<[{1+ yi Ry’, u) | + | IDiff(y’. vl + SO [Ay w)|
ueC(v ueC(v)
+ {14+ D0 Iw € Tul y'Cw.p(w))-est # 0}
ueC(v)
< DRY w+ 1AG wl + tw € Tr y'Crw,pw)-est # 0}!)
ueC(v)
+ |Diff(y', v)| +2
< D7 Ryu) + 1A(y. ul +1(w € Tu 1 7 w,n0w))-e8t # 0}!)
ueC(v)
+€+2
<€+2+ 9° f(y.u)
ueC(v)
< f (Yo, v).
Lemma 13. Let v € Vand I’ = y,y,... be a computation

of Basic starting from a configuration in Cest. Assume that there are
two processes u,u’ € C(v) such that A(yo,u) > 0, A(yo, u’) < O,
R(yo, U) = R(yo, u’) = O, Yo(Tu»).est A 1, and yo(Ty,y).est A 1.
Then there exists a process w € C(v) such that | A(w)| decreases by
at least one in the first three rounds of I’.

Proof. Since J" starts from a configuration in C,., for any process
w € C(v), |A(w)| decreases by at least one if v sends a token
to w or w sends a token to v. Assume for contradiction that no
Y. Sudo, A.K. Datta, L.L. Larmore et al. / Journal of Parallel and Distributed Computing 146 (2020) 201-211 209

process in C(v) sends a token to v and v never sends a token to
its children during the first three rounds of J”. The assumption
R(yo, U) = R(yo, u') = O implies that wee, (u Diff(w) > 1 and
wee, (u') Diff (w) < —1 hold in the initial configuration yo € Cest.
Thus, Diff(u) > 0, Diff(u’) < 0, =HasToken(v, u’), and u.est = —1
hold at the end of the second round. Therefore, if v has at least
one token in its token store or input registers at the end of the
second round, then v must send a token to u’ or some other child
of v in the third round. Otherwise, u must send a token to v in
the third round. Thus, we reach a contradiction.

 

 

 

 

Lemma 14. Let v #4 root and I = yo, y,... a computation of
Basic starting from a configuration in Ces. In the first round of I,
f (uv) decreases by at least one if yo(Ty,,v)).est = L, A(yo, v) = 0,
and f(yo, v) > 0.

Proof. Assume that yo(Typv)).est = 1, A(yo,v) = O, and
f(vo,v) > 0 hold. If yo(Ty.yv))-est € {1,07}, A(yo,v) > O
because yo € Cest; however this contradicts A(yo,v) = O. If
Yo(Typ(v))-est = 0, then yo(Typw).est = O holds for all u €
T, because yo € Ces; however this contradicts f(y,v) > O
and A(yo,v) = O. Hence, we need consider only the case that
Yo(Tupiv))-est € {O-,—1}. Since yo € Cey and A(y,v) =
deuer, Diff(vo, u) = 0, we have yo(Ty.puy).est € {0, 07, —1} and
Diff(yo, u) = O for all u € T,. This implies that at least one process
in T, changes its est from O~ or —1 to O in the first round of I’.
Therefore, f(v) decreases in the first round of I’.

 

 

 

 

Lemma 15. Let v £ root and Il’ = yw, ,... be a computation of
Basic starting from a configuration in Ces. In the first three rounds
of I’, f(v) decreases by at least one if yo(Typv)).est = L.

Proof. Let t = s(I’, 3). Let Pi;5(v) be the predicate that holds if
and only if yo(Ty,pv)).est A L or f(yo,v) > f(%, v). We prove
that Pij5(v) holds for all v € V \ {root} by induction, which yields
the lemma. Every leaf process w satisfies P,j5(w) because the
domain of ry p(w).est excludes L. For the inductive step, assume
P,15(u) for all u € C(v) and assume —P,;5(v) for contradiction. By
Lemma 12, ry ,p(v).est = L always holds in the first three rounds,
1€.,Yo, ¥1,-.., Ye. Since f(w) is monotonically non-increasing for
all w € V, it suffices to show that f(u) = €+ 3+ euectyyf (U4)
decreases by at least one in the first three rounds for some child
u € C(v).

If some u € C(v) Satisfies yo(Typ»v)).est = L, f(u) de-
creases by at least one since P,;5(u) holds, contradiction. There-
fore, yo(Ty,v).est ~ L holds for all u € C(v). If R(yvo, u) > O for
some u € C(v), f(u) decreases by at least one in the first three
rounds, by Lemmas 11 and 12, contradiction. Hence, R(jyo, u) = 0
for all u € C(v). Consider that there are two children u’ and u”
such that A(yo, u’) > O and A(yo, u”) < 0. Then, | A(w)| decreases
by at least one for some w € C(v) in the first three rounds by
Lemma 13. Thus f(w) also decreases in the first three rounds
by Lemma 11, contradiction. Furthermore, there is no process
u € C(v) such that A(yo, u) = O because otherwise f(u) decreases
in the first round of J” by Lemma 14. Above, we have shown the
followings:

(i) Vu € C(v): yolTu,y).est A L, and
(ii) (Vu € C(v): A(yo, u) > 0) V (Vu € C(v): A(y%, U) < 0)

The second statement implies that there exists no two processes
u’,u” € C(v) such that u’.est € {1,07} and u”.est € {0°,—1}
since Yo € Ces. Therefore, by the first statement, yo(Ty,,).est €
{1,0*,0} holds for all u € C(v) or yo(Ty,y).est € {0,07, —1}
holds for all u € C(v). However, this implies that r, p(»).est A L
holds within the first three rounds by Lemma 5, contradiction.

 

 

 

 

Lemma 16. Let IX = yo, y1,... be a computation of Basic starting
from Cest. Then, f(root) decreases by at least one in the first three
rounds of I’ if f(yo, root) > 0.

Proof. Assume that f(yo, root) > O and let t = s(J", 3). Assume
for contradiction that f(root) does not decrease in the first three
rounds of I’, 1.e.,f(yo, root) = f(,;, root). Then, in the same way
as the proof of Lemma 15, the following two statements hold:

e R(y, u) = O for all u € C(root), and
© Yo(Tu.y).est € {1, OT, 0} holds for all u € C(v) or yo(Ty,»).est
€ {0,0-, —1} holds for all u € C(v).

Then, root decreases f(u) by at least one for some u € C(v) by
pushing a token to or pulling a token from the external store in
the first three rounds of I”, which gives f(};, root) < f(y, root),
contradiction.

 

 

 

 

Lemma 17. Every computation I” of Basic ends within O(né)
rounds.

Proof. Corollary 1, Lemmas 10 and 16 imply that I” reaches a
configuration where r,,,.).est = O and A(v) = O for all v €
V \ {root} within O(né) rounds. By pushing tokens to or pulling
tokens from the external store, root also holds exactly k tokens
after an additional O(£) rounds, which results in a configuration
where no process is enabled.

 

 

 

 

Theorem 4. Algorithm Basic is a silent and self-stabilizing token
distribution algorithm, which uses no work space per process and
only constant work space per register, converges in O(n¢) rounds,
and has @(nhe) redundant token moves.

4.5. Algorithm SyncTokenDist

In this subsection, we present algorithm SyncTokenDist, which
reduces the number of redundant token moves of Basic. The key
idea is simple. Corollary 1 and Lemma 9 guarantee that every
computation of Basic reaches a configuration in Ces within 2h
rounds and no redundant token moves happen thereafter. How-
ever, some processes can send or receive many tokens in the first
2h rounds, which makes §2(nhe) redundant token moves in total
in the worst case (Lemma 4). Algorithm SyncTokenDist simulates
a computation of Basic with a simplified version of a synchronizer
given by [16], which loosely synchronizes a computation of Basic
so that the following property holds.

For any integer x, if a process executes the procedure of Basic
at least x + 2 times, then every neighboring process of the
process must execute the procedure of Basic at least x times.

This property and Lemma 7 guarantee that every process v can
execute the procedure of Basic at most O(h) times until a config-
uration in Ce. is reached, after which no redundant token moves
happen.

Algorithm 3 SyncTokenDist
[Actions of process v]
1: if (Vu € N(v) : ~Ahead(v, u) A dw € N(v) : Ahead(w, v))
V(Basic—Enabled(v) A Vu € N(v) : u.clock = v.clock)
then
2: v.clock < v.clock+ 1 (mod 3)
3: Execute the procedure of Basic
4: end if
5: Ty,y.-clock < v.clock for all u € N(v)
210 Y. Sudo, A.K. Datta, L.L. Larmore et al. / Journal of Parallel and Distributed Computing 146 (2020) 201-211

root

 

the 0-wave

the 1-wave

root root

 

the 2-wave

Fig. 6. PIF waves of PIFTokenDist. A number in a circle represents the value of variable wave. Note that the O0-wave and the 1-wave run simultaneously.

The code of SyncTokenDist is shown in Algorithm 3. Every
process v has variable v.clock ¢€ {0,1,2} and r,,.clock ¢€
{0, 1,2} for every u € N(v). It always copies the latest value
of v.clock to r,,.clock for all u € N(v) (Line 20). It also has
all variables of Basic to simulate a computation of Basic. We
say that a process u is ahead of v if u.clock = v.clock + 1
(mod 3), written Ahead(u, v). Process v increments its clock when
it is ahead of no neighbors and it has a neighbor that is ahead
of v or when v is enabled to execute the procedure of Basic
(written Basic—Enabled(v)) and v.clock = u.clock holds for all
neighbors u € N(v) (Line 17). Process v executes the procedure
of Basic every time v increments its clock (Line 18). It is easy to
see that this simple algorithm satisfies the above property, hence
we obtain the following theorem.

Theorem 5. Algorithm SyncTokenDist is a silent and self-stabilizing
token distribution algorithm, which uses only constant work space
per process and per register, converges in O(n) rounds, and causes
O(nh) redundant token moves.

4.6. Algorithm PIFTokenDist

In this section, we present PlFTokenDist, which reduces the
number of redundant token moves of Basic from O(nhe) to O(n),
but increases the convergence time from O(né) to O(nhé). Al-
gorithm PIFTokenDist uses a Propagation of Information with
Feedback (PIF) scheme [4] to reduce the number of redundant
token moves. We use a simplified version of PIF. The pseudo
code is shown in Algorithm 4. Each process v has a local variable
v.wave € {0, 1,2}, a shared variable r,,.wave € {0, 1,2} for
all u € N(v), and all variables of Basic. A process v always
copies the latest value of v.wave to r,,,.wave for all u € N(v)
(Line 4). A computation of PIFTokenDist repeats the cycle of three
waves — the 0-wave, the 1-wave, and the 2-wave (Fig. 6). Once
root.wave = 0, the zero value is propagated from root to leaves
(Line 1, the O-value). In parallel, each process v changes v.wave
from O to 1 after verifying that all its children already have the
zero value in variable wave (Line 2, the 1-wave). When the 1-
wave reaches a leaf, the wave bounces back to the root, changing
the wave-value of processes from 1 to 2 (Line 3, the 2-wave).
When the 2-wave reaches the root, it resets root.wave to 0, thus
the next cycle begins. A process v executes the procedure of Basic
every time it receives the 2-wave, that is, every time it changes
v.wave from 1 to 2 (Line 3).

It is easy to see that every computation of PIFTokenDist reaches
a configuration from which the cycle of three waves is repeated
forever. Furthermore, the above PIF mechanism guarantees that,
for any path vo, v1,...,U, such that vo is a leaf, each process
vj (1 < i < p) receives the 2-wave at least once in the order
Of vo, U1,..., Up before v, receives the 2-wave twice. Therefore,
it holds by Lemma 7 that a computation of PIFTokenDist reaches

a configuration in C,, before some process executes the pro-
cedure of Basic more than three times. Hence, the number of
redundant token moves is O(n) in total. However, the conver-
gence time increases from O(n¢) to O(nhé) because it takes O(h)
rounds between every two consecutive computation of the pro-
cedure of Basic at each process in a computation of PIFTokenDist.
PIFTokenDist, shown in Algorithm 4, is not silent. However, we
can make PIFTokenDist silent by slightly modifying it such that the
root begins the O0-wave at Line 16 only when it detects that the
simulated algorithm (Basic) has not terminated. This modification
is easily implemented by using the enabled-signal-propagation
technique presented in [5].

Theorem 6. PIFTokenDist is a silent and self-stabilizing token distri-
bution algorithm, which uses constant work space per process and
per register, converges in O(nh¢) rounds, and uses O(n) redundant
token moves.

Algorithm 4 PIFTokenDist
[Actions of process v]
1: vu.wave < 0 if (v = root A v.wave = 2)V (uv ¥ root A
rp(v),v-wave = 0)
2: u.wave < 1 if (v.wave = 0) A (v = root V ry,),,.wave =
1) AVu € C(v) : Ty, y.wave = 0)
3: v.wave < 2 and execute the procedure of Basic if (v.wave =
1) A (Vu € C(v) : ty,y.wave = 2)
4: Ty y.wave < v.wave for all u € N(v)

5. Conclusion

We have given self-stabilizing and silent distributed algo-
rithms for token distribution for rooted tree networks. The base
algorithm Basic converges in O(n@) asynchronous rounds and
causes O(nhe) redundant token moves. Algorithms SyncTokenDist
and PIFTokenDist use a synchronizer and a PIF scheme, respec-
tively. Algorithm SyncTokenDist reduces the number of redundant
token moves to O(nh) without increasing convergence time while
PIFTokenDist reduces the number of redundant token moves to
O(n), but increases the convergence time to O(nh€) rounds. All
of the three algorithms uses constant memory space for each
process and each link register.

CRediT authorship contribution statement

Yuichi Sudo: Conceptualization, Methodology, Formal analy-
sis, Writing - original draft, Funding acquisition. Ajoy K. Datta:
Conceptualization, Methodology, Investigation, Writing - original
draft, Project administration. Lawrence L. Larmore: Methodol-
ogy, Formal analysis, Writing - review & editing. Toshimitsu
Masuzawa: Conceptualization, Writing - review & editing, Project
administration, Funding acquisition.
Y. Sudo, A.K. Datta, L.L. Larmore et al. / Journal of Parallel and Distributed Computing 146 (2020) 201-211 211

Declaration of competing interest

The authors declare that they have no known competing finan-
cial interests or personal relationships that could have appeared
to influence the work reported in this paper.

Acknowledgments

This work was supported by JSPS KAKENHI Grant Numbers
18K18000, 19H04085, and 20H04140 and JST SICORP Grant Num-
ber JPMJSC1606.

References

[1]

[2]

[3]
[4]

[5]

[6]

[7]

[8]

[9]

[10]

[11]

[12]
[13]

[14]

Y. Afek, G.M. Brown, Self-stabilization over unreliable communication
media, Distrib. Comput. 7 (1) (1993) 27-34.

A. Arora, M.G. Gouda, Load balancing: An exercise in constrainted conver-
gence, in: Proceedings of the 9th International Workshop on Distributed
Algorithms, 1995, pp. 183-197.

A.Z. Broder, A.M. Frieze, E. Shamir, E. Upfal, Near-perfect token distribution,
Random Struct. Algorithms 5 (4) (1994) 559-572.

A. Bui, A.K. Datta, F. Petit, V. Villain, Snap-stabilization and PIF in tree
networks, Distrib. Comput. 20 (1) (2007) 3-19.

A.K. Datta, L.L. Larmore, T. Masuzawa, Y. Sudo, A self-stabilizing minimal
k-grouping algorithm, in: Proceedings of the 18th International Conference
on Distributed Computing and Networking, ACM, 2017, pp. 3:1-3:10.

B. Ghosh, F.T. Leighton, B.M. Maggs, S. Muthukrishnan, C.G. Plaxton, R.
Rajaraman, A.W. Richa, R.E. Tarjan, D. Zuckerman, Tight analyses of two
local load balancing algorithms, SIAM J. Comput. 29 (1) (1999) 29-64.
K.T. Herley, A note on the token distribution problem, Inf. Process. Lett.
38 (6) (1991) 329-334.

M.E. Houle, A. Symvonis, D.R. Wood, Dimension-exchange algorithms for
load balancing on trees, in: Proceedings of the 9th International Collo-
quium on Structural Information and Communication Complexity, 2002,
pp. 181-196.

M.E. Houle, E.D. Tempero, G. Turner, Optimal dimension-exchange token
distribution on complete binary trees, Theoret. Comput. Sci. 220 (2) (1999)
363-376.

M.E. Houle, G. Turner, Dimension-exchange token distribution on the mesh
and the torus, Parallel Comput. 24 (2) (1998) 247-265.

L. Margara, A. Pistocchi, M. Vassura, Perfect token distribution on trees, in:
Proceedings of the 11th International Colloquium on Structural Information
and Communication Complexity, 2004, pp. 221-232.

D. Peleg, Distributed Computing: a Locality-Sensitive Approach, vol. 5,
Society for Industrial Mathematics, 2000.

D. Peleg, E. Upfal, The generalized packet routing problem, Theoret.
Comput. Sci. 53 (1987) 281-293.

D. Peleg, E. Upfal, The token distribution problem, SIAM J. Comput. 18 (2)
(1989) 229-243.

 

 

 

[15] Y. Sudo, A.K. Datta, L.L. Larmore, T. Masuzawa, Self-stabilizing token dis-

tribution with constant-space for trees, in: 22nd International Conference
on Principles of Distributed Systems, 2018, pp. 31:1-31:16.

[16] Y. Sudo, A.K. Datta, L.L. Larmore, T. Masuzawa, Constant space self-

stabilizing center finding algorithms in chains and trees, Parallel Process.
Lett. 28 (01) (2018) 1850002:1-15.

Yuichi Sudo received the B.E., M.E., and Ph.D. degrees
in computer science from Osaka University in 2009,
2011, and 2015. He had worked at NTT Corpora-
tion and had been engaged in research on network
security during 2011-2017. He is now an assistant
professor of Graduate School of Information Science
and Technology, Osaka University. His research inter-
ests include distributed algorithms, graph theory, and
network security.

Ajoy K. Datta is a professor of Computer Science
at the University of Nevada Las Vegas. His research
interests are in the areas of Distributed Computing and
Self-Stabilization.

Lawrence L. Larmore is a professor of Computer
Science at the University of Nevada Las Vegas. His
research interests are in the areas of Distributed
Computing, SelfStabilization, and On-Line Algorithms.

Toshimitsu Masuzawa received the B.E., M.E. and D.E.
degrees in computer science from Osaka University
in 1982, 1984 and 1987. He had worked at Osaka
University during 1987-1994, and was an associate
professor of Graduate School of Information Science,
Nara Institute of Science and Technology (NAIST) dur-
ing 1994-2000. He is now a professor of Graduate
School of Information Science and Technology, Osaka
University. He was also a visiting associate professor
of Department of Computer Science, Cornell University
between 1993-1994. His research interests include dis-

tributed algorithms, parallel algorithms and graph theory. He is a member of
ACM, IEEE, IEICE and IPSJ.
