Journal of Automated Reasoning (2020) 64:1553-1610
https://doi.org/10.1007/s10817-020-09541-4

®

Check for
updates

Theorem Proving for Pointwise Metric Temporal Logic Over
the Naturals via Translations

Ullrich Hustadt'@ - Ana Ozaki*@® - Clare Dixon'®

Received: 31 May 2019 / Accepted: 6 January 2020 / Published online: 19 February 2020
© The Author(s) 2020

Abstract

We study translations from metric temporal logic (MTL) over the natural numbers to linear
temporal logic (LTL). In particular, we present two approaches for translating from MTL
to LTL which preserve the ExpSpace complexity of the satisfiability problem for MTL.
In each of these approaches we consider the case where the mapping between states and
time points is given by (i) a strict monotonic function and by (ii) a non-strict monotonic
function (which allows multiple states to be mapped to the same time point). We use this
logic to model examples from robotics, traffic management, and scheduling, discussing the
effects of different modelling choices. Our translations allow us to utilise LTL solvers to
solve satisfiability and we empirically compare the translations, showing in which cases one
performs better than the other. We also define a branching-time version of the logic and
provide translations into computation tree logic.

Keywords Metric temporal logic - Theorem proving - Modelling

1 Introduction

Linear and branching-time temporal logics have been used for a long time for the specification
and verification of reactive systems. In linear-time temporal logic (LTL) [24,48] we can, for
example, express that a formula w holds now or at some point in the future using the formula
Ow (w holds eventually). However, some applications require not just that a formula w will

C. Dixon was partially supported by the EPSRC funded RAI Hubs FAIR-SPACE (EP/R026092/1) and RAIN
(EP/RO26084/1), and the EPSRC funded programme Grant S4 (EP/N007565/1).

Eb Clare Dixon
cldixon @liverpool.ac.uk

Ullrich Hustadt
uhustadt @liverpool.ac.uk

Ana Ozaki
ana.ozaki@unibz.it

Department of Computer Science, University of Liverpool, Liverpool, UK

Faculty of Computer Science, Free University of Bozen-Bolzano, Bolzano, Italy

Q) Springer
1554 U. Hustadt et al.

hold eventually but that it holds within a particular time-frame, for example, between 3 and
7 moments from now.

To express such constraints, a range of Metric Temporal Logics (MTL) have been proposed
[6,7], considering different underlying models of time and operators allowed. MTL has been
used to formalise vehicle routing problems [35], monitoring of algorithms [28,53] and cyber-
physical systems [2], among others. A survey about MTL and its fragments can be found in
[46]. It is known that MTL over the reals is undecidable, though, decidable fragments have
been investigated [5,10,12].

Here we consider MTL with pointwise semantics over the natural numbers, following [6],
where each state in the sequence is mapped to a time point on a time line isomorphic to the
natural numbers. In this instance of MTL, temporal operators are annotated with intervals,
which can be finite or infinite. For example, (3,7) 7 means that p should hold in a state that
occurs in the interval [3, 7] of time, while O/2,.0) p means that p should hold in all states that
occur at least 2 moments from now. In contrast to LTL, where the time difference from one
state to the next is always one, in MTL, time is allowed to irregularly ‘jump’ from one state
to the next. The semantics uses a mapping from states to time points to keep track of the time
difference between consecutive states. MTL formulae can then express constraints on such
time differences. For example, using ©)2,2}p we can state that the time difference from the
current state to the next state is two while ©Oj3,.0]p states that the next state is at least three
moments from now.

Following Alur and Henzinger [6], the mapping between states and time points is given by
a (weakly) monotonic function, which allows multiple states to be mapped to the same time
point. Underlying this semantics is the so-called digital-clock assumption: different states
that are associated with the same discrete clock record events happening between successive
clock ticks. If no events occur over one or more successive clock ticks, no state will be
associated with those clock ticks. In this work, we also consider the semantics where the
mapping between states and time points is given by a strictly monotonic function, which
forces time to progress from one state to another.

We provide two approaches for translating from MTL to LTL: in the first approach we
introduce a fresh propositional variable that we call ‘gap’, which is used to encode the
‘jumps’ between states, as mentioned above; the second approach is inspired by [6], where
fresh propositional variables encode time differences between states. In each approach we
consider the case where the mapping between states and time points is given by: (1) a strict
monotonic function and by (ii) a non-strict monotonic function (which allows multiple states
to be mapped to the same time point). All translations are polynomial w.r.t. the largest con-
stant occurring in an interval (although exponential in the size of the MTL formula assuming
a binary encoding of the constants). Since the satisfiability problem for LTL is PSpace-
complete [51], our translations preserve the ExpSpace complexity of the MTL satisfiability
problem over the natural numbers [6]. We provide a range of examples from robotics, traf-
fic management, and scheduling. We present and discuss different modelling choices and
their effect, including the choice between strict and non-strict semantics as the basis for the
formalisation of a domain.

The translations allow us to use existing LTL solvers to determine the satisfiability of MTL
formulae. To the best of our knowledge, there are no implementations of solvers for MTL with
pointwise discrete semantics. We use several LTL solvers, covering a wide range of calculi
and methods, to experimentally investigate the properties of the LTL formulae resulting from
the translation of MTL formulae. We provide experimental results for both the modelled
examples and we propose specific formulae to investigate and analyse the difference between
the translations and provers.

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1555

Finally we consider a branching-time version of MTL and provide a translation into
Computation Tree Logic (CTL) using the gap translation.
Our contributions are:

— translations from MTL to LTL which preserve the ExpSpace complexity of the MTL
satisfiability problem and allow the use of LTL solvers to determine the satisfiability of
MTL formulae;

— an experimental analysis of the behaviour of LTL solvers on the resulting formulae;

— encodings of problems from robotics, traffic management, and the classical multiproces-
sor job-shop scheduling problem [16,27] into MTL, as examples of the kind of problems
that can be solved using MTL;

— discussions about the modelling of these examples that illuminate interesting aspects of
MTL specifications; and

— a translation from a branching-time version of the logic into CTL that gives a tight
2EXPTIME upper bound to the satisfiability problem.

This paper is a revised and extended version of [33]. It includes a range of examples
specified in MTL, full proofs, full details, updated and extended experimental results, a
branching-time version of the logic with its translation into CTL and a more comprehensive
discussion of related work.

In Sect. 2 we provide the syntax and semantics of LTL and MTL. We provide a range
of examples in Sect. 3 encoding problems in MTL from robotics, traffic management, and
job-shop scheduling. Our translations from MTL to LTL are provided in Sects. 4 and 5.
Experimental results are provided in Sects. 6 and 7. A branching-time version of the logic
and its translation into CTL is given in Sect. 8. We discuss related work in Sect. 9 and provide
concluding remarks in Sect. 10.

2 Preliminaries

We briefly state the syntax and semantics of LTL and MTL. Let P be a (countably infinite) set
of propositional variables. Well formed formulae in LTL are formed according to the rule:

QV = Pl-el@AWlog|@uUy)

where p € P. We often omit parentheses if there is no ambiguity. We denote by O* a
sequence of c next operators, ie., O89 = yg and 0" t!g = 00"¢9, for every n EN.

An LTL model or state sequence o over (N, <) is an infinite sequence of states oj C P,
i € N. The semantics of LTL is defined as follows.

(o,i) E p iff p € 0;

(o,i) F@AYW) iff(o,i) Fgand(o,i) Ey

(0,1) F 79 iff (0,1) Fe

(0,1) F O@ iff(o,it+l) E@

(o,i) F(@UW) iffsk >i:(0,k) FWandVj,i<j<k:C,jJ-¢g@

Further connectives can be defined as usual: true = pV —p, false = —(true), Og = truel/y
and Og = —0-@. To simplify the presentation, we further use additional n-ary boolean
operators. If S = {@1,..., Gp} 1s a finite set of LTL formulae, then 6<;S, ®+1S, and
1S resp., are LTL formulae. The semantics of such formulae is as follows. Let o’ be a
state sequence andi € N. Then, (o’,i) FE @<1S iff (o’,i) & gj; for at most one g; € S,

Q) Springer
1556 U. Hustadt et al.

1 < j <n. Analogously, (o’, 7) F @>1S iff (o’, i) — g; forat least one gy; € S,1 < j <n;
and (o’,i) FE @=1S iff (o’,i) E @s1S A @<1S.

MTL formulae are constructed in a way similar to LTL, with the difference that temporal
operators are now bounded by an interval J with natural numbers as end-points or oo on the
right side. Note that since we work with natural numbers as end-points we can assume w.l.0.g
that all our intervals are of the form [c), c2] or [c}, ©), where c}, co € N. We sometimes
write k € j +[c1, c2] with the meaning that k € [cy + J, co + j]. Well formed formulae in
MTL are formed according to the rule:

gv = Pl-e@l@AW) log! Gury)

where p € P. A timed state sequence p = (o,T) over (N, <) is a pair consisting of an
infinite sequence o of states oj C P,i € N, and a function t : N — N that maps every i
corresponding to the i-th state to a time point t(i) such that tT) < t@ + 1). A non-strict
timed state sequence p = (a, T) over (N, <) is a pair consisting of an infinite sequence o of
states oj C P,i € N, and a function t : N — N that maps every 7 corresponding to the i-th
state to a time point T(z) such that tT(i) < t(@i + 1). We assume w.l.o.g. that T(0) = 0. The
semantics of MTL is defined as follows:

(0,1) FE p iff p € oj;
(O,I)E@AW) iff(p,i) Fgand(p,i) Fy;
(p,i) F 79 iff (0,1) FQ;

(p,1) FOrg iff(o,i+1) Ryandt@+1)—t@) eT;
(0,1) EF (ply w) iffak >i: t(k)—Tt(i) eT and (p,k) Fy;
and Wj, i<j <ki (pj) Fg.

Further connectives are defined as usual: O;g = (true U/; g) and O;g = -0,-7@. A timed
state sequence p = (0, T) is amodel of an MTL formula ¢ iff (0, 0) FE g. An MTL formula
y is satisfiable iff there exists a model of ¢ and it is valid iff every timed state sequence
is a model of it. To transform an MTL formula into Negation Normal Form, one uses the
constrained dual until Uy operator [46], defined as (g Uy Ww) =-(-@ UU, 7).

An MTL formula ¢ is in Negation Normal Form (NNF) iff the negation operator (—) occurs
only in front of propositional variables. One of the differences between MTL and LTL is that
in LTL we have the equivalence —(O p) = O77, whereas in MTL 7-(O/p2,2)p) ¥ Op2,2)77p.-
If =(©/2,2]p) then either p does not occur in the next state or the next state does not occur
with time difference two. We can express this as follows:

7(O[2,21P) = Of2,2)7P V Ojo, true V O73, o0) true.
Moreover, the usual LTL equivalence for negated until, namely
“(@Up) = O-WV (-eW)U(-e AmW))
does not hold in MTL, i.e.
(Ur v) FAW V (ow) Ur (Fe A 7y))-

To see this, consider the formula —(p U/2,2) g). It is satisfied by a timed state sequence in
which p never holds, state 0 is mapped to time point O, state 1 is mapped to time point
1, and g only holds in state 2 which is mapped to time point 2. The formula is satisfied
because p does not hold at state 0 or 1. However this timed state sequence does not satisfy
O2,2)7¢ V ((-q) Up,2] (=p A 7q)) as the eventuality of the second disjunct does not hold
within the interval [2,2]. Note that in LTL the equivalence holds. In our example, if we

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1557

remove the intervals from the equivalence and interpret the timed state sequence as an LTL
model we would have the LTL formula O-g v ((—q) U(—p A 7q)) holding at state 0 as the
eventuality of the second disjunct holds at state 0 and 1. The intervals in MTL prevent this.

An MTL formula 9 is in Flat Normal Form (FNF) iff itis of the form po A /\; Oy0,00) (pi >
w;) where po, p; are propositional variables or true and y; is either a formula of propositional
logic or it is of the form O7W, Wy U7 We or Wy Uy wo where Ww, Ww are formulae of
propositional logic.

One can transform an MTL formula into FNF by renaming subformulae with nested
operators, as in [23,55]. For example, assume that we are given the following MTL formula:
O/2,3](7011,2}¢). We first transform our formula into NNF and obtain: O/2,3)(Of1,2; 7g). We
then transform it into FNF:

Po A Of0,00) (Po > O72,31P1) A Of0,c0) (P1 > OF1,217¢g).-

The transformations into NNF and FNEF are satisfiability preserving and can be performed in
polynomial time.

3 Examples

We consider a range of examples that can be represented using MTL relating to robotics,
traffic management, and job-shop scheduling.

First we consider a scenario relating to foraging robots based on a state transition system
with timing constraints relating how long robots can spend in each state searching for food,
moving home, etc. We first model a single robot using the strict semantics with timing
constraints on the next operators to indicate the change from one state to another. We discuss
the difficulties with this modelling approach for multiple robots and show how the scenario
can be re-modelled to represent multiple robots of the same type. Next we consider an example
related to traffic management, in particular, to traffic lights, again with the strict semantics.
This has two traffic lights that are not identical, modelled using until operators with timing
constraints that enforce the correct order and timings of the traffic light colours. The third
example formulates multiprocessor job-shop scheduling. We have multiple processors and
show how this can be modelled using both the strict and non-strict semantics.

3.1 Foraging Robots

This example is based on the models for foraging robot swarms [38]. Robots are located in
an arena with a “home” for them, they leave the home, carry out a random walk to locate
“food”. If food is detected they move towards the food, attempt to grab it and return home. If
food is not found or another robot grabs the detected food and the time for searching for food
is over the robot will move home without food. The food is deposited at home and increases
the overall energy of the swarm but searching for food decreases this energy. Here we focus
on the timing constraints rather than energy. Initially we consider one robot and later we
consider multiple robots. Robots can be in one of nine states:

resting resting at home;
leavingHome leaving home;
randomWalk moving around looking for food;
moveToFood moving towards food having located it;
scanArena looking for food;

Q) Springer
1558 U. Hustadt et al.

Le ine ne

Fig.1 State transition system for foraging robots

 
 

 
 

   

     

  

grabFood attempting to grab food that has been found;
moveToHome the robot moves home with food;
deposit the robot deposits the food at home, and
homing the robot moves home without food.

The state transition system representing their movement between states is shown in Fig. 1.

There are three parameters: the maximum time 7, that can be spent resting, the maximum
time 7, that can be spent searching for food (leavingHome, randomWalk, scanArena, and
moveToFood), and the maximum time 7, to get home with or without food (moveToHome
and homing). The latter is based on an assumption that there is a maximum distance between
the food and home. We assume that grabFood and leavingHome takes between two and three
time units and deposit takes three to four time units. Initially the robot is resting (resting).
Next we specify that the robot must be in exactly one of the states at any moment. Let

S = {resting, leavingHome, randomWalk, moveToFood, grabFood,

moveToHome, deposit, homing, scanArena}

We require that each time point is ‘marked’ with exactly one of the states.

O[0,00) (B=1S)
Next we define the state transition system representing the robot movement.

0,00) (resting > Oj1,rr\leavingHome)
D[0,00) leavingHome — ©/2,3)randomWalk)
D[0,00) (randomWalk — ©j1,00) (homing V moveToFood)
D[0,c0) (moveToFood — Oj{1,00)(grabFood V homing V scanArena)
D[0,00) (scanArena — ©Of1,00) (randomWalk V moveToFood V homing)
D[0,00) (grabFood — ©y2,3)moveToHome)
O[0,00) (moveToHome — O/1,7,\deposit)
D[0,00) (deposit — Oy3,4)resting)
D000) (homing > Oy1,7T,] resting)

The variable searching holds in all the states leavingHome, randomWalk, scanArena,
moveToFood and nowhere else.

D[0,00) (searching <> (leavingHomev randomWalkv scanArenaV moveToFood))

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1559

If the robot is searching then there is a maximum amount of time it can stay searching.
0,00) (searching — 11,7.) searching) (1)
There are a number of properties we could try to prove.
— Having left home the robot will eventually reach home again.
0,00) leavingHome — 10,00) resting)
— The maximum time the robot needs to return home is x
0,00) leavingHome — (0,x] resting)

In particular, the lowest value x for which we can prove this property is the maximum
time the robot can stay away from home.
— The minimum time the robot needs to return home is y.

0,00) leavingHome — Ojo, y—1;7resting)

Here the highest value y for which we can prove this property is the minimum time the
robot needs to return home.

Fora single robot, we believe that the most natural way to represent the foraging robot scenario
is as above, with most timing constraints on the next operator. However, to represent multiple
robots we would need a copy of each state and the formulae representing the transitions
for each robot, 1.e. propositions such as resting and grabFood would be parameterised by
robot number (for example resting; and grabFood, for robot i). In this type of scenario and
modelling, the next operator is working as a synchronisation point: all robots must move into
another state together. In general, this does not accurately reflect the intended behaviour of
robots as some robots may stay in the state they are currently in whilst others may change
state. A potential solution to this would be to include the current state of the robot on the
right hand side of the formulae under a next operator, as follows

O0.00) (resting; > On1,7,| (resting; V leavingHome; ))

so that the robots do not have to change state at the same time. However this introduces other
issues as the robot can now stay in the resting state for longer than 7; time units.

To model this correctly we would need to adopt an approach more like how we have dealt
with the timings for searching, i.e. formulae for each transition in the state transition system,
one denoting the possible next states and one denoting the required timing constraints to
move out of the current state [like Eq. (1)]. We also need to introduce a new propositional
variable for each robot, for each state, to denote the place where the proposition for that
state changes from being false to becoming true. We need this so we can identify when we
first entered some state so we can formalise the maximum time we can stay in this state.
To illustrate this approach, we focus on the state resting; in the following. Here, we denote
the new propositional variable that indicates a state change by startResting; and impose the
following constraint on it.

(resting, <> startResting;) (2)
D[0,00) ((Of1,co) StartResting;) <> (resting; \ Of1,co) resting; ))

Next, for robot 7, to represent the transition out of the state resting; we would have the
following formulae, the first denoting the next possible states of robot i and the second
enforcing the maximum time that robot 7 can be in the resting state.

Q) Springer
1560 U. Hustadt et al.

Dj0,00) (resting; > Oft,oo) (resting; V leavingHome,; ))
0,00) (startResting; > O1,7,)71resting;)

An alternative to the above two formulae would be using an until operator as follows
O0,co) (startResting; — (resting; Uj ,7,) leavingHome; ))

Although we have introduced the proposition startResting, to ensure the relevant timed
formulae only hold from where resting, first became true it is only essential here when the
left hand side of the timing constraint is greater than one. Consider the following timed state
sequence as an example. Let o = (o, T) be the timed state sequence where t(0) = 0, tT(1) =
3, T(2) = 4, and t(3) = 10 where (p, 0) & resting;, (0, 1) & resting;, (0,2) — resting;
and (p, 3) F —resting;. We consider using

0,00) (resting; — Q)3,5)7resting; ) (3)
rather than
0,00) (startResting; > 13,5)7resting; ) (4)

In p, resting; changes from true to false within 3—5 time units from where resting; was first
true, as T(2) — tT(O) € [3, 5]. So

(0,0) F 03,5) 77resting;

and therefore
(0,0) - (resting; > Q(3,5)7resting;)

However
(p, 1) F Oj3,sy7resting;
as T(2) — tT(1) ¢ [3, 5] and as t(3) — t(1) € [3, 5] so
(op, 1) K (resting; > 13,5|)7 resting; )

so (3) does not hold. But if we introduce startResting; as defined in (2) then (9,0) —
startResting;,(p, 1) F —startResting;,(p, 2) - —startResting; and (p, 3) - —startResting,,
and Eq. (4) holds as desired.

We discuss something similar in the next example in Sect. 3.2 relating to traffic lights
about the proposition change;. Another solution to having multiple robots may be adopting
the non-strict semantics in a similar way to what is presented for the multiprocessor job-shop
scheduling problem in Sect. 3.3.

The timing aspects of other examples relating to robots could also be modelled. For
example a personal robot assistant located in a house equipped with sensors that inform the
robot about the state of the house and its participants is considered in [18,19,57]. The robot
actions are controlled by a set of behaviours. These are of the form of “if ...then ...” where
the “if” part depends on state of the robot, sensor data and internal variables and the “then”
part contains a sequence of robot actions. These contain several timing aspects for example

99 66

“wait ten seconds’, “wait an hour” etc that we could model using this logic.

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1561

3.2 Traffic Lights

Consider a pair of traffic lights at a junction with two roads, R1 and R2, crossing each other.
Traffic light one is for road R1 and traffic light two 1s for road R2. As road R1 is busier, there
is acamera to detect when there are cars waiting for traffic light 1. This makes the lights have
different behaviour so the problem is not symmetric.

We use the following propositional variables to denote the states that the traffic lights and
the detection sensor can be in:

=

; traffic light 7 is at red;

a’ traffic light 7 is at amber following being at red;

a; traffic light 7 is at amber following being at green;
a;_ traffic light 7 is at amber (i.e. one of the above holds);
g; traffic light 7 is at green;

detect traffic light one detects cars waiting;

change; traffic light i has just changed colour;

OQ™ue SN

Traffic light i € {1, 2} 1s exactly red, amber or green at every moment in time.

Traffic light i € {1, 2} is at amber if and only if either it is at amber after red or amber after
green (at every moment in time). Note that while our modelling here does not explicitly allow
the red and amber lights to both be on together, as is common in traffic light sequences in
Europe, our use of two different propositional variables for amber after red and amber after
green allows us to differentiate between these situations.

Dl0,00) (ai <> (aj V a’)

Traffic light i € {1,2} cannot be both amber after red and amber after green at the same
moment in time.

Xl0,00) (7a? V 7a")
If one traffic light is green the other is not green.

O[0,00) (781 V 782)

The sequence of the traffic lights is red, then amber, then green, then amber, then red, and so
on. Both traffic lights eventually change to amber after having been at green, stay at amber
after green between one and two time units before changing to red, and stay at amber after
red between one and three time units before changing to green.

The formalisation of these constraints requires some careful consideration. For instance,
one might consider the formula O}0,00) (a7 U2,3] 11) as a possible way of expressing that
red follows amber after green within two or three time units. However, together with the
constraints above, it is unsatisfiable: suppose there is a timed state sequence p = (o, T) that
satisfies our constraints. For any i € N, (a; U42,3] 1) 1S true at (p,7) and there exists k > i
with t(k) — t(i) © [2,3] and 7, is true at (9, k). But since (a; Uj2,3) 71) is always true,
it is also true at (p, k) and since O ¢ [2, 3], a; must be true at (0, k). This contradicts the
constraint that a; and r; cannot both be true at any state. In the following we make use of the
proposition change; together with a particular colour as a guard making sure that the timing
constraints hold when a light changes to that colour.

Q) Springer
1562 U. Hustadt et al.

The variable change; holds in the first moment in time and also if the traffic light was not
red, (respectively amber, green) in the previous moment and is now red (respectively amber,
green).

change;
A Of0,00) (Of1,co)change;) <> (Fr; A Oft,coyFi) V (Fai A Of1,c0) ai)
V (8; A Of1,co) 8i)))
Strictly, for a formula such as O)0,00)(21 Uf0,00) a; ), expressing that traffic light 1 stays
green until it eventually changes to amber after green, where the lower bound on the interval

restricting the until operator is 0, we do not need a guard, but add one anyway in order to
obtain the following more uniform formalisation.

Dy0,00) (change; A gi) > (gi Uf0,00) a; ))
Xj0,00) (change; A a?) > (a? Up2,3) ri)
D[0,00) (change; \ aj) > (a; Uf1,2) gi))

Regarding the change from red to amber, the two traffic lights behave differently. The fol-
lowing two formulae state that traffic light 1 will eventually change to amber after having
been red, while traffic light 2 will do so after 0 to 4 time units.

Cf0,c0) (change; Ar1) > (11 Ufo,co) 4)
Cf0,00) ((change2 Ar2) > (r2 Ujo,4] 44))

Finally, if the car detection sensor on road R1 detects a car and the traffic light is not green
then it will be green within 3 time units.

C[0,00) (detect A 81) > j0,3181) (5)
Properties we would like to check are as follows.
— Infinitely often each traffic light will be green.
O[0,00) 0 (0,00) 81 \ Of0,00) 00,00) 82 (6)
— If acar is detected on road R1 then the wait will be at most x time units.
C[0,00) (detect > O[0,x181) (7)

It is worthwhile to note that the property O)0,00) (detect > 11,x’]g1) is not provable for
any value of x’. In a countermodel, g; always holds at exactly the same states as detect,
1.e. it is true in states where detect is true and false in states where detect is false. This
satisfies the constraint (5) trivially. Also (6) is still satisfied due to the until constraints
forcing the correct light sequence thereby falsifying Qy1,."]81-

— If traffic light 2 is currently red then it will be green within | to y time units.

Dy0,00) (r2 > Of1,y]82) (8)

Here the property 00,00) (r2 > [0,y]82) would hold for exactly the same values of y
as property (8). This follows from the constraint that the traffic lights cannot be red and
green at the same time.

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1563

— If a traffic light is currently amber or red, then a car has to wait at most z time units until
the traffic light will be green. We could try to formalise this property as

Oy0,00) (a1 V 11) > O70,2181) A Of0,00) ((a2 V 72) > 00,282) (9)

However, the first conjunct of (9) does not follow from our specification as there is no
upper bound on the time that traffic light 1 can stay red if no car is detected.

In order to correctly formalise the property we have to include that the presence of a car
makes detect true:

D0,00) (((ay V r1) A detect) > 10,2181) A Of0,00) (a2 V 72) > Of0,2182) (10)

3.3 Multiprocessor Job-Shop Scheduling

Our next example is a generalisation of the classical job-shop scheduling problem, called the
Multiprocessor Job-shop Scheduling (MJS) problem [16,27]. The representation provided is
based on that in [17]. Here a set of jobs have to be processed on a set of machines running
in parallel. Each job requires a number of processor steps to complete (this number may
also depend on the machine, i.e., job 7 may run faster in machine / than in machine /). The
question is whether there is a schedule such that after ¢ time units all jobs will have been
processed by the machines.

We use this example to illustrate encodings with both the strict and non-strict semantics.
Under the strict semantics we use propositional variables run j,m, to encode that job jj is
running on machine m ;, whereas in the non-strict semantics we use separate propositional
variables m; for machines and run ;, for (the execution of) jobs. So, the strict semantics uses
quadratically more propositional variables than the non-strict semantics. This is due to the
fact that in the non-strict semantics we can encode parallelism by associating multiple states
with the same time point. Our encodings have the property that there is a schedule if and
only if there is a model for the resulting MTL formulae. One can use any model of the MTL
formulae to create a schedule satisfying the constraints of an instance of the problem.

We first show how one can encode the problem in MTL with the strict semantics and then
we show the encoding with the non-strict semantics.

Strict Semantics
Assume we have n jobs j1, j2,..., Jn and k machines m1, m2, ..., mx. Let

— startRunj;,, run;, and hasRunj, denote the start, the execution and the end of the
execution of job j; on some machine, respectively;

— start Runj,m, and runj,m, denote the start and the execution of job j; on machine mz),
respectively; and

— tj;m, to denote the time taken to run job j; on machine m).

The following formulae state that (11) once a job starts running it must start running on

one of the machines and that (12) once a job starts running on a machine it must run on that
machine (where /\,—;—,, and /\;—;<, ;<;<,; in front of the formulas is omitted for brevity)
O0,00) (start Run ;, > Vit start Run j,m,) (11)
O[0,00) (start Run jm, —> Tun j;m,) (12)
The parametric formula (13) states that: if a job is running on one machine then it cannot
be running on another (integrity of jobs); and another job cannot be running on the same

machine (integrity of machines). By parametric formula (14), once a job has started it cannot
be started again.

Q) Springer
1564 U. Hustadt et al.

20,00) UM jim > (Npat.pet PHM mp \Ngat.ggi TUM ig) (13)

Dj0,00) (start Run j, > Of0,c0)O}0,00) Start Run j,) (14)
We write —runj, as a short hand for Nix Ir UN j;m,. We can use (15) to denote that once
job jj is started to run on machine my it takes time f;,m, and (16) to denote that once job jj
has finished running on machine m, it will not run again. Further, parametric formula (17)
denotes that job j; cannot be run until it has started.

D0,00) (Start Run jm; > Ol0,t)m,—UN jim, \ thas Run j;) (15)
D0,00) (start Run jm, > Ot}, my 00) (TUN j, A has Runj,)) (16)
Oj0,00) (run ;, U start Run ;;) (17)

We assume that initially no jobs have run, i.e., /\j_, shas Run j,; and that (18) if a job has
not run and is currently not running then it will not have run in the next moment.

D[0,00) (thas Run ;, A srunj;,) + Of0,00) thas Run j;) (18)
We can now check whether we can achieve a schedule after at most ¢ time points by adding
10,11 /\j_1 has Runj;,. We can also specify constraints on jobs such as

— D0,c0) (run j, <> runj, m,): job j; must run on machine m7;

— Dj0,00)(startRun;, > Of{1,00)StartRunj,,): job j; must start before job jm (note that
this formalisation relies on the fact that each job is started exactly once);

— Ofc,a)start Run ;,: job j; must start at a point within the interval [c, d].

Non-Strict Semantics
We again assume we have n jobs jj, j2,..., Jn and k machines m1, m2,..., mg. Let

— startRunj;, and has Runj, denote the start and the end of job j; on some machine,
respectively;

— runj, denote that job j; is running on some machine; and

— tj;m, denote the time taken to run job j; on machine m;.

In each state exactly one of the variables of the form my, is true. Also, in each state
at most one job is running, but now we may have multiple states at the same time. Let

TIm = {m,,...,mg} and IT; = {runj,,...,run;,}. The following states the constraints
mentioned above (the meaning of ®=; and @<, is as described in Sect. 2):
O0,00) (@=1lIm A B<117;) (19)

Parametric formula (20) specifies that if a job is running on one machine then it cannot be
running on another. Parametric formula (21) states that once a job is started it cannot be
started again (where /\;—;—,, ;<;<; and /\,~;—, is again omitted).

D0,00) ((my A run ;,) > Ave O0,00) 7(my A run ;;)) (20)
D[0,00) (start Run j,; — Of0,00) O[0,00) 7Start Run j; ) (21)

We use the following
O0,00) (start Run j, \ mj) > (O[0,¢;,m —11 (has Run j, A (mj — runj;;)) (22)

A Q[0,tj:m,12as Run j;))
to denote that once job j; started to run on machine mz, it takes time ¢j,m, and (23) to
denote that once job j; has finished running on machine m, it will not run again. Further,
we use O)0,00)(7run ;, U start Run j,) to state a job j; cannot be run until it is started and
O[0,00) (thas Run ;, Ustart Run j,) to state that a job cannot have run before it starts (another
rule above will make sure that has Run ;, will hold after the run has finished).
O[0,00) ((start Run ;, \ mj) > Ot jm) + 1,00) (TT UN j /\ has Runj;)) (23)

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1565

Fig.2 Example illustrating Definition 1

We assume that initially no jobs have run, i.e., /\j_, thas Runj,. We can now check
whether we can achieve a schedule after at most ¢ time points by adding 0,1] /\j_, has Run j,
and checking for satisfiability.

4 From MTL to LTL: Encoding ‘Gaps’

Next we provide satisfiability preserving translations from MTL formulae for discrete time
models into LTL using a new propositional variable gap, which is intended to hold at LTL
states corresponding to unmapped time points in MTL models. Assume that our MTL formu-
lae are in NNF and ENF. The main idea for our translation is to map each timed state sequence
p = (o,T) into astate sequence o’ such that p = (ac, T) isa model of an MTL formula if, and
only if, o’ is a model of our LTL translation. We first present our translation using the strict
semantics and then show how to adapt it for the non-strict semantics, where multiple states
are allowed to be mapped to the same time point. Our LTL translations are exponential in the
size of the input formula in MTL due to the binary encoding of the numbers in the intervals.
This blow up is unavoidable and optimal, since reasoning in MTL is ExpSpace-hard and an
exponential size LTL translation gives an ExpSpace upper bound.

Strict Semantics
For every model of a MTL formula there is going to be a model of the translated formula,
such that -gap is true in those states oj of o’ such that there isi € N with t(i) = j and gap

is true in all other states of o’. We now define our mappings between MTL and LTL models.

Definition 1 Given a timed state sequence 9 = (0,T), we define a state sequence 0’ =
040; ..-» where oj is as follows:

, | Oj if there is i € N such that t(i) = /;

J ~~ | {gap} otherwise.

Figure 2 illustrates the mapping given by Definition |. For instance, if p = (0, T) is the
timed state sequence on the left side of Fig. 2a then (p, 0) — Oj2,3)p. Table 1 presents the
translation of formulae of the form O;a, a; U; B ora U 1 B, where a, 6 are propositional
formulae. Assume (v)* = ¢ if g is a propositional formula. Observe that, in the definition of
-£ recursion is only used to deal with the case where 0 occurs on the left side of an interval.
As shown in Table 1, we translate ©;2,3]p into:

VV O'Csap a pyr /\ Ofgap).
2</<3 1<k<l

Note that the state sequence represented on the right side of Fig. 2 is a model of the
translation. Since gap is a propositional variable not occurring in o, the time points mapped
by the image of t do not contain gap.

Definition 2 Given a state sequence o’ such that (o’,0) FE —gap A O(O7 gap), we induc-
tively define o = (09, T(O))(o1, TU1))..., where (09, T(O)) = (06, 0) and, fori, j,k EN
andi > 0, (0;, T(i)) is as follows:

Q) Springer
1566 U. Hustadt et al.

Table 1 Strict gap translation from MTL to LTL, where a, 6 are propositional formulae and c1, cz > 0

 

MTL Strict gap translation

(Of0,00) 0)" (Oft.coy@)*

(Ofey,00) ¢)* (A\t<kec, OX gap) AO"! (gap U (a A >gap))
(Ofeq er ]1@)" Vey <I<e9 (0! (Pgap Aa) A \j<kel Of gap)
(Oyo,0]@)" false

(Ofo,ey]@)* (Oft,es]@)"

(a Uf0,00) B)* (sgap A B) V (@ Uf ,00) B®

(a Ute, 00) BY (Ao<k<c, OX (gap V @)) A 0%! ((gap V a) U (>gap A B))
(a Ufey,c9] BY? Vey<l<cy(O! gap A B) A No<pei Of (gap V @))
(a Ufo,0) B)* agap \ B

(a Upo,cy B)* (agap A B) V (& Up ,c9} BY

(aU, B)* a(3(a) Uy =(B))*

oj = oF andt(i)=j if j >t(i—1), gap ¢ oj and for all k,
ti —1)<k <j, gap €o.

As o’ is such that (o’,0) KE a=gap A O(O7 gap), for each i € N we have t(i) € N. Also,
fori > 0,t(@) > tii — 1) and, so, t : N > N is well defined.

The following two propositions are useful for the proof of Theorem |. Since gap is a
propositional variable not occurring in o, the time points mapped by the image of t do not
contain gap. Then, it is easy to see the following.

Proposition 1 Given a timed state sequence p = (o,T), let o’ be as in Definition 1. Then,
(o', 0) F O(>gap).

The state sequence o’ in Definition 2 is such that (o’, 0) E —gap A O(Q-gap). Conse-
quently, for the timed state sequence constructed in Definition 2 we have that for eachi € N,
t(i) € N. Also, fori > 0, ti) > t(Wi — 1) and, so, tT : N > N 1s well defined. The following
proposition states this property.

Proposition 2 Given a state sequence o' such that (o’,0) K agap A O(On7¢gap), let p =
(ao, T) be as in Definition 2. Then, t : N > N is a function such that ti + 1) > t(i), forall
LEN.

We are ready for Theorem 1, which states the correctness of our translation from MTL to
LTL using “gap’s. One can use similar arguments to show Theorem 2.

Theorem 1 Let y = po A /\; Oj0,cc) (pi > Wi) be an MTL formula in NNF and FNF. Let
g* = por /\\; Dwi > (-gap A w)) be the result of replacing each wy; in p by We as in
Table 1. Then, ¢ is satisfiable if, and only if, gp A ~gap \ O(O- gap) is satisfiable.

Proof ¢ is satisfiable if, and only if, there is a timed state sequence 9 = (0, T) such that
(p, 0) & @. Given a timed state sequence p = (0, T), leto’ = ojo; ... be as in Definition 1.

By Definition 1 we have that (o’, t(0)) K —gap and, by Proposition 1, (o’, t(0)) —
O(O-gap). By definition of o’, for all propositional variables p; occurring in o and all
j €N, we have (p, j) —& p; if, and only if, (o’, t(j)) E p;. With an inductive argument,

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1567

one can show that, for any propositional formula @ not containing gap, (p, j) F a@ if, and
only if, (o’, T(j)) Fa.

Also, ¢* Aagap AU(O-gap) is satisfiable if, and only if, there is a state sequence o’ such
that (o’, 0) E gy? A agap A O(O- gap). Given o’, let p = (0, T) be as in Definition 2. By
Proposition 2, tT : N > N is well defined. By definition of o, for all propositional variables
p; occurring in o/ with gap ¢ o, there is j € N such that t(j) = n and (p, j) — p; iff
(o’, T(j)) —& p;. An inductive argument lifts this claim to propositional formulae.

Thus, following Table 1, we only need to show correspondences between wW; and —gap /A
we This follows from Claims 1—3 below (other cases are similar), where 9 = (0,T) isa
timed state sequence and j € N. Let C — | be the greatest number occurring in an interval
in g or 1, if none occur. We argue that, for all natural numbers c; with 0 < c, < c2 < C, the
following claims hold.

Claim 1 (p, j/) E Ofe,c@ iff (6, TU) EK agap A (Ofe},c9]0)*.

Proof (p, j) F Ofe,,c.j@ iff (0, 7 +1) Ha andt(j+1) € t(j) +[c1, c2]. By Definitions |
and 2, this happens iff (o’, t(j ++1)) KE —=gapAqa and thereisnon € Nsuchthatt(n) = m, for
t(j) <m < t(j+1), meaning that for all suchm, (o’,m) - gap. Ast(j)+c; < tUj+l) <
t(j) +2, this happens iff (o’, T(j)) & Vo <l<cy (Ol (Aap Aaya \y<pel o* gap), and
(o’, T(j)) — -gap, by definition of 0’. So, (9, J) E Ofe),cj@ iff (o', TV) KE agap A
(Ofey.c9]0)?.

Claim2 (0, 7) Fo Ufey,c) B iff (0, TU) FE agap A (@ Ufey,cr) B)*.

Proof (p, j) F alte, cy] B iff there is k € N such that t(k) € t(j) +[c1, c2] and (p,k) — B
and for all/ € N with 7 < / < k we have (p,/) — a. By Definitions 1 and 2, this
happens iff (i) (o’, tT(k)) FE —gap A B, (ii) as T(7) +1 < TKK) S T(J) +2, (0, TU) EF
V er <m<e,(O” (agap “ B)), and (iii), for all 7 <¢ N with j </ < k we have (o’,t(1)) Ea.
Ifn € Nis such that t(j) <n < t(k) and there is nol € N withn = T(/) then, by definition
of 0’, (o’,n) - gap.

Thus, by (i-it1), (0, J) Fa Ue, 5] B iff

(0', tA) FE Ve, <1<e)(O' gap A B) A Noes O* (Bap V &)).

Claim3 (9, j) Ea lU{e,.cy B iff (o', TU)) K gap A 7(A(@) Ute; c9] 7(B))*.

Proof By the semantics of U/, we have that (p, j) E a Utes .05] B iff (0, J) FE AA(@) ey ,65]
=(B)). By Claim 2, (p, j) K 7(@) Ue; cr] 7B) iff (6, tT) KF mgap A (Aa) Ufey,c9]
=(B))*. Since (o’, t(j)) EK —gap (by definition of o’), this happens iff (o’, t(j)) E agapA
a(7(@) Utes e9] 7(B))*. Oo

Example Assume that we are given the following MTL formula in NNF and FNF: g =
PO A O}0,00) (Po > O7/2,31P1)A Oj0,cc)(P1 > Of1,2179g). Using Table 1, we translate g into
LTL as follows (recall that 0; = true U/; w):
go = po AU(po > (agap A (Vo<123(0l (Agap A pi) A \yepeq OK gap)
AO(p1 > (-gap A (Vy e22(0! (agap A 7q)))).

Non-Strict Semantics

We now show how we modify the Gap translation for non-strict timed state sequences. We
introduce a fresh propositional variable called ‘same’. same is true exactly in those states o i
of o’ such that there is i €¢ N with t(i) = j and, fori > 0, t(j) = t(i — 1). Note that same
and gap cannot both be true in any state. We say that a state s is a gap state if gap € s. We
now define our mappings between MTL and LTL models.

Q) Springer
1568 U. Hustadt et al.

Fig.3 Example illustrating Definition 3

Definition 3 Let o = (o, tT) be a non-strict timed state sequence.
We define o’ = ogo; ... by initially setting o’ = o and then modifying o’ with the two
following steps:

1. Fori > 0, if t@) — t@ — 1) = O then set of := 0; U {same};

2. Fori, j > 0, if oF is the i-th non-gap state in o’, Oiay is anon-gap state and t(i + 1) —
t(i) =k > 1 then add k — 1 states of the form {gap} between oj and Oisy
Figure 3 illustrates the mapping given by Definition 3. For instance, if p = (0, T) is the

non-strict timed state sequence on the left side then (9, 0) — )2,2)g. Table 2 presents our

translation of formulae of the form O;a, a; U7 B or a Uy B, as in Table 1. As shown in

Table 2, we translate }/2,2)g into:

same U (-same A O(same U (msame A O((g A mgap) V O(same U (q A same)))))).

The main distinction from the translation presented in Table | is that here we use nested until

operators to make progress in our encoding of the time line whenever we find a state with

—same. Note that the state sequence represented on the right side of Fig. 3 is a model of the

translation (recall that Qj2,2)¢ = (true U/2,2) ¢)).

Definition 4 Let o’ be a state sequence such that (o’, 0) EK ~gap A =same A O(QO- gap) A
O(-same V sgap) \ O(gap > O-same).
We first define t : N > N by setting t(0) = O and, fori > O, T(z) is as follows:
r(i) = t(i—1) if oF is the i+1-th non-gap state and same € oj
T(i—1)+k-+1 otherwise,
where k > 0 is the number of gap states between the i-th and i + 1-th non-gap states. We
now define o as follows:
oj = a; \ {same}, where oj is the i + 1-th non-gap state.

We are ready for Theorem 2, which states the correctness of our translation from MTL to
LTL using the variables ‘gap’ and ‘same’.

Theorem 2 Let y = po A /\; Oj0,c0c) (Pi > Wi) be an MTL formula in NNF and FNF. Let
gy? = pon /\\; Dwi > (-gap A w)) be the result of replacing each wy; in p by We as in
Table 2. Then, ¢ is satisfiable if, and only if, p" Aagap Asame AO(O>gap) AO(-samev
sgap) \ O(gap > O-same) is satisfiable.

Proof (Sketch) We use Definitions 3 and 4 to map models of g into models of gy? A —gap A
XO(Q-gap) and vice versa. The correctness of our translation is again given by a structural
inductive argument. As mentioned, the main difference w.r.t. to Theorem | is that here we
use the propositional variable same to encode multiple states mapped to the same time point.

O

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1569

Table2 Non-strict gap translation from MTL to LTL, using gap and same, where a, f are propositional logic
formulae, cj, cz > 0 and (Ofey,c0) %)* and (Ofey en] 0)" are as in Table |

MTL Non-strict gap translation

(Of0,00) 0)" (Qr0,0}@)* Vv (Oft,coy@)*

(Ofo,ey]@)* (Oy0,0}@)* V (Oft,es]@)"

(Ojo,0)@)* O(@ A same)

(a@ Ufc; 00) Bp) a \ O(a A same) U (>same A (a Ufc; 1,00) B)*))
(a Ujo,00) B)* (gap V a) U (gap A B)

(0 Ufc ey} B)* a A O((a A same) U (same A (a Ute; ~1,c9—1] B)*))
(a Upo,o) B)* (B A mgap) V (a A O(a A same) U(B A same)))

(a Ujo,cy} B)* (a Ujo,o} B)* V (@ Ufi.e9| BY

(aw Uy B)* a(>(a) U; 7(B))*

5 From MTL to LTL: Encoding Time Differences

Next we provide satisfiability preserving translations from MTL formulae for discrete time
models into LTL using new propositional variables to denote the time differences from the
previous state. Assume that our MTL formulae are in NNF and FNF. Similar to the previous
section our proof strategy relies on mapping each timed state sequence p = (a, T) to a state
sequence o’ such that p = (o, T) isa model of an MTL formula if, and only if, 0’ is a model of
our LTL translation. We first show a translation under the strict semantics and then we show
how to adapt it for the non-strict semantics. Our LTL translations here are also exponential
in the size of the input formula in MTL due to the binary encoding of the numbers in the
intervals, and thus, yield tight ExpSpace upper bounds.

Strict Semantics

We denote by C — | the greatest number occurring in an interval in an MTL formula @ or
1, if none occur. We say that a timed state sequence p = (0, T) 1s C-bounded, for a constant
C EN, if t(O) < C and, for alli e N, ri + 1) — t(i) < C. To map a timed state sequence
p = (o,T) toa state sequence o’ we employ the following result adapted from [7].

Theorem 3 Let g be an MTL formula. If there is a timed state sequence p = (0, T) such that
(0,0) E @ then there is a C-bounded timed state sequence pc such that (pc, 0) — @.

Definition 5 Given a timed sequence p = (o,T) and C € N, we define a timed sequence
Pc = (Oc, Tc) as follows:
— 0c =90;
— tc (0) = min(t (0), C) and, fori > 0, we have that tc(i) = tc(i — 1) + min(C, t(i) —
t(i — 1)).

The following proposition states the main property of Definition 5.

Proposition 3 Let 9 = (0,T) be a timed state sequence and let pce = (Oc, Tc) be as in
Definition 5. For alli, j € N and all intervals of the form I = [c,, c2] or I = [c1, ©) with
C1, €2 < C, the following holds:

TJ) ETO +1 8 Ic) € tc +/1

Q) Springer
1570 U. Hustadt et al.

Proof First assume J = [c1, co]. If t(j) € tT) + [c], co] then t(j) — Ti) < C2 < C
and, so, Tc(j) — Tc(i) = T(J) — TC). Thus, tc(J) € Tc) + [c1, C2]. Conversely, if
tTc(j) € Toi) +[c1, c2] then tc(j) —tTc(i) < c2 < Cand, so, tc(j) —tTc(i) = T(J) - TW).
Thus, t(j) € tT(i) + [cq, c2].

Now assume J = [cj, 00). If t(j) € TW) + [Cc], o©) then t(j) — TH) = cy. If TY) —
T(i) < C then Tc(j) — tc(i) = T(J) — TZ) and, so, tTc(J) € Tc(i) + [c1, ©). Otherwise
T(j)—t(i) => C. Then, tc(j)—Tc (i) = C. ASC > cy, wehave that t(j) € tc(i)+[c1, &).
Conversely, if t(j) € tTc(i) + [c1, ©) then tc(j) — tTc(i) = c1. If tTe(J) — tc (i) < C then
Tc(j) —Tc(i) = T(J) — TA) and, so, T(J) € TH) + [c1, CO). Otherwise tTc(j) — Tei) = C.
Then, t(j) — tT(i) > C. As C > cj, we have that t(j) € TW) + [c], ©). oO

We are now ready for Theorem 3.

Proof Let p = (o, T) be a timed state sequence and let pc = (0c, Tc) be as in Definition 5.
By definition of oc we have that pc is C-bounded.

Assume w.l.o.g. that g is in NNF. Let sub(@) be the set of all subformulae of gy. To prove
this lemma, we argue by structural induction and show that for all g’ € sub(g), if (0,1) Eg’
then (0c,i) EF g’,i EN.

In the base case, g’ is a propositional formula. Then, as oc = o, we have that (9,7) EK gy’
implies (pc, i) K g’,i € N. Suppose that, for x, yy € sub(y) andi € N, (p,i) — x implies
(0c, 1) —& x, and, (0,7) FE Ww implies (9c,1) FE w. We explain for O7, U7 and Uy (other
cases are similar):

— g’ is of the form 0; x: if (0,1) EK O;x thentG +1) € ti) + J and(p,i+1) Ey.
By the induction hypothesis, (0c,i +1) E w. By Proposition 3, tc(i +1) € Tei) + I.
Then, (0c,1) F O7xX.

— qg’ is of the form (x U W): if (0,1) E (xy U7 W) then there is k € N such that k > i,
t(k) € tii) +7 and (9, k) — w and forall 7 e N,ifi < 7 < k then (p, j) E x. By the
induction hypothesis, (oc, k) F wand (pc, Jj) F x, forall 7 ¢ N withi < j <k. By
Proposition 3, tc(k) € tc(i) + I. Then, (0c,1) FE (x U7 Ww).

— g’ is of the form (x U; W): if (p, i) E (x Uy W) then either:

1. forall 7 e N, if ty) € ti) +- J then (p, 7) E W; or

2. (ifc; > 0)(9,k) E x for some k € N such that t(k) € t(z) + [0, cy — 1], where c
is the left end-point of /; or

3. (p,1) —& x for some / € N such that t(/) € t(i) + J and for all /’ € N such that
T(i) + cy < t(l') < tT(1), we have (p,l') Ew.

We make a case distinction. In Case (1), we have to establish that, for all 7 € N, if
Tc(j) € tTc(i) + J then (oc, Jj) —& Ww. By Proposition 3, if tc(j) € tTc(i) + J then
T(j) € tT(i) + J and by induction hypothesis, (oc, 7) EF wW, for all 7 € N with t(j) €
t(i) + I. Therefore, (0c, 71) E (x Uy w). Cases (2) and (3) can be proved with similar
arguments. O

By Theorem 3, w.l.o.g., we can consider only timed state sequences where the time
difference from a state to its previous state is bounded by C. Then, we can encode time
differences using propositional variables of the form s’, with the meaning that ‘the sum of
the time differences from the last n states to the current state is m’. For our translation, we
only need to define these variables up to sums bounded by 2 - C. We can now define our
mapping from an MTL model to an LTL model.!

! We write min(l +k,2-C) for the minimum between / + k and 2 - C. If the minimum is 2 - C then sft
means that the sum of the last 7 + 1 variables is greater or equal to2-C.

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1571

Definition 6 Given a C-bounded timed state sequence p = (0, T), we define o’ = Oo; Lee
by setting oj = oo and, fori > 0:
of =o; U{s, | ti) —tG — 1) =k} U

i+] ; ;
(Syindek2.c) |T@) — TG — 1) =kand s/ € of_)}
where 1 < j < C, 1 <1] <2-Cand1<k < C (assume variables of the form s?, do not
occur ing).

In Definition 6, if, for example, t(2) —t(0) = 4 then (o’, 2) & Sq. Intuitively, the variable
sy allow us to group together all the cases where the sum of the time differences from the last
2 states to the current state is 4. This happens when: t(2) — t(1) = 3 and t(1) — t(O) = 1;
or T(2) — tT(1) = 1 and t(1) — t(O) = 3; or T(2) — TC) = 2 and t(1) — tT(O) = 2. By
definition of 0’, Lemma | is immediate (see definition of <; and @s, in the Preliminaries).

Lemma1 Let Sc be the conjunction of the following:

1. 00 @=1 I7!, for IT! = {sf | 1 <k < C};
2. O@<1 MM’, for | <i < Cand I7' ={s' |i <j <2-C};

1 J jt+l 1 J J+l i
3. O((Os, A Sp) > OSmingek.2-c))» FOP {Sk 87+ Sind ek.2-.c)} F Ur<iec MM:

Given a C-bounded timed state sequence p = (0, T), leto' = o90; ... be as in Definition 6.
Then, (o',0) & Sc.

There is exactly one value k, 1 < k < C, that is going to be equal to the sum of the time
difference of the last state to the current. This is encoded by s (Point 1). Point 2 ensures
that at all times we cannot have more than one value for the sum of the time differences of
the last i states. Finally, Point 3 has the propagation of sum variables: if the sum of the last
j States is / and the time difference to the next is & then the next state should have that the
sum of the last 7 + 1 states is/ +k.

Remark 1 To simplify the presentation, in this section we used variables of the form s/),, where
n ranges from | to C — 1 andm ranges from 1 (or from 0 for the non-strict semantics) to 2-C
(in fact 2-C — 1 would be enough for the translation). As mentioned in Sect. 1, the exponential
blow-up of the translations cannot be avoided. Though, we can have a slightly more succinct
translation by encoding m in binary. So in our experiments, we encode variables of the form
swith n - log m variables, where for each n we represent m in binary. For example, sy 1S
encoded with 85 A as? A a56.

We now define our mapping from an LTL model of Sc to an MTL model (for this mapping,
we actually only need Point 1).

Definition 7 Given a state sequence o’ = ojo; ... such that (o’,0) — Sc, we define a
C-bounded timed state sequence p = (a, T) by setting 0; = o/ \ (U, <j<c /1’), fori € N,
and:

ri) = 0 ifi =0
ti-l+k ifi>0,(',i) Es}

Note that p, in particular, t, in Definition 7 is well-defined because for every i € N there
is exactly one k such that (o’,7) — St: Table 3 presents our translation of formulae of the
form O7a, a; U; B ora Uy B, as in Tables 1 and 2. As shown in Table 3, we translate, for
example, ©/2,3}p into O((s5 V s}) A p). The following two propositions are useful for the
proof of Theorem 4.

Q) Springer
1572 U. Hustadt et al.

Table 3 Strict time difference translation from MTL to LTL where a, £ are propositional logic formulae and

c1,¢2 > 0

MTL Strict time difference translation

(Ofey,00) &)* O(Ve, <i<c s}) A a)

(Ol0,00)«)* Oa

(fey ,e9])* OV) <i<ey 8) A@)

(Ofo,e910)* (Oft,es1@)*

(Oy0,01@)" false

(a Ufey,00) B)* Vi<i<e,(O' (Vey <j<cy4c 84) \(@UB)) A (Nock <i O*@))
(aw U0,00) B)* (wUB)

(a Ufc, ,c9] B)* Vi<i<e)(O' (Vey <j<co 84) AB) A Nock<i O*@))
(a Ujo,c9} BY BV (aUfics] BY

(a Uo,0) B)* B

(aU; B)* a(>(a) Uy =(B))*

Proposition 4 Given a C-bounded timed state sequence p = (0,7), let o’ be as in Def-
inition 6. For alli < j € N, ift(¥j) —t@) =m < 2-Candj —i =n < C then
(0, j) Est.

Proof In the base case j = i + 1, that is, n = 1. As p is C-bounded, t(@i + 1) — ti) = k,
for 1 < k < C. Then, by Definition 6, (o’, j) — sh. Suppose that, for 7 = i +n, if
tT(i +n)—Tt(i) =/ then (o’,itn)& s; where / < 2- C. In the induction step we consider
j =i+tn-+1.Letk’ be such that ti +n+1)—tGit+tn) =k’. As t(itn) —t(i) =/ and
ti +n+1)— tli +n) =k’, we have that t@ +n+1)—t(i) =1 +k’. By Definition 6,
(o’,itn+l1)— Spy. By induction hypothesis, (o’, j) — s;’. By Definition 6, if/ +k’ < 2-C,
then (oi tn+1) E syth. o

Proposition 5 Given a state sequence o' = O40; ... such that (o',0) —& Sc, let p be as in
Definition 7. For alli < j €N, if (o’, j) Es" with j —i =n < Candm <2.-C then
T(J) —TU) =m.

Proof In the base case j = i + 1, that is, n = 1. Assume that (o’,i +1) & sh. Then, by
Definition 7, 7(i + 1) —t(@i) =k < C,i € N. Suppose that, for 7 =i-+n,(o’,i+n) - s",
with j —i =n < C andm < 2-C, implies t(@i +n) — t(i) = m. In the induction step we
consider 7 = i+n+1. Assume that (o’,i+n+1) — snet By Points | and 2 of the definition
of Sc, there is | < k’ < C such that (o’,itn+1)— Spy. As (o’,i +n) Fs” and (o’,i +

n+l) E- Sp we have that, by Point 4 of the definition of Sc, (o’,i+n+1) —& sr m-tk’ 2.0):

Also, by Point 3 of the definition, there is no] 4 m +k’ such that (o’,i +n+1) E& gre
Then, we can assume that / = min(m + k’,2 - C). By induction hypothesis, form < 2-C,
we have that t(i +n) — t(i) =m. By Definition 7, ti +n+ 1) — tii +n) =k’. Then, if
m+k' <2-C wehave that tri +n +1)—t(i) =m+k’. Oo

We now show Theorem 4, which states the correctness of our translation using time
differences. One can use similar arguments to show Theorem 5.

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1573

Theorem 4 Let y = po A /\; Oj0,00) (pi > Wi) be an MTL formula in NNF and FNF. Let
g* = pon /\; 9@i > vi) be the result of replacing each yy; in g by ve as in Table 3.
Then, 9 is satisfiable if, and only if, g® A Sc is satisfiable.

Proof ¢ is satisfiable if, and only if, there is a timed state sequence 9 = (0, T) such that
(0,0) — g. By Theorem 3, we can assume w.l.g. that o is C-bounded, where C — | is the
largest constant in gy. Given a timed state sequence p = (0,T), let o’ = ojo; ... be as in
Definition 6. By Lemma 1, (o’,0) E Sc. By definition of o’, for all propositional variables
p; occurring in o and all j € N, we have (p, j) K p; iff (o’, 7) EK p;. With an inductive
argument one can show that, for any propositional formula a, (0, 7) E @ iff (o’, 7) Ea.

Also, v* A Sc is satisfiable if, and only if, there is a state sequence o’ such that (o’, 0) E
y* A Sc. Given o’, let p = (co, T) be a C-bounded timed state sequence as in Definition 7.
By definition of o, for all propositional variables p; occurring in o’ but not in LU), <;,,-¢ i
and all 7 € N, we have (p, j) E p; iff (o’, 7) E pj. Clearly, for any propositional formula
a, (p, j) Fa@iff(o’, j) Fa.

Thus, following Table 3, we only need to show correspondences between yy; and wy This
follows from Claims 4—6 below (other cases are similar), where p = (0, T) is a C-bounded
timed state sequence. We argue that, for all natural numbers c; with O < c; < c2 < C, the
following claims hold.

Claim 4 (0, j) E Ofe.cxje iff (o', f) FE (Ofey cs)?

Proof (0, fj) F Ofe,cj@, with c, > 0, iff (0, 7 +1) Fa andt(ij+1) € t(j) +[c1, c2].
By Definitions 6 and 7, this happens iff (o’, 7 +1) Ra and(o’",j +1 EV s},
which is equivalent to (o’, 7) EK O((\V/ 1) nA @).

C{ <i <c2 Sj

cj Si <c2

Claim5 (0, 7) F (@ Ufey,c] B) iff (o’, JE Utes ,c5] p)*.

Proof (p, j) F alc, .c.1B, withc; > 0, iffthereisi ¢ Nsuchthat t(j +i)—t(J) € [c1, ca],
(0, j/ +i) — B and foralln € N, if j <n < j +i then (o,n) Ea. By Definitions 6 and 7,
this happens iff (o’, 7 +i) K& 6 and for alln € N, if j < n < j +i then (o’,n) Ea.
By Propositions 4 and 5, for alli € N, withO < 7 -—i =n < C,andm < 2-C, we
have that (o’, j) Es” iff t(j +i) — t(j) =m. As cy > 0 and 7 is strictly monotonically
increasing, we have 1 < n < cp. Also, cy < T(J +1) —T(J) =m < cE < C,” so this
happens iff i ¢ N is such that (o’, 7 +1) F O" (Vo, <m<c. Sin) A B, with n = j — i,

and (o’, £2) E @ for all £ € N such that j < @ < j +i. This is equivalent to (o’, j) —&
V t<n<cy (O" (Ve <m<e Sin) I B) I /\o<ken ofa).

Claim6 (p, f) K& Ute.) Biff (0, 7) KE A(A(@) Utes 09) 7(B))*.

Proof (p, j) K a@l{es.co} Biff (p, 7) KE (Aa) Ufc; co] 7(B)), by semantics of U. By Claim
5, (p, jf) K (a) Ue cr] 7B) iff (o,f) K (A(@) Ufey.c21 7(B))*,
which is equivalent to (o’, j) E >(A(@) Ufc, .c5] 7(B))*- Oo

Example Assume that we are given the following MTL formula in NNF and FNF: g =
Po A Of0,co) (Po > Of2,31P1) A Of0,00) (P1 > O1,2}7q). Using Table 3, we translate g into
LTL as follows:

y* = po AD(po > (Op3]P1)) A O(p1 > p1.2}79g)*), where

2 The 2 - C bound of Propositions 4 and 5 are useful for the proof of @ Ufc 90) B.

Q) Springer
1574 U. Hustadt et al.

Table 4 Non-strict time difference translation from MTL to LTL where a, £ are propositional logic formulae,
ki, ko > Oandc},co > 0

MTL Non-strict time difference translation
(Ofky ,ooy @)? OV i, <i<c 91) A@)
(Ofky ko) OUV k, <i<k s}) Aa)

1 2

a /\ OV i<i<e, ((a A 54) ui (=s4 A a),

ti .
(@ Ufc, ,00) B) (=) A (Vey<j<cy4c 8j) \(@UB)))
(a Uf0,00) B)* (aU B)

aAO Vt<i<es (ASQ) uf! (=54 Ad),

tt 4
(@ Ue, ,c>] B) (59 (Ve) <j<cy si) A (a Ufo,0] B)*))

(a Uo0,c5} B)* (a Ujo,o] BY V (@ Uft,c5] BY
(a Ufo,0) B)* BY (aA O(a A 54) U(BA 89)))
(a Uy B)* =(=(a) Uz =(B))*

(Op,3)P1)" = WV 2<) <3 s}) A P1) and

(On,2179g)* = Vi<jian(O'(V j<j<0 s\) A 7q))
(recall that O; yy = true2/; w). By Theorem 4, ¢ is satisfiable iff y" \ S4 is satisfiable, where
S4 is the conjunction of the following:

1. 00 @= 7', for 7! = {s} | 1 <k <4);

2. 0 ®<i IT’, for 1 <i < 8 and /7' = {s' |i < j < 8};

3. B(Osk A 5] > OShrincae,s))» £0 (5E+ 57 Shinae,sy} © Ur<ies
Non-Strict Semantics
We now show how we modify the Time Difference translation for non-strict timed state
sequences. We extend the set J7! = {s} | 1 <i < C} of propositional variables representing
time differences with Sp. which holds whenever the time difference to the previous state is 0.
We say that a state is non-zero if the time difference to the previous state is non-zero. For
m > O, the meaning of the variables of the form s/, also needs to change. It now indicates
that ‘the sum of the time differences from the last n non-zero states to the current state is m’.
As before, for our translation, we only need to define these variables up to sums bounded by
2-C. We can now define our mapping from an MTL model to an LTL model.

Given a C-bounded non-strict timed state sequence (co, T), we define a state sequence o’
as in Definition 6, with the difference that, whenever t(i) = t(i — 1), we now make sj true
in o/ and, for m > 0, we copy all variables of the form s/’ in o/_, to a. Let Sj. be the
conjunction of the following:

1. 00 @=; J7!, for 7! = {st |0 <k < C};
2. O@<1 7’, for 1 <i < C and IT’ = {si |i < j <2-C};

i+1 j = j+l
3. A((Osg A sj) > OSmnin(+k.2-C))” for {s{, 5) Sinin(+k2-C)} CUlciec
4. o((Os) As} ) > Os/), for sj E Uj<iec TT’ with] > 0.

It is easy to see that (o’,0) E S$ C Note that the only difference from S C to Sc, defined
in Lemma 1, is Point 4 which propagates the variables of the form s?, to the next state if the
time difference is zero. The mapping from an LTL model of Sj. to an MTL model is defined

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1575

in the same way as in Definition 7 (but now the time difference k can be zero). To simplify
the notation, in Table 4 we write ¢ U” y, x as a shorthand for dU (y A O(¢ ur! V,X)),
where ¢ U/' v,X = (¢U x). Theorem 5 states the correctness of our translation (Table 4)
using non-strict time differences. It can be proved with ideas similar to those used in the
proof of Theorem 4. The main distinction appears in the translation of the ‘until’ formulas,
where we nest until operators so that we can count n non-zero states and then check whether
a variable of the form s? holds (in the strict case all states are non-zero, so in Table 3 we can
count these states with next operators).

Theorem 5 Let y = po A /\; Oj0,00c) (pi — Wi) be an MTL formula in NNF and FNF. Let
g* = pod /\\; Mi > We) be the result of replacing each yy; in g by we as in Table 4.
Then, 9 is satisfiable if, and only if, o® A Sc is satisfiable.

Proof (Sketch) We use our modified versions of Definitions 6 and 7 for the non-strict seman-
tics to map models of g into models of g? A S$ C and vice versa. The correctness of our
translation is again given by a structural inductive argument. As mentioned, the main differ-
ence w.r.t. to Theorem 4 is that here we use the propositional variable sj to encode multiple
states mapped to the same time point. Oo

6 Empirical Evaluation of the Translations

In order to empirically evaluate the translations, we have implemented them in SWI-Prolog
and have used them together with the LTL satisfiability solvers Aalta, Leviathan,
LS4, LWB-MOD, LWB-SAT, NUSMV-BDD, NUSMV-SBMC, plt1 (graph), pltl (tree),
TRP++, and TSPASS. The sources of the implementation of the translations and all auxiliary
files necessary to replicate the evaluation can be found at [31].

Aalta [1] implements the obligation-based LTL satisfiability checking algorithm for
finite and infinite traces devised by Li et al. [37]. We have performed experiments with both
versions 1.2 and 2.0 of Aalta. As Aalta 2.0 was consistently several orders of magnitude
faster than Aalta 1.2, we will only report the results for the latest version of Aalta.

NuSMV 2.6.0 [45] uses a reduction of the LTL satisfiability problem to the LTL model
checking problem [15]. It is then possible to decide the latter problem either using a
BDD-based algorithm (NUSMV-BDD) or a SAT-based algorithm (NUSMV-SBMC). We con-
sidered these to be two different solvers as they often exhibit different behaviours. We use
NuSMV-BDD with the options dynamic for dynamic reordering and el bwd for backward
image computation, for NuSMV-SBMC we have enabled the completeness check.

The Logics Workbench 1.1 (LWB) [39] contains implementations of two different LTL
solvers. The first is a two-pass tableau-based decision procedure developed by Janssen [34]
which underlies the provable and satisfiable functions of the p1t1 module of LWB.
In the following we denote this procedure by LWB-SAT. The second is a one-pass tableau
calculus by Schwendimann [50] which underlies the model function of the p1t1 module.
In the following we denote this procedure by LWB-MOD. In contrast to LWB- SAT, LWB-MOD
returns a model for satisfiable formulae. We again, consider these to be two different solvers
as the underlying calculi are distinct.

Leviathan [36] is an LTL satisfiability checking and model building tool that imple-
ments a novel one-pass tableau calculus by Reynolds [11,49].

The plt1 [47] system implements two tableau-based methods. The tree method is
again based on Schwendimann’s one-pass tableau calculus, the graph method is based on
a one-pass and-or tree tableau calculus [26] resulting in a time complexity optimal decision

Q) Springer
1576 U. Hustadt et al.

procedure for LTL. We denote the former by p1t1 (tree) and the latter by p1t1 (graph).
Neither of the two methods returns a model. In this section we will only report results for
pltl (graph) as it always performs better than p1t1 (tree).

TRP++ 2.2 [54] is based on an ordered resolution calculus that operates on LTL formulae
in a clausal normal form [32], while TSPASS [56] extends that calculus to monodic first-
order linear time temporal logic over expanding domains [42]. We use TSPASS with the
ModelConstruction option so that it returns a model for satisfiable formulae [41]. It
should be noted that this model construction potentially requires significantly more resolution
inferences to be performed than are necessary to just decide the satisfiability of a formula.
Thus, the way we use TSPASS puts it as a distinct performance disadvantage over TRP++
although both perform very similar inference steps when just deciding the satisfiability of an
LTL formula.

LS4 [40] is an LTL-prover based on labelled superposition with partial model guidance
developed by Suda and Weidenbach [52]. It operates on LTL formulae in the same clausal
normal form as TRP++. LS4 optionally returns a model for satisfiable formulae.

We focus on formulae where differences between the two translations could lead to dif-
ferences in the behaviour of solvers on these formulae. In particular, for (@ U{c,,¢5] B) or
Olc1.co]B, the Strict and Non-Strict Time Difference Translations contain disjunctive subfor-
mulae of the form \/, <j<co si that have no equivalence in the Strict and Non-Strict Gap
Translations of that formula. Each sum variable s‘. is also subject to the constraints expressed
by Sc. The hypothesis is that the Gap Translations lead to better behaviour of solvers on
such formulae. On the other hand, for Oj, ,o0)@ both Gap Translations contain an eventuality
formula gap U (a A —gap) that is not present in the Time Difference Translations of this for-
mula. Here, the hypothesis is that the Time Difference Translations lead to better behaviour
of solvers.

To test our two hypotheses, we consider the unsatisfiable parametrised formulae A, =
O10,b,)]P \ Olo,co)—p for values of b; between | and 10, and O, <= Of10,00) P \ Ofbs,00) 7P
for values of b2 between 10 and 100 in steps of 10.

After transformation to Flat Normal Form, we apply one of the four translations, and run
a solver five times on the resulting LTL formula (with a timeout of 1000 CPU seconds),
and then determine the median CPU time over those five runs. We refer to that median CPU
time as the runtime. The repeated runs are necessary to moderate the fluctuations shown by
all LTL solvers in the CPU time used to solve a particular formula. The experiments were
conducted on a PC with Intel 17-2600 CPU @ 3.40GHz and 16GB main memory.

Recall that for the Time Difference Translations we encode variables of the form swith
n- log m variables, where for each n we represent m in binary, e.g., sy is encoded with
ss A as? A a86 . In the following tables and graphs we denote this variant by “bTD’ to
distinguish it from the variant used for related experiments in [33] and denoted by ‘TD’
there.

Tables 5 and 6 show the runtimes for the combination of our translations with the various
LTL solvers on A, , with values of b; between | and 10, and on 0. with values of b2 between
10 and 100 in steps of 10, respectively. An entry ‘T/O’ indicates that the timeout of 1000
CPU seconds was exceeded by an LTL solver while an entry ‘Fail’ indicates that the LTL
solver encountered some other error condition and stopped before the timeout was reached.
This is often a memory allocation error or some internal data structure running out of space.

Figures 4 and 5 show the same data in the form of ‘heat maps’ where different colours are
used to represent different ranges of runtimes. This allows us to easily recognise significant
differences in the performance of the various combinations of translations and LTL solver.

Q) Springer
1577

Theorem Proving for Metric Temporal Logic Over the Naturals

COT
oro
c0°0
c0°0
10°0
10°0
10°0
10°0

10°0
10°0
10°0
10°0
10°0
10°0
10°0
10°0
10°0
10°0

LVS dM
dey

[rey
[rey
[rey
[rey
[rey
[rey
[rey
cv9

O/L
[rey
[rey
[rey
[rey
[rey
[rey
[rey
8L'6
10°0

LVS dM
GL

cro
90°0
c0°0
T0°0
T0°0
T0°0
T0°0
T0°0

T0°0
T0°0
T0°0
T0°0
T0°0
T0°0
T0°0
T0°0
T0°0
T0°0

COW aM'l
dey

O/L
O/L
O/L
O/L
O/L
O/L
S69€
90°0

O/L
O/L
O/L
O/L
O/L
19°8¢
6c S
1¢°0
10°0
10°0

COW aM
GL

sv’0
97°0
L0°0
b0°0
c0°0
10°0
00°0
00°0

00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0

vs'l
dey

€8°09
8ST
66°0
cco 0
60°0
c0'0
00°0
00°0

STO
60°0
S00
£00
10°0
00°0
00°0
00°0
00°0
00°0

vs'l

GL

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
00°0

UeYIeLA]
dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
00°0

uUvyIeIATT
dL

100
100
00°0
00°0
00°0
00°0
00°0
00°0

00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0

eqTey
dey

[rey OI
[rey
8V OV
60°
8ST
9¢'T
60°0
c0'0
SONURUIIS JOLNS-UON
[rey OI
[rey
[rey
[rey
SOT
LIT
LO0
c0'0
100
00°0
SOURIS JOINS

aN OTN OD

7~a nnwvrnwor~wvo an

eqTeV
GL Iq

JOA[OS TI] ue pue sonuewias

JOLNS-UOU/OINS ot) 0} edser YIM UON]sSUeN v Jo UONeUIQUIOD IeJNONIed & hq ‘OT S Iq S ‘de Olg v dl'@0ly = ‘tg DA[OS 0} porInbas ‘spuodes gD Ul ‘ouMUNY g¢ aqey

pringer

QS
U. Hustadt et al.

1578

cco0 O/L Ill O/L SL’°0 O/L IVT O/L c0°0 O/L Ol
$70 O/L v$°0 O/L 97°0 O/L 9TCT O/L 10°0 O/L 6
610 O/L 6S°0 O/L Oro O/L 90°S O/L 10°0 O/L 8
vT'0 O/L cv'0 O/L r0°0 O/L Cly O/L 10°0 O/L L
Oro O/L 87°0 O/L 10°0 O/L CST O/L 10°0 O/L 9
L0°0 O/L 8T0 O/L 00°0 O/L 10'T O/L 10°0 O/L ¢
r0°0 CC OEY Or0 O/L 00°0 O/L 8r'0 O/L 10°0 O/L V
£0°0 OV CE s0°0 O/L 00°0 O/L £770 O/L 00°0 VOCE €
c0°0 LoS c0°0 €9°C6 00°0 O/L Il0 O/L 00°0 OT c
00°0 vO'0 00°0 90 00°0 86 Te s0°0 19°C8I 00°0 ITO I
SOTUBUTAS JOTIJS-UON
00°0 O/L 00°0 91°88 00°0 O/L L0°0 €8°89 10°0 O/L Ol
00°0 O/L 00°0 cO'CS 00°0 O/L s0°0 ve OE 10°0 O/L 6
00°0 LIIT 00°0 IST 00°0 O/L r0°0 vr st 10°0 O/L 8
00°0 OV'0 00°0 610 00°0 O/L £0°0 68'8 10°0 O/L L
00°0 CCT 00°0 160 00°0 O/L c0°0 OLE 00°0 O/L 9
00°0 ITO 00°0 £00 00°0 O/L c0°0 OS T 00°0 Co OI ¢
00°0 v0'0 00°0 100 00°0 O/L c0°0 890 00°0 6c Te V
00°0 c0O'0 00°0 00°0 00°0 O/L 10°0 0c 0 00°0 Loe €
00°0 00°0 00°0 00°0 00°0 CLV 10°0 c0'0 00°0 L7O c
00°0 00°0 00°0 00°0 00°0 00°0 00°0 100 00°0 100 I
SONUBUAS JOTIIS
yderzb yderb ONS OWas aad aad Iq

SSVWdSL SSVdSL +40 +40 T3atd T3atd AWSTN AWST.N AWSTN AWSTN

dep GL dep GL dep GL dep GL dep GL

penuTuos g ayqey

pringer

QDS
1579

Theorem Proving for Metric Temporal Logic Over the Naturals

100
100
100
100
100
100
100
100
100
100

100
100
100
100
100
100
100
100
100
100

LVS aM
+dey

10°0
cO0
10°0
10°0
10°0
10°0
10°0
10°0
10°0
10°0

10°0
10°0
10°0
10°0
10°0
10°0
10°0
10°0
10°0
10°0

LYS AMT
+149

£00
£00
c0'0
c0'0
c0'0
10°0
10°0
10°0
10°0
10°0

£00
c0'0
c0'0
c0'0
10°0
10°0
10°0
10°0
10°0
10°0

COW dM"
+dey

10°0
10°0
10°0
10°0
10°0
10°0
10°0
10°0
10°0
10°0

10°0
10°0
c0°0
10°0
10°0
10°0
10°0
10°0
10°0
10°0

COW aM'1
+QL4

8CC
cel
860
c80
LS‘0
6c°0
1c 0
60°0
v0'0
100

LTT
cel
96°0
v3°0
cco
6c°0
070
60°0
v0'0
100

vs'l
+dey

00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0

00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0

vs
+149

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

uUvYIVIATT
+dey

[req
[req
[req
[req
[req
[req
[req
[req
[req
00°0

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
00°0

ueyyeIAgT
+149

[rey
[rey
[rey
[rey
[rey
6c 89
86 €7
gs°9
col
90°0

[rey
[rey
[rey
[rey
[rey
66:99
el ve
LL9O
Tel
S00

eqTeV

+dey

00°0 OO
00°0 06
00°0 08
00°0 OL
00°0 09
00°0 OS
00°0 OV
00°0 O¢
00°0 OC
00°0 Ol
SOURS JOLIS-UON
00°0 OO
00°0 06
00°0 08
00°0 OL
00°0 09
00°0 OS
00°0 OV
00°0 O¢
00°0 OC
00°0 Ol

SOURIS JOINS

eqlTey
+CL4

cq

JOA[OS TJ Uv pue SOULS 1911)S-UOU/JOIIS
oY} 0} JOodsar YIM UOTeIsue Be JO UOTeUIqUIOD Ie[NOTIed & Aq ‘QO, > Cg > OC] ‘d Uda vy d@0N9 = “Ig dAIOS 0} pormnbal ‘spuosas gD UI ‘ouUMUNY 9 aqeL

pringer

QS
U. Hustadt et al.

1580

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
60°L6S

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
TO'SLS

ssvdsib
dey

6S°0
oro
L7'0
Lv0
L0°0
b0°0
c0°0
100
00°0
00°0

6S°0
oro
L7'0
810
80°0
b0°0
c0°0
10°0
00°0
00°0

SSVdSiL
+AL4

O/L
O/L
O/L
O/L
O/L
O/L
£196
OC 667
19°S9
L3°0

O/L
O/L
O/L
O/L
O/L
O/L

co C6
Le Ivy
cS 19
L3°0

+4+dub
+dey

00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0

00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0

+4+dub
+dL4

00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0

00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0

yderb

T3a1td
+dey

00°0
cO0
[00
[00
00°0
00°0
00°0
00°0
00°0
00°0

00°0
[00
[00
[00
00°0
00°0
00°0
00°0
00°0
00°0

yderb
T3atd
+d.L9

6¢°S6
00°99
89° CV
LO'LT
LV 91
6L°6
v9'V
LOC
9L'0
610

CI L6
16°19
98° CV
8e°L7
c8 ST
18°38
cv'y
vol
69°0
LTO

OWES
AWSTN
+dey

b0°0
s0°0
90°0
90°0
10°0
c0°0
c0°0
00°0
10°0
10°0

b0°0
s0°0
90°0
L0°0
10°0
c0°0
c0°0
10°0
10°0
00°0

OWAS
AWSTN
+149

81°C?
Ic Ol
OV IC
19°9
LLL
68°T
Tel
66°0
6r'0
ITO

96'TT
vS'°6
LT €T
LVS
LI€
Tee
99'T
s9°0
6c'0
60°0

ddd
AWSTN
+dey

60°0 OOT
Oro 06
170 08
ce"0 OL
10°0 09
c0°0 OS
L0°0 OV
10°0 O¢
10°0 OC
00°0 Ol
SOURS JOLIS-UON
60°0 OOT
07°0 06
170 08
0¢°0 OL
10°0 09
c0°0 OS
c0°0 OV
00°0 O¢
10°0 OC
00°0 Ol

SOURIS JOINS

ddd
AWSON
+14

cq

penuTuos ga3qey

pringer

Y)S
Theorem Proving for Metric Temporal Logic Over the Naturals 1581

Strict Semantics Non-Strict Semantics

bTD + Aalta

Gap +Aalta

bTD + Leviathan
Gap + Leviathan
bTD+LS4

Gap +LS4

bTD + LWB-MOD

Gap +LWB-MOD
bTD + LWB-SAT
Gap +LWB-SAT
bTD + NuSMV-BDD
Gap + NuSMV-BDD
bTD + NuSMV-SBMC
Gap + NuSMV-SBMC
bTD + pltl (graph)
Gap + pltl (graph)
bTD + TRP++

Gap +TRP++

bTD + TSPASS

Gap + TSPASS

 

Fig. 4 Heat map of the runtimes on 5, = 0[0,b,]P \ Of0,cc)7p- Each rectangle represents the

runtime in CPU seconds of a particular combination of a translation with respect to the strict/non-
strict semantics and an LTL solver on one instance of a with runtimes given in colours as follows:

< 0.01 sec > 0.01 sec, < 0.25 sec > 0.25 sec, < 0.50 sec’ > 0.50 sec, < 1 sec
> 1 sec, < 2sec| | > 2 sec, < 4 sec | > 4 sec, < 8 sec |) > 8 sec, < 16sec
> 16sec,< 32sec > 32sec,< 64secH> 64sec, < 125 sec > 125 sec, < 250 sec
> 250 sec, < 500 sec J > 500 sec, < 1000 sec ff T/O, OoM or Fail

The results in Table 5 and Fig. 4 confirm our hypothesis that on A, the Gap translations will
lead to better performance than the Time Difference translations. For both the strict and non-
strict semantics, for all LTL solvers, and for all values of b; considered, the Gap translations
result in better or equal performance than the Time Difference translations (highlighted in bold
in the Table 5), with the vast majority of entries indicating a significantly worse performance
for the Time Difference translations.

Regarding the strict versus the non-strict translations, we would expect that a non-strict
translation results in worse performance compared to the corresponding strict translation as
the search space for an LTL solver is larger. This is indeed the case for all provers.

The best performing combination is Gap+Aalta. The most ‘robust’ LTL solver, in the
sense of producing the lowest total runtime across all translations and all instances of Oy,
considered, is LS4.

The results in Table 6 and Fig. 5 also largely confirm our hypothesis that on 0, the Time
Difference translations will lead to better performance than the Gap translations. In total we
have considered ten LTL solvers with two translations under two different semantics, giving
us twenty points of comparison between a Time Difference translation and a Gap translation,
each over ten instances of 0, In Table 6 we have highlighted in bold all instances where a
Time Difference translation leads to better or equal performance and in italics all instances
where the opposite is true. We see that for only seven instances the latter is the case, six of
them for plt1 (graph).

The reason is that most of background theories Sc and Sj. that form part of the Time
Difference Translations turn out not to be relevant to the (un)satisfiability of (65,)*. Most

Q) Springer
1582 U. Hustadt et al.

Strict Semantics Non-Strict Semantics

bTD+Aalta

Gap +Aalta

bTD + Leviathan
Gap + Leviathan
bTD+LS4

Gap +LS4

bTD + LWB-MOD

Gap +LWB-MOD
bTD + LWB-SAT
Gap +LWB-SAT
bTD + NuSMV-BDD
Gap + NuSMV-BDD
bTD + NuSMV-SBMC
Gap + NuSMV-SBMC
bTD + pltl (graph)
Gap + pltl (graph)
bTD + TRP++

Gap +TRP++

bTD + TSPASS

Gap + TSPASS

 

Fig. 5 Heat map of the runtimes on 05, <= Of10,00) P “ Ofc },c0) 7P- Each rectangle represents the

runtime in CPU seconds of a particular combination of a translation with respect to the strict/non-
strict semantics and an LTL solver on one instance of > with runtimes given in colours as follows:

< 0.01 sec > 0.01 sec, < 0.25 sec > 0.25 sec, < 0.50 sec’ > 0.50 sec, < 1 sec
> 1 sec, < 2sec| | > 2 sec, < 4 sec | > 4 sec, < 8 sec |) > 8 sec, < 16sec
> 16sec,< 32sec > 32sec,< 64secH> 64sec, < 125 sec > 125 sec, < 250 sec
> 250 sec, < 500 sec J > 500 sec, < 1000 sec ff T/O, OoM or Fail

provers appear to be able to derive a contradiction without too many inferences involving
Sc or S’., while p1t1 (graph) does not. If one restricts Sc and Sc by hand to smaller
sets strictly necessary to establish the (un)satisfiability of (65), then pltl1 (graph) also
performs better with the Time Difference Translations than with the Gap Translations on all
instances.

Aalta, LS4 and TRP++ with a Time Difference translation as well as plt1l (graph)
with a Gap translation can solve all instances in negligible time. The most ‘robust’ LTL solver
on 0, over all translations is pl1t1 (graph).

Overall the evaluation presented in this section confirms that no translation is always
strictly ‘better’ than the other. It will depend on the characteristics of the formula and some-
times on the LTL solver whether a Time Difference translation or a Gap translation results in
better performance and therefore in a greater likelihood of deciding a formula in reasonable
time. However, the experiments also show the significant performance improvements that
can be achieved by choosing the ‘right’ translation and, arguably, the simplicity of the Gap
translations means that more often than not it is the translation to use. The experimental
results presented in the next section provide additional support for this.

7 Examples Revisited

In the following we revisit the examples given in Sect. 3. For the foraging robots, traffic lights
and multiprocessor job-shop scheduling scenarios, we have stated a range of properties that

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1583

we will now attempt to prove using our translations together with the LTL solvers Aalta,
Leviathan, LS4, LWB-MOD, LWB-SAT, plt1 (graph), NuSMV-BDD, NuSMV-SBMC,
TRP++, and TSPASS. The collection of MTL formulae for the specifications and properties
can again be found at [31].

7.1 Foraging Robots

For the foraging robots example we use the specification given in Sect. 3.1 with the maximum
time that the robot can be spent resting 7; = oo, the maximum time that the robot be spent
searching for food T,; = 5, and the maximum time that the robot needs to get home with our
without food Ty = 2. Let rr denote the conjunction of the formulae in the specification.
We want to prove that the following properties follow from rr:

— Having left home the robot will eventually reach home again.
0,00) leavingHome — 10,00) resting) (F))
— The maximum time the robot needs to return home is x
0,00) leavingHome — (0,x] resting) (F;)
The lowest value x for which we can prove that (F; ) follows from 2’rr is the maximum
time the robot needs to return home. For our choice of Tj, 7;- and T; that lowest value of
x is 9 and in our experiments we consider Fs and F?,i.e.,x = 8andx = 9, respectively.
— The minimum time the robot needs to return home is y.
O[0,00) (leavingHome — Oj0,y—1)7resting) (F3)
The highest value y for which we can prove that (F' 3 ) follows from X’rr can be proved
is the minimum time the robot needs to return home. This value is independent of the
choice of Ty, T, and 7;, instead it depends on the lower bounds in relevant intervals. For
2'rr that highest value of y is 3 and in our experiments we consider F3 and F*, ice.,
y = 3 and y = 4, respectively.

To prove that rr — ¢ holds, we check the unsatisfiability of 7p \—@. In Table 7 we denote
DFR /\ —g@ by ¢ in the first column. The second column indicates whether ¢ is satisfiable (S)
or unsatisfiable (U). The remaining columns of the table show the runtime for each translation
and each prover. We again have used a timeout of 1000 CPU seconds and as before “T/O’ in
the table indicates that a prover was not able to determine the satisfiability of the translated
formula within that time while ‘Fail’ indicates that an LTL solver encountered some other
error condition and stopped before the timeout was reached.

On all formulae each LTL solver, except TSPASS, performs better with the Gap Transla-
tion than with the Time Difference Translation. Only LS4 is able to decide the satisfiability
of all formulae with both translations. LWB-MOD and NuSMV-BDD are able to decide the
satisfiability of all formulae with the Gap Translation but fail to decide any of the formu-
lae with the Time Difference Translation. The latter is also true for LWB-SAT, p1ti1, and
TRP++. TSPASS is the only system showing better performance with the Time Difference
Translation, it can solve two unsatisfiable formulae with that translation but none with the
Gap Translation.

7.2 Traffic Lights

For the traffic lights example we use the specification given in Sect. 3.2, denoted by »’7p.
We want to prove that the following properties follow from 2 7p:

Q) Springer
U. Hustadt et al.

1584

O/L
O/L
O/L
O/L
O/L

ssvdsib
+dey
O/L

6r IC

CC CE
L9°8

COST

LVS dM
+dey

O/L
eL9
O/L
O/L
£696

ssvdsib
+QL4
O/L
O/L
O/L
O/L
O/L

LVS aM
+AL4

O/L
O/L
O/L
O/L
O/L

+4+daib
+dey
C8'V
£6
Ics
S19
SO°SLT

COW aM'l
+dey

[rey
[rey
O/L
O/L
[rey

+4+dub
+dL49

O/L
O/L
O/L
O/L
O/L

COW aml
+14

O/L
O/L
O/L
O/L
O/L
ydersb
T3Td
+dey
00°0
00°0
100
100
S10
Vs'l
+dey

O/L
O/L
O/L
O/L
O/L
ydersb
T31d
+Q.L9
c0'0
10°0
vse
T¢0
700
vs'l
+Q.L9

0c'0
[rey
O/L
18°0
[rey
OWES
AWSTN
+dey
O/L
O/L
[re
[rey
O/L

ULYIVIATT]
+dey

06'T
[rey
[rey
OL6I
[rey
OWAS
AWSTN
+QL4
O/L
O/L
[rey
[rey
O/L

UvYILIATT
+149

I8'T
cel
99°C
v8'T
6c
add
AWST.N
+dey
vol
09°0
LICC
OS'9
[rey

eqlTew
+ dey

O/L
O/L
O/L
O/L
O/L
add
AWSON
+QL4
O/L
c6'0
[rey
[rey
66 67S

eqTew
+CdL4

PnrnrpPpn

nA

Pnrnpn

S

JOA[OS ‘TJ ue pue uOoTL[sueT) ve JO UOTeUIqUIOD IepNoned ev Aq sonsodoid JoqoY SUIseIO SATOS 0} posnbal ‘spuodses gD Ul ‘awIUNY Z aqeL

pringer

Y)S
Theorem Proving for Metric Temporal Logic Over the Naturals 1585

Infinitely often each traffic light will be green.

D[0,00) 0,00) 81 \ Ff0,00) Y[0,00) 82 (T;)
— If acar is detected on road R1 then the wait will be at most x; time units.
O[0,00) (detect > Oj0,x181) (T5)

This property holds for x > 3 but not 0 < x < 3. In our experiments we consider T;
and T3, Le., x = 2 and x = 3, respectively.

— If traffic light 2 is currently red then it will be green within | to y time units.

O0,00) (r2 > Of1,y] 82) (T})

This property holds for y > 7 but not 0 < y < 7. Consequently, we will consider Te
and Ti, Le., y =6and y = 7.

— If a traffic light is currently amber or red, then a car has to wait at most z time units until
the traffic light will be green.

O0,00) (((a1 V 11) A detect) > J0,z2181) A Of0,00) (a2 V r2) > Of0,2182) (Tf)
This property should hold for z > 9 but not 0 < z < 9 and we focus on T? and T;..

As for the Foraging Robots example, in order to prove X'7r — g for an MTL formula g,
we check the unsatisfiability of X’7r A —@. In Table 8 we denote vr A —¢ by ¢ in the first
column. The second column indicates whether ¢ is satisfiable (S) or not (U). The remaining
columns show the runtime for each translation and each prover. We have for the first time
included results for p1t1 (tree), as there are instances on which it performs better than
pltl (graph).

As we can see, these formulae are much more challenging than those for the Foraging
Robots example. This is not surprising if, for instance, one considers the state space of
potential models for our specifications. A robot could only be in one of nine states. In
contrast, each of the two traffic lights can be in one of four states plus we have a sensor that
can be in one of two states. That already gives us 32 global states, only two of which are
straightforwardly excluded by the constraint that not both traffic lights can be green at the same
time. Furthermore, for the Foraging Robots example we only had one ‘defined’ propositional
variable searching that had a rather straightforward definition while in the Traffic Lights
example we have change, and change? that are subject to much more complicated temporal
constraints.

As a consequence, only NUuSMV-BDD with the Gap Translation and LS4 with the Time
Difference Translation can solve all formulae. For LS4 the Gap Translation still results in
better performance on all formulae that can be solved by both translations within the time
limit. The same is true for NuSMV-SBMC and for Aalta. LWB-SAT, pltl, TRP++ and
TSPASS fail to solve a single formula with either translation within the timeout.

7.3 Multiprocessor Job-Shop Scheduling

Regarding the Multiprocessor Job-shop Scheduling problems (MJS problems for short) we
made the simplifying assumption that a job j;, foreachi, 1 <i <n, takes the same amount
of time ¢; on whichever machine it is processed on. We can then characterise an MJS problem
by stating (i) a job list J consisting of a list of durations (¢;,..., t,), Gi) the number k of
machines available, and (ii1) the time bound ¢. In Eqs. 15, 16, 22 and 23, foreveryi,1 <i <n,
and every /, 1 <1 <k, tj,m, will be given by t' The time bound f is used in the formula
10,11 \j-1 has Run j;, that expresses the requirement for a schedule that completes all n jobs
on k machines in at most f time points.

Q) Springer
U. Hustadt et al.

1586

 

O/L
O/L
O/L
O/L
O/L
O/L
O/L

ssvdsib
+dey

O/L

O/L

O/L

O/L

O/L

O/L

O/L

LVS aM
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L

osvdsib
+QL4
O/L

O/L

O/L

O/L

O/L

O/L

O/L

LVS aM]
+QL4

O/L O/L O/L O/L [re [rey S8°C8 O/L nN gL
O/L O/L O/L O/L eve IL el €8° COC O/L S dL
O/L O/L O/L O/L [re [rey LI'97@ O/L nN EL
O/L O/L O/L O/L Tel vO £6 °6C O/L S GL
O/L O/L O/L [rey [re [rey I¢'6 O/L nN él
O/L O/L O/L [re LO wy CO 8 O/L S EL
O/L O/L O/L [ef O/L [rey 60°S7 O/L S IL
yderb yderb OWaS OWS dad aad
++dUL ++dUL T31d T31d AWSTN AWSTIN AWSTN AWSON
+dep +q.Lq +dep +qLq +depy +GLq +dep +q@L4q s
O/L O/L OL'0O LO'CET [rey [re [re [rey nN él
O/L O/L 09°0 80'T [rey [re O/L [rey S dL
O/L O/L c8 0 6c 7 [rey [re [re [rey nN EL
ev Le O/L ec 0 O10 [rey [re O/L [rey S EL
O/L O/L 00°0 100 [rey [re VI’ vLY nN él
O/L O/L 810 810 O/L O/L [re O/L S EL
O/L O/L O/L SO’ O/L [re [re O/L S IL
COW aM" COW aM" vs vs UvYIPIAIT ULYILIAIT el1TeVv ealTev
+dey +d.Lq +dep +aLq +dep +d.Lq + dep +q.Lq s

IOA[OS "TT ue pue uoTeysuey ve Jo UONeUIqWIOD Ie[NoTWed ev Aq sonsodoid syst] OYJe.) SAlOS 0} posmmbal ‘spuodses Mq_ Ul ‘ouMUNY gaqeL

pringer

Y)S
Theorem Proving for Metric Temporal Logic Over the Naturals 1587

It is an interesting characteristic of the MTL formulae for MJS instances that unsatisfiable
MTL formulae are smaller than satisfiable MTL formulae. A time bound f that is too small
leads to an MJS problem for which no schedule exists that can complete all jobs within the
given time bound while a sufficiently large time bound guarantees that such a schedule can
be found. By our encodings, a small time bound results in a smaller LTL formula than a large
time bound. The difference in size is more pronounced for the Time Difference Translations
than for the Gap Translations. This is in contrast to, say, random 3CNF formulae or random
modal K3CNEF formulae that are often used for benchmarking SAT solvers or modal logic
provers, where unsatisfiable formulae tend to be larger than satisfiable formulae.

For our experiments we created 36 MJS problems with a number n of jobs between | and
4, a duration t; of ajob between | and 4, a number k of machines between | and 3 and finally
a time bound ¢ between 0 and 5. We then constructed MTL formulae for the strict semantics
and the non-strict semantics according to the formalisations in Sect. 3.3. Finally, we used a
combination of one the encodings with an LTL solver to determine the satisfiability of each
MTL formula, or if the LTL solver has that capability, attempt to find a model for it, with a
timeout of 1000 CPU seconds.

If an LTL solver reports that the formula resulting from an MJS problem with n jobs, k
machines and time bound f is satisfiable, then a schedule exists that completes all n jobs on
k machines within f time points. However, this provides us with no information about what
that schedule might be. If for a satisfiable formula the LTL solver also returns a model, then
the information at which time point start Run jm, (or start Runj; A mj, for the non-strict
semantics) becomes true indicates when a particular job has to be started on a particular
machine in order to complete all jobs within the time bound, thus, the model provides us
with a schedule.

Among the systems included in our experiments, only Leviathan, LS4, LWB-MOD,
NuSMV-BDD, NuSMV-SBMC, and TSPASS can produce models and have been used with
the command line options that require them to do so.

Tables 9, 10, 11, 12, 13, 14 show the results for the formalisation of MJS problems in MTL
with strict semantics and non-strict semantics, respectively. The first three columns in each
table show the job list J, the number k of machines and the time bound ¢. The fourth column
indicates whether the corresponding MTL formula is satisfiable (S) or unsatisfiable (U). The
remaining columns of the table show the runtime for each translation and each prover (‘T/O’
indicates timeout, ‘Fail’ indicates that the solver encountered some error condition before
reaching the timeout). Figure 6 shows the same data in the form of a heat map.

Regarding the formalisation of MJS problems in the strict semantics, we see in Fig. 6
and Tables 9, 10, 11 for the 296 MJS problem for which an LTL solver can determine its
satisfiability with either the Gap or the Time Difference Translation, for 183 problems the
Gap Translation results in better performance, for 32 problems the opposite is true, while
for 81 problems we get the same performance. The two LTL solvers for which the Time
Difference Translation regularly results in better performance are TRP++ and TSPASS. The
Gap Translation together with LS4 offers the best performance for every instance.

Regarding the formalisation of MJS problems in the non-strict semantics, the most striking
observation we can make from Fig. 6 and from the data in Tables 12, 13, 141s how much more
challenging the corresponding LTL satisfiability problems are for all the provers. In total there
are 36 MJS problems on which we benchmarked 11 LTL solvers / settings with 2 different
translations producing a total of 792 results. Of these 449 were timeouts, compared to 206
timeouts for MJS problems in the strict semantics. In a further 130 instances an LTL solver
failed, that is, it encountered a memory allocation error, exhausted the limited size of some
internal data structure, or produced some other internal failure before reaching the timeout.

Q) Springer
U. Hustadt et al.

1588

 

O/L
O/L
O/L
00°0
O/L
O/L
O/L
00°0
O/L
O/L
SO ICS
00°0
LI8I
vO'8I
vr'l
00°0
Lol
L9°0
90°0
00°0
00°0
00°0
00°0
00°0

9023 TaTd

+dey

O/L
O/L
O/L
00°0
O/L
O/L
O/L
00°0
O/L
O/L
O/L
00°0
O/L
O/L
O/L
00°0
O/L
O/L
60° 18¢
00°0
O/L
89°9
00°0
00°0

90273 T3aTd

+dLq

O/L
O/L
O/L
00°0
O/L
O/L
O/L
00°0
O/L
O/L
89 OLE
00°0
6L TT
Os TT
v3°0
00°0
6C'€
col
ITO
00°0
00°0
00°0
00°0
00°0

yderb TaTd

+dey

O/L
O/L
O/L
00°0
O/L
O/L
O/L
00°0
O/L
O/L
O/L
00°0
O/L
O/L
O/L
00°0
O/L
O/L
6¢ 796
00°0
O/L
IL9
00°0
00°0

yderz6 T3aTd

+dLq

£0987
8S LOT
9g°SS
90°0
6 LVT
CO CVT
c8 Eel
c0'0
LOY
SIV
C86
10°0
ITO
80°0
S00
10°0
£00
c0'0
10°0
10°0
10°0
10°0
10°0
10°0
LVS dM
+dey

[rey
[rey
O/L
LO'0
[rey
[rey
O/L
c0'0
[rey
[rey
6C 6¢9
c0'0
[rey
[rey
SVL
10°0
[rey
[rey
ve 0
10°0
[rey
LV'68
100
100
LVS dM
+QL4

C81
cL'0
cO'0
100
810
Iv'0
£0°0
100
ITO
cl‘0
cO'0
100
£0°0
cO'0
100
100
cO'0
100
100
100
100
100
100
100
COW aM
+dey

O/L
ve9
c0'0
10°0
6¢°€
C80
cri
10°0
vO'V
9¢°0
cO'0
10°0
VEC
L10
Sc 0
10°0
€8°C6
cv'0
10°0
10°0
es
S00
10°0
10°0
COW aM
+QL4

PnnnrnDyPD NPP HANDPDNANDYPDPNHANDDPDPD nD

S

COTA NM OF NNO VF NOON OO TI  NCU OO OUlURCLUNC OOO TICLUNCCUL SM

bn er ee ce GE Qs Qs Es QQ OO EO OO EL OO EE @ EE QE @ |

4

TTT
TTT
TTT
TTT
TIT
TIT
TIT
TIT
TIT
TIT
TIT
TIT
(onl

(onl

(onl

(onl

(onl

(onl

(onl

(onl

S-=cUlUl Ol

f

((9823) T3Td “(ydesb) TATd ‘LvS-aMT
‘COW-AM'T) IOAlOS TIT ue puv SOTUBUIIS 191} BY} 0} JOOdsoI YIM UONL[sSuL) B JO UONeUIqWIOD IejNoned ev Aq suaTqod SfAJ DATOS 0} posrNbar ‘spuosas gO Ul ‘ouMUNY 6 aqGe]L

pringer

Y)S
1589

Theorem Proving for Metric Temporal Logic Over the Naturals

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
00°0
90273 TaTd
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
00°0
90273 T3aTd
+14

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
00°0
yderb T3aTd
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
00°0
yde1rz6 TaTd
+14

O/L
O/L
EL’ vvs
96 9LI
O/L
TS°08S
1S°6L7
00°08
O/L
O/L
O/L
O10
LVS adMT
+dey

O/L
O/L
O/L
O/L
O/L
[rey
[rey
O/L
[rey
[rey
O/L
£00
LVS adMT
+QL4

£0°8C
86°CI
807
89°0
ILL
90'L
cL'0
c0'0
CLT
SSE
S00
100
COW aM
+dey

O/L
O/L
O/L
O/L
O/L
O/L
9TCES
£00
O/L
SLE
90°0
100
COW aM
+QL4

PYPnnvnvvnvpyprnyoypopn

Om NOM TR NO TNO TM

ETT
ETT
ETT
ETT
CCT
CCT
CCT
CCT
TTT
TTT
TTT
TTT

MOAN NANANNANNAINANANIANAN AN

4 f

penuTuos §93qGeL

pringer

QS
U. Hustadt et al.

1590

 

O/L
€8'l
co'0
£00
L9'0V9
OL'OST
870
cO'0
O/L
86° C16
0c'0
cO'0
e8'8IT
O8 PE
80°0
100
89°6S7
80°0
£00
100
SEL
00°C
ITT
00°0
sovdsib
+dey

O/L
O/L
£00
c0'0
O/L
TTLST
O10
100
O/L
9L'6CI
c0'0
100
SO'LLYV
Sc OV
v0'0
100
c0'0
OTST
100
100
10'T
e10
c0'0
00°0
sovdsib
+QL4

O/L
IT'8¢
0c'0
10°0
O/L
O/L
cco 0
00°0
O/L
O/L
80°0
00°0
O/L
O/L
v0'0
00°0
O/L
910
00°0
00°0
cS'0
6£°0
co0
00°0
+4+daib
+dey

O/L
O/L
90°0
00°0
O/L
O/L
LO'0
00°0
O/L
O/L
00°0
00°0
O/L
8e 6EL
10°0
00°0
O/L
c8'T
00°0
00°0
O/L
90°0
00°0
00°0
+4+dab
+QL4

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
£0'0¢

ULYIVIATT]
+dey

[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
6$°C
c9'0

UvYyIVIATT
+149

90°0
L0'0
10°0
00°0
£00
v0'0
c0'0
00°0
c0'0
£00
10°0
00°0
10°0
10°0
00°0
00°0
10°0
10°0
00°0
00°0
00°0
00°0
00°0
00°0
eq lew
+dey

1I0'T
110
100
00'0
9L0
LO'0
100
00'0
60
80°0
100
00'0
VIO
LO'0
00'0
00'0
LL I
S00
00'0
00'0
170
cO'0
00'0
00'0
eqTew
+d.Lq

PnnnrDyP DI NPD HANDYPDNADYPDPDHANDDPDPD nD

TTT
TTT
TTT
TTT
TIT
TIT
TIT
TIT
TIT
TIT
TIT
TIT
(onl

(onl

(onl

(onl

(onl

(onl

(onl

(onl

COTA NM OF NNO VF NOON OO TI  NCU OO OUlURCLUNC OOO TICLUNCCUL SM
Soo Om Or re sl UNINC INCU NC NCCU NCIC NC NC MOM MO MM N NON NN

S-=cUlUl Ol

J ¥ L

(SSVdS.L ‘++duL ‘UeyeTAST

‘CL TEV) JOAJOS TJ Ue pue soNUBUTAS JOINS OY) 0} JOOdSaI YIM UOTR[SUL.) B JO UONVUIQUIOD JepNoTVIed ve Aq sua[goid Sf BATOS 0} posINbal ‘spuodsas gD Ul ‘oUIUNY OL aqeL

pringer

Y)S
1591

Theorem Proving for Metric Temporal Logic Over the Naturals

O/L
O/L
OO'ST
9C'C
O/L
CO’ 16S
Tel
cL 0
O/L
O/L
9L'0
v0'O

ssvdsib

+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
90°0
O/L
O/L
60°0
c0'0

SSVWdSiL
+AL4

O/L
O/L
O/L
O/L
O/L
O/L
SV C8E
6c'0
O/L
O/L
96°0
cO'0
+4+daiL
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
e10
O/L
O/L
1¢°0
00°0

+4+dab
+dLq9

[rey
[rey
[rey
[rey
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

ULYIVIATT]
+dey

[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
UvYyIVIATT
+149

660
99°0
L770
90°0
870
ve0
£00
10°0
S00
L0'0
c0'0
00°0
eqTeW
+dey

06 9IT
O/L
6l TT
v60
OO'ET
EOL
cS'0
vO'0
ve 0
8c 0
cO'0
00°0
eITeW
+d.L9

PYPnnvnvvnvpyprnyoypopn

Om NOM TR NO TNO TM

ETT
ETT
ETT
ETT
CCT
CCT
CCT
CCT
TTT
TTT
TTT
TTT

MA ANTMNMNANNAIANANIAN AN

4 f

ponunuos gL aqey

pringer

QS
U. Hustadt et al.

1592

 

Le'0
0c'0
v10
O10
970
970
cT0
60°0
610
610
O10
90°0
cl‘0
cl‘0
90°0
v0'0
ITO
90°0
v0'0
cO'0
£0°0
cO'0
cO'0
100
OWES ANSTN
+dey

180
6c 0
1c 0
VIO
LVv'0
8c 0
810
cl0
0S°0
6c 0
VIO
O10
ce0
LI 0
O10
LO'0
tv 0
ITO
80°0
S00
1c 0
80°0
v0'0
10°0
OWAS ANSTN
+QL4

OL'VE
vest
cO's
6c
Ice]
868
vVI'V
VOE
16°C
99'T
06°
vol
cL'0
6S 0
6S 0
6c°0
9V'0
9¢°0
9¢°0
STO
S00
v0'0
v0'0
10°0

ddd AWS UN

+dey

O/L
vV'vEe
ST 9I
LVv'8
O/L
So LI
90°TT
00°9
VL OST
LOST
vL'V
6r'¢
S09
99°¢
col
col
80°TT
OL'T
6ST
OT
S8e
19°0
O10
O10
ddd AWS UN
+149

00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
vs'l
+dey

c0'0
00°0
00°0
00°0
00°0
00°0
00°0
00°0
100
00°0
00°0
00°0
100
00°0
00°0
00°0
100
00°0
00°0
00°0
00°0
00°0
00°0
00°0
vs'l
+149

PnnnrDyP DI NPD HANDYPDNADYPDPDHANDDPDPD nD

TTT
TTT
TTT
TTT
TIT
TIT
TIT
TIT
TIT
TIT
TIT
TIT
(onl

(onl

(onl

(onl

(onl

(onl

(onl

(onl

COTA NM OF NNO VF NOON OO TI  NCU OO OUlURCLUNC OOO TICLUNCCUL SM
Sor re NOC INCU INC NCC NC IN INC NO MOM OM MO MN NN NN

S-=cUlUl Ol

J ¥ L

(OWAS-ANSUN ‘Gadd-ANSNN

‘7S'1) JOA[OS TIT ue pue sonUPUds OLS dy} 0) JOodsor YM UONR[SURT B JO UONCUIQUIOD Ie[NoTVIed B Aq swa{qoId Sf 9ATOS 0} porInbos ‘spuodas qD Ul ‘oWMUNY LL aqey

pringer

Y)S
1593

© 190
BS

8 6¢'0
£ 0¢'0
o €7'0
oO

vy 8r'0
Do

S 67'0
oO

S 770
a. .
E 910
k-

w Or'0
J 6¢'0
oS IZ0
oH

£ v0
>

©

fc OWaS ANSTN
O +dey
oO

wu

—

vO’
OST
OCT
£60
8L' I
L9°0
cS'0
Le 0
8L0
cS'0
Le0
810
OWAS ANSTN
+QL4

88°17
LE 8V
68°ST
Iv'vl
IT'Ic
C991
10°CI
68°L
S9O're
vS'9C
c9OVI
6S°8
ddd AWS UN
+dey

O/L
O/L
LS'888
O/L
O/L
cv LOI
SI Tel
$6 £8
O/L
S0'6L
LV'CS
vs vl
ddd AWSUN
+149

cO'0
cO'0
00°0
00°0
10°0
00°0
00°0
00°0
10°0
10°0
00°0
00°0
vs'l
+dey

ae)
LTO
v0'0
100
£00
100
00°0
00°0
100
100
00°0
00°0
vs
+149

PYPnnvnvvnvpyprnyoypopn

Om NOM TR NO TNO TM

MOAN NANANONNNAINANINNAN AN AN

4

ETT
ETT
ETT
ETT
CCT
CCT
CCT
CCT
TTT
TTT
TTT
TTT

f

ponunuos LL aqey

pringer

DS
U. Hustadt et al.

 

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
L8°€8
8V' Se
vLL
£9'0
10°0
10°0
00°0
00°0

9023 TaTd

+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

90273 T3aTd
+14

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
£6 98S
69°0CI
86 ST
OT
c0'0
c0'0
10°0
00°0

yderb TaTd

+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

yderz6 T3aTd
+14

O/L
O/L
O/L
O/L
[ey
[ey
[ey
[ey
O/L
O/L
O/L
O/L
VC 8EL
SS°96€
VL COL
6£'0C
vr OV
91 6l
89°
80°0
100
100
100
100
LVS dM
+dey

[rey
[rey
[rey
[rey
O/L
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
LVS dM
+QL4

O/L
O/L
O/L
C8 1s
O/L
O/L
O/L
O/L
L9°C86
cy c9l
10°C8L
OS'Tl
Sel
68°
801
cO'T
ce'0
cs 0
ITO
c0'0
c0'0
10°0
10°0
10°0
COW aM
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
Or IT
L8°6
8c Cl
COW aM
+QL4

PnnnrDyP DI NPD HANDYPDNADYPDPDHANDDPDPD nD

S

COTA NM OF NNO VF NOON OO TI  NCU OO OUlURCLUNC OOO TICLUNCCUL SM

J

bn er ee ce GE Qs Qs Es QQ OO EO OO EL OO EE @ EE QE @ |

4

TTT
TTT
TTT
TTT
TIT
TIT
TIT
TIT
TIT
TIT
TIT
TIT
(onl

(onl

(onl

(onl

(onl

(onl

(onl

(onl

I

I
I
I

f

((9e294) TATA ‘(yYderH) TATA ‘LWS-aM' ‘GOW-aM'T)
JOA[OS "TJ Ue pUe SOTJURUIOS JOLNS-UOU dy} 0} JOodsar YIM UOTJR[SURT) BJO UOTeUIqWIOD IefnNoned ev Aq sulatqoid Sfp DATOS 0} posNbas ‘spuodsas gD UI ‘ouUTUNY ZL ajqeL

pringer

Y)S
1595

Theorem Proving for Metric Temporal Logic Over the Naturals

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

90273 TaTd
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

90273 T3aTd
+14

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

yderb T3aTd
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

yde1rz6 TaTd
+14

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
[rey
[rey
[rey
[rey

LVS adMT
+dey

[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
LVS adMT
+QL4

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

COW aM
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

COW aM'T
+AL4

PYPnnvnvvnvpyprnyoypopn

nA

Om NOM TR NO TNO TM

MOAN NANANNANNAINANANIANAN AN

4

ETT
ETT
ETT
ETT
CCT
CCT
CCT
CCT
TTT
TTT
TTT
TTT

f

ponunuos ZL aqey

pringer

QS
U. Hustadt et al.

 

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
9 19V
vO'c6
O0¢ 08

sovdsib
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
LS'S8
60°87

SSVWdSiL
+AL4

O/L O/L [rey O/L [rey [rey S € C CCT
O/L O/L [rey O/L [rey [rey nN C C CCT
O/L O/L [rey O/L [rey 69°80P nN I C CCT
O/L O/L [rey O/L cre S860 nN 0 C CCT
O/L O/L [rey O/L O/L [66 S € € TUT
O/L O/L [rey O/L vel 10°C S C € TUT
O/L O/L [rey O/L [rey [rey nN I € TUT
O/L O/L [rey O/L 61°9 6S 9 nN 0 € TUT
O/L O/L [rey O/L rit Or'9ole S € C TUT
O/L O/L [rey O/L [rey [rey S C C TUT
O/L O/L [rey O/L OL'TT IT'97E nN I C TUT
O/L O/L [rey O/L 69°C EL'79 nN 0 C TUT
O/L O/L [rey O/L 810 S6O'e S € C CT
O/L O/L [rey O/L 7L'0 [rey S C C CT
O/L O/L [rey O/L Z6'€ LS'€ nN I C CT
O/L O/L [rey O/L 670 pce nN 0 C CT
O/L O/L [rey O/L O10 7901 S € I CT
O/L O/L [rey O/L [rey LS'€] nN C I CT
O/L O/L [rey O/L 070 LL'6 nN I I CT
O/L O/L [rey O/L 90°0 Iv’ nN 0 I CT
O/L O/L O/L O/L 100 06°0 S € I I
O/L O/L O/L O/L 00°0 v0 S Z I I
O/L O/L O/L O/L ZOO 100 S I I I
66° €rI O/L O/L [rey 100 80°0 nN 0 I I
+4+du ++daL UBYIPIATT ueyye lag] eqTeV eqTeV

+ dey +14 +den +14 +dey +d1q S J ¥ L

(SSVdSL ‘++d UL ‘UPYIeETAST ‘eATeV)

JOA[OS "TJ Uv pu SONURUAS JOLNS-UOU oY} 0} OOdsaI YIM UONPISULD v JO UONeUTqUIOD Je[NONJed eB Aq swua[goid Sf 9ATOS 0} posInbal ‘spuodses gD UI ‘aWTMUNY €|1 aqey

pringer

Y)S
1597

Theorem Proving for Metric Temporal Logic Over the Naturals

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

ssvdsib
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

SSVWdSiL
+AL4

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

+4+dub
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

+4+dab
+dLq9

[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey

ULYIVIATT]
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

UvYyIVIATT
+149

[rey
[rey
[rey
[rey
[rey
[rey
[rey
[rey
8e$
[rey
[rey
OS ECC

eqlLeW
+dey

[rey
[rey
[rey
O/L
[rey
[rey
[rey
O/L
[rey
[rey
[rey
S8°L8V

eqaTew
+CdL4

PYPnnvnvvnvpyprnyoypopn

Om NOM TR NO TNO TM

MOAN NANANNANNAINANANIANAN AN

4

ETT
ETT
ETT
ETT
CCT
CCT
CCT
CCT
TTT
TTT
TTT
TTT

f

ponunuos ¢, ajqey

pringer

QS
U. Hustadt et al.

1598

 

cs'0
O/L
O/L
O/L
Le'0
9¢°0
O/L
O/L
L70
Sc0
O/L
O/L
v10
cT0
O/L
[rey
cl‘0
O/L
O/L
O/L
£0°0
£0°0
£0°0
SO'E
OWES ANSTN
+dey

Ic T
[rey
[rey
[rey
ell
ITT
[rey
[rey
960
vo 0
[rey
[rey
£9'0
c9'0
[rey
[rey
OL'0
[rey
[rey
[rey
cc0
e100
cl 0
[rey
OWS ANSON
+149

OT’ 607
SL 8L
VCC
ges
OC 8c9
OT LLC
10°Sc
8V'9
vO9L
LTE
£09
LOC
6s
SIT
6ST
6L°0
19°0
cco 0
8c0
970
S00
S00
S00
10°0

ddd AWSUN

+dey

O/L
O/L
LO 18S
C8°STC
O/L
O/L
O/L
S9'L8
O/L
9S LIT
O/L
O/L
cr vi9
8S VCE
CL VV
8V ve
O/L
VS Ee
SO ICY
TS°19
9E°CS
I¢'c
10°
99°C
ddd AWSUN
+149

910
O/L
O/L
Ie
60°0
cl0
O/L
O/L
90°0
90°0
O/L
760
£00
£00
IL'T
80°0
100
CVE
c0'0
00°0
00°0
00°0
00°0
00°0
vs'l
+dey

cc0
O/L
O/L
O/L
ITO
O10
O/L
O/L
80°0
O10
O/L
LS OTT
v0'0
90°0
9v°0
LO'0
S00
O10
S00
£00
10°0
00°0
00°0
00°0

vs
+QL4

PnnnrDyP DI NPD HANDYPDNADYPDPDHANDDPDPD nD

TTT
TTT
TTT
TTT
TIT
TIT
TIT
TIT
TIT
TIT
TIT
TIT
(onl

(onl

(onl

(onl

(onl

(onl

(onl

(onl

SoA NM OVP NM OV NOM OVI NOOO OO VIC UNCC OO OCU DWITCLUNCCLC lO
bn er ee ce GE Qs Qs Es QQ OO EO OO EL OO EE @ EE QE @ |

S-=cUlUl Ol

J ¥ L

(OWAS-ANSUN ‘Gadd-ANSNN

‘7S'T) JOAlOS TJ Ue pue SOURIS JOLNS-UOU dy} 0} JOOdSaI YM UONPIsUL B JO UOTRUIQUIOD JejNoTVIed B Aq suta[qold Sf] 9ATOS 0} porINbal ‘spuodes YqD Ul ‘oUIUNY pL aqey

pringer

Y)S
1599

Theorem Proving for Metric Temporal Logic Over the Naturals

cO'T

1L'6

O/L

O/L

06°C

LET

ETT

O/L
O/L
O/L
8L°0
O/L
O/L
[rey
OL'0
cL'0
O/L
[rey

OWES ANSTN
+dey

[rey
[rey
[rey
ele
[rey
[rey
[rey
8L'T
SLI
[rey
[rey
OWAS ANSTN
+QL4

O/L
O/L
vr Lel
O/L
O/L
89° COT
OLLI
O/L
O/L
LL’EST
cc OL

ddd AWS UN
+dey

O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L
O/L

add AWSTN
+14

O/L
O/L
O/L
LVv'0
O/L
O/L
O/L
OrV'0
8c 0
O/L
O/L

vs'l
+dey

O/L
O/L
O/L
9L°0
O/L
O/L
O/L
co0
£0
O/L
O/L

vs
+149

PYPnnvnvvnvpyprnyoypopn

nA

Om NOM TR NO TNO TM

ETT
ETT
ETT
CCT
CCT
CCT
CCT
TTT
TTT
TTT
TTT

MAM NANNNANANINANIN ANA N

4 f

ponunuos pL aqey

pringer

QS
1600 U. Hustadt et al.

Strict Semantics Non-Strict Semantics

bTD-+ Aalta

Gap + Aalta

bTD + Leviathan
Gap + Leviathan
bTD+LS4

Gap + LS4

bTD + LWB-MOD
Gap + LWB-MOD
bTD + LWB-SAT
Gap + LWB-SAT
bTD + NuSMV-BDD
Gap +NuSMV-BDD
bTD + NuSMV-SBMC
Gap + NuSMV-SBMC
bTD+ pl1tl (graph)
Gap + pltl (graph)
bTD+pltl (tree)
Gap + pltl (tree)
bTD + TRP++

Gap + TRPtt+

bTD + TSPASS

Gap + TSPASS

 

 

Fig. 6 Heat map for the performance of LTL provers on MJS problems. Each rectangle represents
the runtime of our two encodings of the MJS problem, with runtimes given in colours as follows:

< 0.01 sec > 0.01 sec, < 0.25 sec > 0.25 sec, < 0.50 sec > 0.50 sec, < 1 sec
> 1 sec, < 2 sec > 2 sec, < 4 sec > 4 sec, < 8 sec > 8 sec, < 16 sec
> 16 sec, < 32 sec > 32sec, < 64 sec > 64 sec, < 125 sec > 125 sec, < 250 sec
> 250 sec, < 500 sec > 500 sec, < 1000 sec T/O or Fail

This compares to 53 failures for the strict semantics. So, in both categories the numbers more
than double, resulting only in 213 instances where a combination of a translation with an LTL
solver succeeded within the time given compared to 533 instances with the strict semantics.

Overall, the Non-Strict Gap Translation results in better performance than the Non-Strict
Time Difference Translation: For the 139 MJS problem where an LTL solver can decide its
satisfiability with either the Gap or Time Difference Translation, for 125 of those problems the
Non-Strict Gap Translations results in better performance, for 11 problems the opposite is true
while for just 3 problems the two encodings result in the same performance. The combination
of the Non-Strict Gap Translation and NuSMV-BDD solves the most problems within the time
given, 29 out of 36. Of the seven MJS problems that NuSMV-BDD with the Non-Strict Gap
Translation cannot solve, four can be solved by both LS4 and NuSMV-SBMC, interestingly,
with both the Non-Strict Gap Translation and Non-Strict Time Difference Translation. The
best results can be obtained by a combination of the Non-Strict Gap Translation with a
portfolio consisting of LS4 and NUSMV-BDD.

It is worth pointing out that MJS is not our intended domain of application for the transla-
tions we have presented. There is a lot of symmetry in these problems that a more specialised
solver can take advantage of while LTL solvers are oblivious to it, e.g., the order in which
jobs are executed on a particular machine does not affect the overall time to completion nor
does the choice of machine. However it provides us with a parameterised problem set on
which we can experiment for both semantics. For problems containing less symmetry that
can naturally be formalised in MTL, and for which scheduling or planning is just one part of
it, the approach used here can be beneficial.

In summary, the experimental results presented in this section provide further insights into
the differing behaviour of the Gap Translations and Time Difference Translations on a range
of examples.

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1601

8 Branching Metric Temporal Logic

Combinations of branching temporal logic with quantitative time have been proposed with
continuous semantics [4,8,44] and with discrete semantics [20]. The logic we propose, which
we call CTL, is closely related to the logic Complete Real-Time* Computation Tree Logic
(CRTCTL), presented in [20]. The authors show that the complexity of the satisfiability
problem for CRTCTL is 2EXPTIME-complete. In the following, we show that the satisfia-
bility problem for CTLy is in 2EXPTIME via a translation to CTL. We then explain how to
translate CRTCTL to CTLy, which implies that our upper bound is tight. In this section, our
main goal is to introduce CTLy and show complexity results for this logic. For this purpose
we only need to provide one type of translation. We show that the ‘gap’ translation can be
adapted to the branching time setting, under the strict semantics. One could similarly adapt
the time difference translation and the non-strict semantics from the linear to the branching
case.

We introduce the syntax and semantics of CTL and CTLy. Let P be a (countably infinite)
set of propositional symbols. Well formed formulae in CTL are formed according to the rule:

gy := p|false|@AwW)| -¢e | QOg | Q@Uy)
where p € Pand Qe {E, A}.

As usual, the structure of a CTL model has the shape of an infinite tree. For the purposes
of this work, a tree is a pair T = (W, <) such that (1) ‘<’ is a binary irreflexive and transitive
relation over a non-empty set of nodes W and (ii) for all w € W the set {w’ €e W | w’ < w}
is linearly ordered by ‘<’. It is assumed that T has only one root (i.e. minimal element)
denoted by e. A path z in a tree T = (W, <) starting at a node w € W is a maximal
sequence wow ,... with w) = w and uw; < w;+1, for alli > 0. We use [i] to denote w;. In
the following we assume that our trees have a (countably) infinite number of nodes and that
our paths are infinite sequences of nodes. The semantics of CTL is defined as follows (we
omit propositional cases).

Definition 8 A state tree 0 = (T, 0) is apair consisting of a tree T = (W, <) anda function
o : W — 2? that maps every w € W to aset of propositional symbols in P.
(0, w) F Eog iff dz such that z[0] = w, (0, z[1]) Fe
(0,w) FE(@Uw) iff dam such that z[0] = w, dk EN: (0, 27[k]) Ev;
and Vj € N, (0 < j <k) implies (0, z[j]) FE g
(0,w) EF AO@g iff Vz with z[0] = w, (0, z[1]) EF @
(0,w) FA(@Uw) iff Vz with z[0] = w, dk EN: (0, 7[k]) Ev;
and Vj € N, (0 < j <k) implies (0, z[j]) Fg
Further connectives are defined as: true = —(false), Q(true Uy) = Q(Og), A(QO@) =
=E(oO-¢), E(Ov) = -A(O-@¢@), where Q ¢€ {E, A}. A state tree 9 = (T, 0) is a model of
a CTL formula ¢ iff (0, ¢€) FE g. A CTL formula ¢ 1s satisfiable iff there exists a model of @
and it is valid iff every state tree is a model of it. CTL) formulae are constructed in a way
similar to CTL with the difference that path specific operators are constrained by intervals,
as in MTL. Well formed formulae in CTLy are formed according to the rule:

gy ‘= p|false| GAY) | -¢ | QO7g | Q@euU )
where p € P and Q é€ {E, A}. The semantics of CTLy is defined as follows (we omit
propositional cases).

Definition 9 A timed state tree @ = (T,0,T) over (N, <) is a triple consisting of a tree
T = (W, <), a function o : W — 2? that maps every w € W to a set of propositional

3 Here real-time refers to real time systems, not to the real numbers.

Q) Springer
1602 U. Hustadt et al.

symbols in ?; and a function t : W — N that maps every w € W toa time point tT(w) such
that, for all paths z in T, t(zr[O]) < t(z[1]).

The semantics of temporal connectives is then defined as follows.
(0,w) F EO/g iff dz such that z[0] = w, (e, z[1]) Eg
and t(z[1]) € t(w) +1
(0,w) FE(@U, w) iff dz with z[0] = w, dak E N: t(a[k]) € t(w) + J and
(0, 7[k]) Ew; andVj € N, (0 < j <k) implies
(0, ml) FE ¢
(0,w) F AO Te iff Vzr such that [0] = w, we have (0, z[1]) E g and
t([1]) € tw) +1
(0,w) FA(@U, w) iff Va with z[0] = w, dk Ee N: t([k]) € t(w) + J and
(0, 7[k]) Ew; andVj € N, (0 < j <k) implies
(0, ml) FE ¢
Further connectives are defined as: true = —(false), Q(true U/; y) = Q(O7¢), A(O9) =
=E(o/;-¢), E(O;¢~) = -A(O;-7¢@), where Q € {E, A}. A timed state tree 0 = (T, 0, T)
is a model of a CTL» formula g iff (0, €) FE g. A CTL» formula ¢ is satisfiable iff there
exists a model of g. A CTL» formula ¢ is in Negation Normal Form (NNF) iff the negation
operator (—) occurs only in front of propositional symbols. To transform a CTLm formula
into Negation Normal Form, we use El/; and Al/;, defined as E(g Uy Ww) = -A(-@U] 7)
and A(g Uy w) = -E(-@U -w). A CTL» formula ¢ is in Flat Normal Form (F NF) iff it is
of the form po A /\; A(O)0,00) (pi > Wi)) where po, p; are propositional variables or true
and w; is either a formula of propositional logic or it is of the form QO7W%, Q(W U7 W2) or
QW Uy w2) where 1, W2 are formulae of propositional logic and Q € {K, A}.

8.1 CTLjy to CTL Translation: Encoding ‘Gaps’

Assume that our CTLy formulae are in NNF and FNF. We translate CTL) formulae over
timed state trees into CTL using gap, a fresh propositional symbol, similar to what we did
with our first translation from MTL to LTL. For this, we need to map each timed state tree
o = (T,0o,T) toa state tree 9’ such that @ is a model of a CTLy formula if, and only if, 0’
is a model of our CTL translation. We now define our mappings between CTLy and CTL
models.

Let 0 = (T,0,T) with T = (W, <) be a timed state tree. With every w, w’ € W and
k € Nwe uniquely associate a new node Wey wk) To simplify notation, in the following we
by wgkw’.

denote w’ (w, w!.k)

Definition 10 Given a timed state tree 0 = (T,0,T) with T = (W, <), we define a state
tree (T’, 0’) with T’ = (W’, <’), as follows:
WwW’ = WU {wekw’ |w,w €W,w <w’,1<k <t(w’)—T(w)}.
We call nodes of the form wg*w’ ‘gap’ nodes.* We now define <’ as the transitive closure
of all of the following:
l. w <' we’, if wew’ € W';
2. wekw! <' wekt!w’;
3. wekw!’ <' w’, if wgkt!w’ € W’;
4. w <’w' ifwew’ ¢ W’ andw < w’;

+ We assume that g is a symbol not among those used to represent w € W.
k : 1 _ k+1 _ ogk
g” denotes a sequence of gs of length k, i.e., g° = g and g = gg", for every k > 0.

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1603

E E
Qt teen e eee >e O e
wos, W2
W1 e W2 Qc eee Se 1 @ @
: see >
w3 W4 ggwi Ww2gwa
1B. So 2 , ° °
S | W3
es se 3 e e

Fig.7 Example mapping as in Definition 10

Table 15 CTL, to CTL translation using ‘gap’ where Q € {E, A} and a, f are propositional logic formulae
and c1,c2 > 0

CTLm CTL Gap Translation

(QO}0,00)@)* (QOf1,00)@)*

(QOfeq,00)%)* QO(gapA ... QO(Q(gap U (=gap Aa)))...)
——$_ Ss <4
c ,—1 times

(QOfe},c]@)" QO(gapA ...QO((>gap Aa) Vv (gapA ...QO(>gap A a@)...))...)
—— ee
c, —1 times c2—c 1 times

(QOj0,0)@)" false

(QO0,c51@)" (QOf1,c9]¢)"

(Q(a Ujo,c0) B)) (gap A B) V (Q(@Uf1 00) B))*

(Q(a Ufc, 00) B))* a@ A QO(gap V aA ... QO(Q(gap V «&) U (>gap A B)).--)

c,—1| times
aA QO(gap Va)A ...QWO(-gap A B) V ((gap V a)A
=-e_——n—no-_—_——" —e?k?v.}}k} ke
(Q@ Uc1,co] B))* c,—1 times c2—cy times
...QO(-gap “A B)...))...)

(Q(a Uo,0) B)) agap \ B

(Q(@ Uf0,c5] B))* (=gap A B) A Q(@Ufi,cy] B))*

(E(a U; B))* =(A(=(a) Uz =(B)))

(A(a U; B))® =(E(-(a) Uy =(B)))?

For a ‘gap’ node wg*w’, we define o/(wg* w’) = {gap} and, for w € W, we define o/(w) =
o(w).

Intuitively, in Point (1) we relate a node in W’ to a ‘gap’ node; in Point (2) we relate two
consecutive ‘gap’ nodes; in Point (3) we relate the last of a sequence of ‘gap’ nodes to a node
in W’; finally in Point (4) we relate two non-‘gap’ nodes in W’ if there is no gap between
them, i.e, when t(w’) — tT(w) = 1.

Figure 7 illustrates the mapping given by Definition 10. For instance, if 9 = (T,0,T)
is the timed state tree on the left side of Fig. 7 and o(w 1) = {p} then (0, €) FE EOp,3)p.

Q) Springer
1604 U. Hustadt et al.

Table 15 presents our translation. As shown in Table 15, we translate EOy2,3)p into:
EO(gap \ EO((-gap 4 p) Vv (gap AEO(-gap A p)))).
Note that the state tree represented on the right side of Fig. 7 is a model of this CTL formula.
Since gap is a propositional symbol not occurring in @, the states from W C W’ do not
contain gap.
The next proposition follows straightforwardly from Definition 10.

Proposition 6 Given a timed state tree 90 = (T,0,T), let 0’ be as in Definition 10. Then,
(o', €) F ~gap \ A(O(A07gap)).

Definition 11 Given a state tree 0’ = (T’,o’) with T’ = (W’, <’) such that (9’,¢) &
agap \ A(O(AO-gap)), we define 9 = (T, 0, T), with T = (W, <), as follows. We start
by defining W ando.

W={w|wew’',egap ¢go'(w)} and o(w) =o'(w) forall w € W.
It remains to define t and <. For any distinct w, w’ € W, we define < as the transitive
closure of:

— w < w’ iff there is a path z in T’ such that 2[0] = w and there isk € N with z[k] = w’
and Vj,0 < j <k, gap € o'(x[j]).

To define t, we first set t(€) = 0. Now, for any distinct w < w’ € W, there is a path z in T’
such that [0] = w and there is k € N with z[k] = w’ and V/j,0 < j <k, gap € o'(x[/)).
Observe that such k is unique and we set t(w’) = t(w) +k.

As Q’ is such that (0’,e€) -E mgap A A(a(AQ-¢gap)), for each w € W, we define
t(w) € N. Also, for all z in T, t(a[1]) > t(at[0]), and so, tT : W — N Is well defined. The
following proposition states this property.

Proposition 7 Given a state tree @' such that (o',€) - agap \ AU(AOzgap), let o =
(T, 0, t) be as in Definition 11. Then, t : W — Nisa function such that t(a[0]) < t(a[1]),
for all paths m in T.

We are ready for Theorem 6, which shows correctness of our translation from CTL to CTL
using ‘gap’s.
Theorem 6 Let y = po A /\; A(Oj0,00)(pi > Wi)) be an CTLy formula in NNF and FNF-

Let yp" = po” /\; A(O(p; > (-gap A w?))) be the result of replacing each Wj; in g by ve as
in Table 15. Then, is satisfiable if, and only if, p? Aagap \ A(O(AO-¢gap)) is satisfiable.

Proof ¢ is satisfiable if, and only if, there is a timed state tree @ = (T,0,T) such that
(Qo, €) EK g. Given a timed state tree 9 = (T, 0, T), let op’ = (T’, o’) be as in Definition 10.
By Proposition 6, (9, €) KE agap A A(O(AQ-gap)). By definition of 9’, for all w ¢ W
and all propositional variables p; occurring in o(w), we have (0, w) — p; iff (0’, w) — pj.
With an inductive argument one can show that, for any propositional formula a, (0, w) FE a
iff (o', w) Ea.

Also, g? A agap \ A(a(AO-gap)) is satisfiable if, and only if, there is a state tree
o' = (T, 0’) such that (0’, ¢) KE g* Aagap A A(O(AO-gap)). Given 0’, let o = (T, 0, T)
be a timed state tree as in Definition 11. By Proposition 7, t : W — N is well defined. By
definition of 0, forall w € W’ with gap ¢ o'(w), we have that for p; a propositional variable
occurring in o’(w), (0, w) — p; iff (o’, w) —& p;. As before, an inductive argument lifts
this claim to propositional formulae. That is, for any propositional formula a, (0, w) FE a
iff (o', w) Ea.

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1605

Thus, following our translation in Table 15, we only need to show correspondences
between w; and —gap A we This follows from Claims 7—9 below (other cases are simi-
lar).

In our claims, we use the following bijection between (infinite) paths z in T and zr’ in T’,
which is implied by Definitions 10 and 11: 2 ~ zr’ if, and only if, z[0] = z’[0] and Vj € N,
m[j] = 2’[k], where t(z[j]) — t([0]) = k. We now argue that, for all natural numbers
Cj, C2 with O < cy < co < C, the following claims hold.

Claim7 (0, w) K Ate ce iff (o’, w) E gap A (AO fey ,c910)*.

Proof (0, w) F AOjec,c))@ iff for each wz in T with 2[0] = w, we have t(z[1]) € t(w) +
[c1, c2] and (9, z[1]) EK a. By Definitions 10 and 11, this happens iff there is a zr’ in T’
such that 2 ~ z’ and, fork = t(a[1]) — t(z[0]), (0, z’[k]) EK —gap Aa and Vj € N
with 0 < j < k, (o’,z’[j]) FE gap. Since z was arbitrary, this holds for all such z.
As ~ is a bijection, we obtain this for all such wz’ in T’. Then, (0,w) F AOfe,,c.j@ iff
(o’, w) F mgap A (AOfe}.0)@)*.

Claim8 (0, w) F A(a U{e,,c] B) iff (Q’, w) FE gap A (A(a Ue; ,c9] B))*.

Proof (0,w) — A(a Ure, cy} B) iff for each a in T with w[0] = w, there is k € N such
that t(z[k]) € t(w) + [cj, c2] and (0, z[k]) — 6B; and Vj € N,O < j < k implies
(oe, t[j]) -& a. By Definitions 10 and 11, this happens iff there is a 2’ in T’ such that
ma ~ wm’ and, for k’ = t(a[k]) — t(z[0]), (0’, 2’[k’]) —E gap A B and Vj € N with
0< j < k,(o’,27’'Uj)) —& gap V a. Since mz was arbitrary, this holds for all such z. As
~ is a bijection, we obtain this for all such z’ in T’. Thus, (0, w) F A(a Ufc, 5] B) iff
(o', w) FE agap A (A(a Ufe; cr] B))*.

Claim9 (0, w) K E(@ Ue, ,c9} B) iff (o', w) E gap A (A(A(@) Utes ,e9] 7(B)))*.

Proof By semantics of El, we have that (0,w) FEF E(a Ute .c2] B) iff (0,w) —&
(A(>(@) Ufe;.co] 1(B))). By Claim 8, (0, w) F A(-(@) Ufey,c.) =(B)) iff (e', w)
agap © (A(a Ure, cr] B))*. As (0’, w) E —gap (by definition of (@’, w)), we have that
(o',w) K (A(@ Ufe,co] B))*. Then, (0,w) - E(@ Ufe;,co] B) iff (o', w) - gap A
=(A(>(@) Ufeyc] 7(B)))*. O

Due to the binary encoding of constants, our translation is exponential in the size of
the input. Then, since satisfiability of CTL can be decided in EXPTIME [21], we obtain
2EXPTIME as upper bound of this problem for CTLy. Our lower bound follows from the
fact that we can translate CRTCTL (which is 2EXPTIME-complete), presented in [20], to
CTL». In CRTCTL, the models are the same as in CTL (infinite trees with a labelling function
that maps nodes to propositional symbols) and the syntax extends CTL with formulae of the
form Q(@U=* w) and Q(@U~* wv), where Q € {A, E} andk € N. For example, E(true//> p)
means that there is a path in which p occurs within 5 states from now. In fact, we can see
CRTCTL models as a special case of CTL models where time differences from one state
to another can only be |. Then, one can easily translate CRTCTL formulae into CTLy by
replacing temporal operators U/<* with Ujo,4, and U-* with Ux... For the CTL temporal
operators we add the interval [0, oo). Finally we include AOj0,o0) (Oj1,1;true) to ensure that
the time difference between states is always 1. For example, we translate EO p A A(p us q)
into EOj0,00) p A A(p Ufo,3) 4) A ADjo,oo) (Op, 1)true).

Theorem 7 Satisfiability of CTLy is 2EXPTIME-complete.

Q) Springer
1606 U. Hustadt et al.

9 Related Work

As already mentioned in the introduction, propositional MTL has been proposed in the 90’s
by Alur and Henzinger [6,7] as a formalism for specifying quantitative temporal constraints.
More recently, combinations of MTL with Description Logic [9,29] and Datalog [13,14]
have also been investigated.

Since its proposal, several authors have used MTL to specify problems from a range of
domains (security, robotics, among others). Karaman and Frazzoli use a fragment of MTL
to specify some aspects of Vehicle Routing Problems (VRP) [35]. VRPs are a generalisation
of the traveling salesman problem with a fleet of vehicles leaving from and returning to one
or more departure locations, to delivery locations via a network of communication links e.g.
roads or rail tracks, that also must satisfy certain constraints and minimizes transportation
costs. In the mentioned work, their focus is on Unmanned Aerial Vehicles (UAVs) with target,
launch and landing sites, times spent at the locations, as well as between them and parameters
relating to relative risk for using a particular UAV and the time a UAV can be used without
re-fueling [35]. This is solved by developing a Mixed-Integer Linear Programming (MILP)
algorithm. The style of these problems is very similar to the job-shop scheduling examples
we provided in Sect. 3.3, but an important difference is that problem specifications are not
fully given in a logical formalism. A similar approach is taken by Zhou et al. [59], they
applied a variant of MTL to formalise some constraints in motion planning problems in a
dynamic environment for a UAV and for a car. Again, problems are translated into MILP.

Luo et. al define SMTL, an augmented version of a fragment of MTL, suitable for Schedul-
ing Algorithms [43]. This language differs from ours as it has no next operator and the
semantics is not pointwise. Fragments of SMTL are considered by restricting aspects of the
language so each event can only occur a fixed number of times. They provide examples dis-
cussing how these fragments can be used to specify both Job Shop Scheduling and Temporal
Networks. To find a schedule, a translation is provided into first order temporal logic and
then to Satisfiability Modulo Theory (SMT).

Hoxha et. al describe a tool (Visual Specification Tool, VISPEC) that allows users that
are not expert in logics or MTL to specify problems using a graphical formalism [30].
This is automatically translated into MTL. A usability study of the tool is provided and
two applications relating to robot surgery and quadcopters are presented. The focus is on
specifications rather than satisfiability checking that we consider here.

The robustness of signals modelling or controlling physical processes is considered by
Fainekos and Pappas [22]. Robustness relates to how much a trajectory can be perturbed
without changing the truth value of a specification expressed in the LTL or MTL. This work
is used by Algahtani et. al to consider safety in relation to path planning applied to an
autonomous drone in an adversarial environment where specifications are given in MTL [3].
Robustness is further considered by Abbas et. al in the context of cyber physical systems [2].
They provide a testing framework that returns counterexamples using an MTL specification
that minimises a robustness metric.

Thati and Rosu propose a runtime verification and monitoring approach for checking
MTL formulae over execution traces of algorithms [53]. An algorithm is presented where
both past and future-time MTL formulae are checked against timestamped execution traces.
As we do, the authors also restrict the intervals on temporal operators to be natural numbers
(or infinity) but also allow past-time operators. Models are timed state sequences allowing
real-valued time points. Two subsets of MTL are also considered limiting the specifications
to be checked to past-time MTL formulae and LTL. We note that this is a runtime verification
approach rather than related to theorem proving.

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1607

A runtime verification and monitoring approach using MTL specifications applied to the
security domain is presented by Gunadi and Tiu [28]. In particular, the authors consider the
privilege escalation attack in the Android operating system. A privilege escalation attack
occurs when access services or resources that the attacker doesn’t have permissions for is
obtained. The past-time fragment of MTL is considered and models are based on the natural
numbers and the intervals on temporal operators are natural numbers (where the left hand
side is always 0). Similarly to the work by Thati and Rosu [53], the focus is on presenting
and implementing an algorithm to check formulae over traces along with its application to
the privilege escalation attack.

10 Conclusions

This work considers MTL, a temporal logic that allows timing constraints on the temporal
operators, with a pointwise semantics over the natural numbers. We presented four satisfia-
bility preserving translations from MTL to LTL. The translations using time difference are
based on the MTL decision procedure presented in [6] and use the bounded model property.
Note that the translations using ‘gap’ are proved independently of this property.

Our translations provide a route to practical reasoning about MTL over the naturals via
LTL solvers. We specified examples from robotics, traffic management, and scheduling using
MTL. Modelling these examples showed that using the next operator to specify the timing
constraints on the next state a robot can move into acts a synchronisation point for all robots
in multi-robot systems. Additional care has to be taken using until or eventually operators
with intervals where the left hand side is greater than zero (for example 7/1 3) in the scope of
an always operator 00,00) as this can inadvertently lead to unsatisfiable timing constraints.

For the scheduling example we gave specifications based both on the strict semantics and
on the non-strict semantics of MTL. We then used ten different LTL solvers to explore the
extent these can solve satisfiability problems based on these specifications. Our experiments
seem to indicate that (1) a formalisation based on the non-strict semantics results in poor per-
formance compared to a formalisation based on the strict semantics, (11) for the vast majority
of problems a Gap translation results in better performance than a Time Difference trans-
lation, and (i11) LTL solvers that consistently perform well on translated formulae meaning
a combination of translation and use of an LTL solver provides a viable means for MTL
satisfiability checking and MTL theorem proving.

We have explored the question on what classes of formulae the use of each translation
could be advantageous. We have defined two sets of parametrised formulae and again used
a range of LTL solvers to verify that for one a Gap translation results in better performance
while for the other the Time translation leads to better performance.

We also introduced an branching-time variant of MTL and provided a translation using
‘gaps’ into the branching-time temporal logic CTL. This opens up the opportunity to use
CTL solvers such as [58] in a similar way as we have done for LTL solvers.

As future work, we intend to investigate whether we can translate PDDL3.0 statements
[25] into MTL and apply our translations to the planning domain.

Open Access This article is licensed under a Creative Commons Attribution 4.0 International License, which
permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give
appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence,
and indicate if changes were made. The images or other third party material in this article are included in the
article’s Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is

Q) Springer
1608 U. Hustadt et al.

not included in the article’s Creative Commons licence and your intended use is not permitted by statutory
regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder.
To view a copy of this licence, visit http://creativecommons.org/licenses/by/4.0/.

References

we

10.

11.

12.

13.

14.

15.

16.

17.

18.

19.

20.

. Aalta. http://lab205.org/aalta/
. Abbas, H., Fainekos, G., Sankaranarayanan, S., Ivanci¢, F., Gupta, A.: Probabilistic temporal logic fal-

sification of cyber-physical systems. ACM Trans. Embedded Comput. Syst. (TECS) 12(2s), 95:1—95:30
(2013). https://doi.org/10.1145/2465787.2465797

. Algahtani, S., Riley, I., Taylor, S., Gamble, R., Mailler, R.: MTL robustness for path planning with A*.

In: André, E., Koenig, S., Dastani, M., Sukthankar, G. (eds.) International Foundation for Autonomous
Agents and Multiagent Systems, AAMAS 2018, pp. 247-255 (2018)

. Alur, R., Courcoubetis, C., Dill, D.L.: Model-checking in dense real-time. Inf. Comput. 104(1), 2-34

(1993). https://doi.org/10.1006/inco.1993.1024

. Alur, R., Feder, T., Henzinger, T.A.: The benefits of relaxing punctuality. J. ACM 43(1), 116-146 (1996).

https://doi.org/10.1145/227595.227602

. Alur, R., Henzinger, T.A.: Real-time logics: complexity and expressiveness. Inf. Comput. 104(1), 35-77

(1993). https://doi.org/10.1006/inco.1993.1025

. Alur, R., Henzinger, T.A.: A really temporal logic. J. ACM 41(1), 181-204 (1994). https://doi.org/10.

1145/174644.174651

. Alur, R., Henzinger, T.A., Ho, P.: Automatic symbolic verification of embedded systems. [EEE Trans.

Softw. Eng. 22(3), 181-201 (1996). https://doi.org/10.1109/32.489079

. Baader, F., Borgwardt, S., Koopmann, P., Ozaki, A., Thost, V.: Metric temporal description logics with

interval-rigid names. In: Dixon, C., Finger, M. (eds.) FroCoS 2017, LNCS, vol. 10483, pp. 60-76 (2017).
https://doi.org/10.1007/978-3-319-66167-4_4

Bersani, M.M., Rossi, M., San Pietro, P.: A tool for deciding the satisfiability of continuous-time metric
temporal logic. Acta Inform. 53(2), 171-206 (2016). https://doi.org/10.1109/TIME.2013.20

Bertello, M., Gigante, N., Montanari, A., Reynolds, M.: Leviathan: a new LTL satisfiability checking
tool based on a one-pass tree-shaped tableau. In: Kambhampati, S. (ed.) IMCAI 2016, pp. 950-956.
IJCAI/AAAI Press, Menlo Park (2016)

Bouyer, P., Markey, N., Ouaknine, J., Worrell, J.: The cost of punctuality. In: LICS 2007, pp. 109-120.
IEEE (2007). https://doi.org/10.1109/LICS.2007.49

Brandt, S., Kalayci, E.G., Kontchakov, R., Ryzhikov, V., Xiao, G., Zakharyaschev, M.: Ontology-based
data access with a Horn fragment of metric temporal logic. In: Singh, S., Markovitch, S. (eds.) AAAT
2017, pp. 1070-1076. AAAI Press, Menlo Park (2017)

Brandt, S., Kalayci, E.G., Ryzhikov, V., Xiao, G., Zakharyaschev, M.: Querying log data with metric
temporal logic. J. Artif. Intell. Res. 62, 829-877 (2018). https://doi.org/10.1613/jair.1.11229

Cimatti, A., Clarke, E.M., Giunchiglia, E., Giunchiglia, F., Pistore, M., Roveri, M., Sebastiani, R., Tac-
chella, A.: NuSMV 2: An OpenSource tool for symbolic model checking. In: Brinksma, E., Larsen, K.G.
(eds.) CAV 2002, LNCS, vol. 2404, pp. 359-364. Springer, Berlin (2002). https://doi.org/10.1007/3-540-
45657-0_29

Dauzére-Pérés, S., Paulli, J.: An integrated approach for modeling and solving the general multiprocessor
job-shop scheduling problem using tabu search. Ann. Oper. Res. 70, 281-306 (1997). https://doi.org/10.
1023/A:1018930406487

Dixon, C., Fisher, M., Konev, B.: Temporal logic with capacity constraints. In: Konev, B., Wolter, F. (eds.)
FroCoS 2007, LNCS, vol. 4720, pp. 163-177. Springer, Berlin (2007). https://doi.org/10.1007/978-3-
540-74621-8_11

Dixon, C., Webster, M., Saunders, J., Fisher, M., Dautenhahn, K.: “The Fridge Door is Open’—temporal
verification of a robotic assistant’s behaviours. In: Mistry, M., Leonardis, A., Witkowski, M., Melhuish,
C. (eds.) TAROS 2014, LNCS, vol. 8717, pp. 97-108. Springer, Berlin (2014). https://doi.org/10.1007/
978-3-319-10401-0_9

Duque, I., Dautenhahn, K., Koay, K.L., Willcock, L., Christianson, B.: Knowledge-driven user activity
recognition for a smart house - development and validation of a generic and low-cost, resource-efficient
system. In: Miller, L. (ed.) ACHI 2013, pp. 141-146. IARIA XPS Press, Wilmington (2013)

Emerson, E., Mok, A., Sistla, A., Srinivasan, J.: Quantitative temporal reasoning. Real-Time Syst. 4(4),
331-352 (1992). https://doi.org/10.1007/BF00355298

Q) Springer
Theorem Proving for Metric Temporal Logic Over the Naturals 1609

21.

22.

23.

24.

25.

26.

27.
28.

29.

30.

31.

32.

33.

34.
35.
36.
37.
38.
39.
40.
4].
42.

43.

44,

45.
46.

Emerson, E.A., Halpern, J.Y.: Decision procedures and expressiveness in the temporal logic of branching
time. In: Lewis, H.R., Simons, B.B., Burkhard, W.A., Landweber, L.H. (eds.) STOC 1982, pp. 169-180.
ACM, New York (1982)

Fainekos, G.E., Pappas, G.J.: Robustness of temporal logic specifications for continuous-time signals.
Theor. Comput. Sci. 410(42), 4262-4291 (2009). https://doi.org/10.1016/j.tcs.2009.06.021

Fisher, M.: A normal form for temporal logics and its applications in theorem-proving and execution. J.
Logic Comput. 7(4), 429-456 (1997)

Gabbay, D., Pnueli, A., Shelah, S., Stavi, J.: On the temporal analysis of fairness. In: Abrahams, P.W.,
Lipton, R.J., Bourne, S.R. (eds.) POPL 1980, pp. 163-173. ACM, New York (1980). https://doi.org/10.
1145/567446.567462

Gerevini, A., Haslum, P., Long, D., Saetti, A., Dimopoulos, Y.: Deterministic planning in the fifth interna-
tional planning competition: PDDL3 and experimental evaluation of the planners. Artif. Intell. 173(5-6),
619-668 (2009). https://doi.org/10.1016/j.artint.2008.10.012

Goré, R.: And-or tableaux for fixpoint logics with converse: LTL, CTL, PDL and CPDL. In: Demri, S.,
Kapur, D., Weidenbach, C. (eds.) IJCAR 2014, LNCS, vol. 8562, pp. 26-45. Springer, Berlin (2014).
https://doi.org/10.1007/978-3-319-08587-6_3

Graham, R.L.: Bounds for certain multiprocessing anomalies. Bell Labs Tech. J. 45(9), 1563-1581 (1966)
Gunadi, H., Tiu, A.: Efficient runtime monitoring with metric temporal logic: a case study in the Android
operating system. In: Jones, C., Pihlajasaari, P., Sun, J. (eds.) FM 2014, LNCS, vol. 8442, pp. 296-311.
Springer, Berlin (2014). https://doi.org/10.1007/978-3-319-06410-9_21

Gutiérrez-Basulto, V., Jung, J.C., Ozaki, A.: On metric temporal description logics. In: Kaminka, G.A.,
Fox, M. (eds.) ECAI 2016, Frontiers in Artificial Intelligence and Applications, vol. 285, pp. 837-845.
IOS Press, Amsterdam (2016). https://doi.org/10.3233/978- 1-61499-672-9-837

Hoxha, B., Mavridis, N., Fainekos, G.: VISPEC: A graphical tool for elicitation of MTL requirements.
In: IROS 2015, vol. 2015-December, pp. 3486-3492. IEEE, New York (2015). https://doi.org/10.1109/
IROS.2015.7353863

Hustadt, U., Dixon, C., Ozaki, A.: Mtl: Tools and experiments. University of Liverpool, Liverpool http://
cgi.csc.liv.ac.uk/~ullrich/MTL (2019)

Hustadt, U., Konev, B.: TRP™T 2.0: a temporal resolution prover. In: Baader, F. (ed.) Proceedings of the
CADE-19, LNCS, vol. 2741, pp. 274-278. Springer, Berlin (2003). https://doi.org/10.1007/978-3-540-
45085-6_21

Hustadt, U., Ozaki, A., Dixon, C.: Theorem proving for metric temporal logic over the naturals. In: de
Moura, L. (ed.) CADE-26, LNCS, vol. 10395, pp. 326-343. Springer, Berlin (2017). https://doi.org/10.
1007/978-3-319-63046-5_20

Janssen, G.: Logics for digital circuit verification: Theory, algorithms, and applications. Ph.D. thesis,
Eindhoven University of Technology, Eindhoven (1999)

Karaman, S., Frazzoli, E.: Vehicle routing problem with metric temporal logic specifications. In: CDC
2008, pp. 3953-3958. IEEE (2008). https://doi.org/10.1109/CDC.2008.4739366

Leviathan. https://github.com/Corralx/leviathan

Li, J., Yao, Y., Pu, G., Zhang, L., He, J.: Aalta: an LTL satisfiability checker over infinite/finite traces.
In: Cheung, S.C., Orso, A., Storey, M.A.D. (eds.) SIGSOFT FSE 2014, pp. 731-734. ACM, New York
(2014). https://doi.org/10.1145/2635868.2661669

Liu, W., Winfield, A.: Modelling and optimisation of adaptive foraging in swarm robotic systems. Int. J.
Robot. Res. 29(14), 1743-1760 (2010)

Logics Workbench. http://www.lwb.unibe.ch/index.html

LS4. https://github.com/quickbeam 123/1s4

Ludwig, M., Hustadt, U.: Resolution-based model construction for PLTL. In: Lutz, C., Raskin, J. (eds.)
TIME 2009, pp. 73-80. IEEE, New York (2009). https://doi.org/10.1109/TIME.2009. 11

Ludwig, M., Hustadt, U.: Implementing a fair monodic temporal logic prover. AI Commun. 23(2-3),
69-96 (2010)

Luo, R., Valenzano, R.A., Li, Y., Beck, J.C., MclIlraith, S.A.: Using metric temporal logic to specify
scheduling problems. In: Baral, C., Delgrande, J.P., Wolter, F. (eds.) KR 2016, pp. 581-584. AAAI Press,
Menlo Park (2016)

Mohammed, A., Furbach, U.: MAS: qualitative and quantitative reasoning. In: Dennis, L., Boissier, O.,
Bordini, R.H. (eds.) ProoOMAS 2011, LNCS, vol. 7217, pp. 114-132. Springer, Berlin (2011). https://doi.
org/10.1007/978-3-642-31915-0_7

NuSMV. http://nusmy.fbk.eu/

Ouaknine, J., Worrell, J.: Some recent results in metric temporal logic. In: Cassez, F., Jard, C. (eds.)
FORMATS 2008, LNCS, vol. 5215, pp. 1-13. Springer, Berlin (2008). https://doi.org/10.1007/978-3-
540-85778-51

Q) Springer
1610 U. Hustadt et al.

47.
48.

49.

50.

51.

52.

53.
54.
55.

56.
57.

58.

59.

plt1. http://users.cecs.anu.edu.au/~rpg/PLTLProvers/

Pnueli, A.: The temporal logic of programs. In: Proceedings of the SFCS ’77, pp. 46-57. IEEE (1977).
https://doi.org/10.1109/SFCS.1977.32

Reynolds, M.: A new rule for LTL tableaux. In: D. Cantone, G. Delzanno (eds.) GandALF 2016, EPTCS,
vol. 226, pp. 287-301 (2016). https://doi.org/10.4204/EPTCS.226.20

Schwendimann, S.: A new one-pass tableau calculus for PLTL. In: de Swart, H.C.M. (ed.) TABLEAUX
1998, LNCS, vol. 1397, pp. 277-292. Springer, Berlin (1998)

Sistla, A.P., Clarke, E.M.: The complexity of propositional linear temporal logics. J. ACM 32(3), 733-749
(1985). https://doi.org/10.1145/3828.3837

Suda, M., Weidenbach, C.: A PLTL-prover based on labelled superposition with partial model guidance.
In: Gramlich, B., Miller, D., Sattler, U. (eds.) ICAR 2012, LNCS, vol. 7364, pp. 537-543. Springer,
Berlin (2012). https://doi.org/10.1007/978-3-642-31365-3_42

Thati, P., Rosu, G.: Monitoring algorithms for metric temporal logic specifications. Electron. Notes Theor.
Comput. Sci. 113, 145-162 (2005)

TRPTT . http://cgi.csc.liv.ac.uk/~konev/software/trp++/

Tseitin, G.S.: On the complexity of derivation in propositional calculus. In: Siekmann, J.H., Wrightson,
G. (eds.) Automation of Reasoning, vol 2: Classical Papers on Computational Logic 1967-1970, pp.
466-483. Springer, Berlin (1983)

TSPASS. http://cgi.csc.liv.ac.uk/~michael/TLBook/TSPASS-System/

Webster, M., Dixon, C., Fisher, M., Salem, M., Saunders, J., Koay, K.L., Dautenhahn, K., Saez-Pons,
J.: Toward reliable autonomous robotic assistants through formal verification: a case study. IEEE Trans.
Hum. Mach. Syst. 46(2), 186-196 (2016). https://doi.org/10.1109/THMS.2015.2425139

Zhang, L., Hustadt, U., Dixon, C.: A resolution calculus for the branching-time temporal logic CTL.
ACM Trans. Comput. Log 15(1), 10:1-—10:38 (2014). https://doi.org/10.1145/2529993

Zhou, Y., Maity, D., Baras, J.S.: Optimal mission planner with timed temporal logic constraints. In: ECC
2015, pp. 759-764. IEEE, New York (2015). https://doi.org/10.1109/ECC.2015.7330634

Publisher’s Note Springer Nature remains neutral with regard to jurisdictional claims in published maps and
institutional affiliations.

Q) Springer
