Abikoye et al. EURASIP Journal on Information Security
https://doi.org/10.1186/s13635-020-001 13-y

(2020) 2020:14

EURASIP Journal on
Information Security

RESEARCH Oy else =e

A novel technique to prevent SQL injection
and cross-site scripting attacks using

Check for
updates

 

Knuth-Morris-Pratt string match algorithm

Oluwakemi Christiana Abikoye', Abdullahi Abubakar’, Ahmed Haruna Dokoro”, Oluwatobi Noah Akande® ® and

Aderonke Anthonia Kayode®

Abstract

Structured Query Language (SQL) injection and cross-site scripting remain a major threat to data-driven web
applications. Instances where hackers obtain unrestricted access to back-end database of web applications so as to
steal, edit, and destroy confidential data are increasing. Therefore, measures must be put in place to curtail the growing
threats of SOL injection and XSS attacks. This study presents a technique for detecting and preventing these threats
using Knuth-Morris-Pratt (KMP) string matching algorithm. The algorithm was used to match user's input string with
the stored pattern of the injection string in order to detect any malicious code. The implementation was carried out
using PHP scripting language and Apache XAMPP Server. The security level of the technique was measured using
different test cases of SOL injection, cross-site scripting (XSS), and encoded injection attacks. Results obtained revealed
that the proposed technique was able to successfully detect and prevent the attacks, log the attack entry in the
database, block the system using its mac address, and also generate a warning message. Therefore, the proposed
technique proved to be more effective in detecting and preventing SOL injection and XSS attacks

Keywords: SOL injection, Cross-site scripting, Information security, Web application vulnerability, Knuth-Morris-Pratt
(KMP) string matching algorithm

1 Introduction

Internet is fast becoming a household technology with
4.39 billion users in January 2019 compared to 3.48
billion users in January 2018 [1]. This showed that
more than one million new users got connected daily.
This growth rate is being facilitated by data-driven
web applications and services which enable users to
transact their online activities with ease. Most modern
organizations and individuals heavily rely on these
web applications to reach out to their numerous cus-
tomers. Users’ inputs via web applications are used to
query back end databases so as to provide the needed
information. This trend has therefore opened up web

 

* Correspondence: akande.noah@lmu.edu.ng

*Computer Science Department, Landmark University, Kwara State,
Omu-Aran, Nigeria

Full list of author information is available at the end of the article

o) Springer Open

 

applications and services to attacks by hackers. More-
over, the popularity of web application in social net-
working, financial transaction, and health problems
are increasing very rapidly; as a result, software vul-
nerabilities are becoming very critical issues, and thus,
web security has now become a major concern [2].
The vulnerabilities are mostly application layer vul-
nerabilities such as domain name server attacks,
Inline Frame flaws, remote file inclusion, web authen-
tication flaws, remote code execution, XSS, and SQL
injection [3, 4]. A survey carried out by Open Web
Application Security Project (OWASP) identified top
10 vulnerabilities as at June 2019 to be injection
flaws, broken authentication and session management,
sensitive data exposure, XML external entity, broken
access control, security misconfiguration, XSS, inse-
cure deserialization, using components with known

© The Author(s). 2020 Open Access This article is licensed under a Creative Commons Attribution 4.0 International License,
which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give
appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if

changes were made. The images or other third party material in this article are included in the article's Creative Commons
licence, unless indicated otherwise in a credit line to the material. If material is not included in the article's Creative Commons
licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain
permission directly from the copyright holder. To view a copy of this licence, visit http://creativecommons.org/licenses/by/4.0/.
Abikoye et al. EURASIP Journal on Information Security

vulnerabilities, insufficient logging, and monitoring.
However, among these forms of attacks, XSS and
SQL injection have been identified as the most
dangerous [5]. The WordPress Security Learning Cen-
ter also submits that if SQL injection and XSS vul-
nerabilities could be handled in a code, then 65%
vulnerabilities has been eliminated. Since web applica-
tions use data supplied by users in SQL queries,
hackers can manipulate these data and insert SQL
meta-characters into the input fields so as to access,
modify, or delete the content of the database. For in-
stance, the WHERE clause in the SQL query SELE
CT*FROM users WHERE password = 1234 could be
manipulated when hackers supply inputs like ‘any-
thing’ OR ‘1’ = ‘13 # The WHERE clause now con-
tains two conditions separated with the logical
operator OR. The first condition might not be TRUE,
but the second condition must be TRUE because 1 is
always equals 1, and the logical operator “OR” returns
TRUE if either or both of the conditions are TRUE.
Hence, the hacker gains access without a need to
know the password. Sometimes, wrong input values
can also be supplied intentionally so that error mes-
sages that will help the attackers to understand the
database schema will be revealed. Therefore, SQL in-
jection is a serious threat for web application users.

1.1 Cross-site scripting (XSS) attacks

XSS is another similar attack where hackers prepare and
execute a fragment of JavaScript in the security context
of the targeted domain thereby incorporating malicious
contents into web pages presented by a trusted web ap-
plication. Most web applications that do not properly
screen user input before loading web pages are suscep-
tible to XSS attacks. Once a site has been affected, users
could be redirected to automatically open malicious
websites, the entire user session could be hijacked, and
users’ login details could also be stolen. Since the con-
tent is claimed to be from a trusted server, it is proc-
essed like normal contents. For example, the pseudo
code below shows how latest comments are displayed on
a website using a simple sever-site script:

echo" < html >< body >";
echo" < h1 > Most recent comments </h1 >";
echo database. latestComment;

echo" </html ></body >";

The scripts assume that the comments consist of only
text. However, since the user’s input is directly included,
an attacker can submit his comment as “<script>

(2020) 2020:14

Page 2 of 14

doSomethingEvil();</script>”. Therefore, users who visit
the page will receive the following response:

echo" < html >< body >";
echo" < h1 > Most recent comments </h1 >";
echo" < script > doSomethingEvil(); </script >";

echo" </html ></body >";

When the user’s browser loads the page, it executes
whatever JavaScript is contained inside the <script >
tags. In this case, the attacker can write a JavaScript
function that steals the victim’s session cookie. This ses-
sion cookie can be used to impersonate the victim
subsequently.

XSS vulnerabilities have been categorized into three
categories which are reflected, stored, and Document
Object Model (DOM)-based [3]. DOM-based vulnerabil-
ities occur when active contents on a web page (mostly
JavaScript) accept user inputs which are malicious
thereby causing the execution of injected code. Stored
XSS vulnerabilities occur when inputs collected via web
applications are malicious and stored in the database for
immediate or future use. It is one of the most dangerous
of all XSS vulnerabilities because in as much as it is in
the database, the hacker can manipulate the contents of
the database at will [1]. Reflected XSS vulnerabilities are
different from other XSS vulnerabilities because it at-
tacks clients who accesses or loads a malicious URL.
Though several techniques aimed at curtailing the grow-
ing hazards of these attacks have been reported in litera-
ture, many have not been able to fully address all scope
of the problem. Several security techniques have been
proposed towards preventing data and information from
unauthorized attacks [6-8], and attackers continually de-
vise new security vulnerabilities that could be exploited.
Therefore, new techniques aimed at detecting and pre-
venting these attacks are essential.

1.2 SQL injection attacks
SQL-injection attacks could be in six categories:

a) Boolean-based SQL injection or tautology attack:

Boolean values (True or False) are used to carry out
this type of SQL injection. The malicious SQL query
forces the web application to return a different result de-
pending on whether the query returns a TRUE or
FALSE result. For instance, "aaa O R 2=2" has been
inserted into SQL query "SELECT «FROM users
WHERE password = aaa OR 2 = 2" as the password so
as to alter the structure of the WHERE clause of the
Abikoye et al. EURASIP Journal on Information Security

original query. This yields a SQL query with two differ-
ent conditions separated with a logical operator OR. The
first condition "password = aaa" might not be true, but
the second condition “2 = 2” must be true. Therefore,
the logical operator OR returns true if at least one of the
operand is true thereby forcing the web application to
return a different result.

b) Union-based SQL injection: this is the most popular
of all the SQL injections. It uses the UNION
statement to integrate two or more select
statements in a SQL query thereby obtaining data
illegally from the database. For instance, in the SQL
query "SELECT « FROM customers WHERE
password = 123 UNION SELECT creditCardNo, pin
FROM customers’ the attacker injects the SQL
statement "123 UNION SELECT creditCardNo, pin
FROM customers" instead of the required password.
The query therefore exposes all the credit card
numbers with their PINs from the customer’s table.

c) Error-based SQL injection: this is the simplest of all
the SQL injection vulnerabilities; however, it only
affects web applications that use MS-SQL Server.
The most common form of this vulnerability re-
quires an attacker to supply an SQL statement with
improper input causing a syntax error such as pro-
viding a string when the SQL query is expecting an
integer. For example, the SQL query: SELECT *
FROM customer WHERE pin = convert (int, (SELE
CT firstName FROM customer LIMIT 1)) tries to
convert the first name of the first customer in the
customer's table into integer type which is not pos-
sible. As a result, it causes the database server to
throw an error containing the information about
the structure of the table.

d) Batch query SQL injection/piggy backing attacks:
this form of injection is dangerous as it attempts to
take full control of the database. An attacker
terminates the original query of the application and
injects his own query into the database server. For
instance, considering the SQL query: aaa; INSERT
INTO users VALUES (‘Abubakar’, ‘1234’);#, the first
semicolon (;) terminates the original query, and
query adds the username “Abubakar ” and password
“1234” to the users table ,and the hash (#)
comments out the remaining query so that it will
not be executed by the server. However, this form
of attack works on only SQL-Server 2005, because
it is the only server that accepts multiple queries at
a time.

e) Like-based SQL injection. This injection type is
used by hackers to impersonate a particular user
using the SQL keyword LIKE with a wildcard
operator (%). For instance, an attacker can inject

(2020) 2020:14

Page 3 of 14

input: “anything OR username LIKE ‘S%’ ;# instead
of a username to have SQL query: SELECT *
FROM users WHERE username =’ anything OR
username LIKE ‘S%7 #”. The LIKE operator
implements a pattern match comparison, that is, it
matches a string value against a pattern string
containing wildcard character. The query searches
the user’s table and returns the records of the users
whose username starts with letter S. The wildcard
operator (%) means zero or more characters (S...),
and it can be used before or after the pattern.

f) Hexadecimal/decimal/binary variation attack
(encoded injection): in this type of injection, the
hacker leverages on the diversity of the SQL
language by using hexadecimal or decimal
representations of the keywords instead of the
regular strings and characters of the injection code.
For instance, the traditional SQL injection code:
UNION SELECT * FROM users; # could be replaced
with:

"RHXZ3IRHXES QHX7 BRHX7 3RHX7 IRHX7 BRHX32LHXB3RHX6IRHX76
SHX69RH#X67RHXB4ARHX3Z2RHX4AZRHX3Z2R#HXTORHXB2ZRHX7TIQHXT7
RHXZ2ZR#X117RHX115 &#x101 R#xX1148#x1158&#x59R#x35'

Therefore, SQL injection vulnerability is a serious at-
tack that must be prevented. Its different categories have
further revealed that a prevention technique that works
for a specific category may not perfectly work for an-
other category. This has made the quest to eradicate
SQL injection vulnerabilities an open field of research.

2 Related works

As documented in literature, preventing SQL injection
vulnerabilities as well as XSS attacks has been mostly
achieved through the use of data encryption algo-
rithms, PHP escaping functions, pattern matching al-
gorithms, and through instruction set randomization.
Authors in [9] employed SHA-1 hashing algorithm to
prevent batch query SQL injections. It works by
extracting query attribute values from the stored in-
puts; these were hashed using SHA-1 hashing algo-
rithm. After that, any other input will also be hashed
and compared with the initially hashed stored input
before further execution. If the compared hashed in-
put is the same, then the SQL query will be executed
otherwise rejected. With this technique, erroneous in-
puts cannot be processed directly by the SQL query,
and an attempt to fetch stored inputs values will re-
turn hashed values that are already encrypted. Simi-
larly, Boyer-Moore string matching algorithm for SQL
injection attacks detection and prevention was intro-
duced by authors in [10]. Input values are scanned
Abikoye et al. EURASIP Journal on Information Security

for possible attributes of SQL injection attacks. A hy-
brid approach which leverages on the strengths of
static and dynamic approach to detecting and pre-
venting SQL injection was proposed by Ghafarian.
Static approach attempts to find fault in the written
SQL query (database layer) while dynamic approach
finds vulnerabilities that could be present at runtime
(common gateway interface layer). Firstly, an algo-
rithm was written to match strings from input SQL
query to stored SQL query. The result obtained was
matched with the expected valid query. Any observed
vulnerability will cause the query to be discarded. For
the dynamic approach, an algorithm was proposed to
examine incoming queries dynamically. Once a vul-
nerability is detected, the query will be discarded.

Authors in [11] proposed a technique for preventing
SQL injection and XSS attack. Web applications were
categorized into two: those whose query does not change
regardless of the time, and parameter were classified as
static while those whose query change due to time or
data passed into it were called dynamic web
applications. Static and dynamic mapping model were
used to detect and prevent vulnerabilities from both cat-
egories. Similar technique using Aho—Corasick pattern
matching technique was proposed by Prabakar et al. Au-
thors in [12] employed instruction set randomization to
prevent second-order SQL injection. The technique dy-
namically builds SQL instruction sets from trusted SQL
keywords. Input SQL query was saved into a proxy ser-
ver and not directly into the database. Therefore, the
contents of the proxy server will be examined for any
malicious stings. However, the technique can only pre-
vent Boolean-based SQL injection attack. Similar tech-
nique using instruction set randomization was also
reported in [13-15]

Similarly, a technique to prevent SQL injection
using ASCII codes was proposed by Srivastava. User’s
input was first converted to ASCII values before sav-
ing them in the database. Subsequent input will be
converted to ASCII values and matched with stored
ASCII values. Should there be any difference, the in-
put SQL query will be discarded. Similarly, parse tree
validation technique and code conversion were pro-
posed for detecting SQL injection and XSS attacks in
[16]. Parse tree was employed to check if user’s input
is vulnerable; if not vulnerable, the input will be con-
verted to ASCII code before being stored in the data-
base. However, ASCII code conversion consumes
space, and the technique cannot handle encoded SQL
injection. Ramesh [17] employed syntactic analysis for
SQL injection detection and prevention. Every input
SQL query will be parsed through a grammar specif-
ically written to detect piggy backed SQL, tautology
queries, and union queries. However, the proposed

(2020) 2020:14

Page 4 of 14

Table 1 Special characters used to compose SOL-injection code
S/N Character

 

Description

 

—

Character string indicator

2 -- or # Single line comment

3 /*..*/ Multiple line comment

4 % Wildcard attribute indicator
5 Query terminator

6 + or || String concatenate

7 = Assignment operator

8 >, <, <=, >=, ==, <> or!l= Comparison operators

 

technique was not designed to handle other forms of
SQL injections and XSS attacks. SHA-1 Hashing tech-
nique was also proposed in [18]. to prevent SQL in-
jection and session hijacking. A unique hash value
was calculated for user’s input supplied during regis-
tration which is then compared with subsequent login
details provided. Additionally, session hijacking was
prevented by generating hash values for legitimate
system and browser parameters such as_ browser
name, host IP browser platform, and version. This
hash value will be compared with subsequent values
supplied. The technique was reported to be able to
prevent UNION, error-based, piggy backing, and tau-
tology attacks. Signature-based approach that con-
ducts deep packet inspection of HTTP packet
payloads was proposed in [19]. Packets sent between
clients and server are screened for possible malicious
keywords. Filtering technique that uses certain PHP
functions was employed for SQL injection and XSS
attack prevention by Voitovych et al [20]. All user’s

Table 2 Keywords used to compose SOL-injection code

 

 

 

S/. Keyword — Description

N

1 OR Used in Boolean-based injection attack

2 UNION Used in union-based injection attack

3. DROP Used to destroy the entire database table

4 DELETE Used to delete rows in a database table

5 TRUNCATE Used to empty a particular table in a database

6 SELECT Used to retrieve record from a database table

7 UPDATE Used to modify record in a database table

8 — INSERT Used to add record to a table in a database

Q LIKE Used with the wildcard (%) to select a record that

contains a particular string pattern.

10 CONVERT( Used in error-based SQL injection to causes the data-

) base server to displays some error messages.

 
Abikoye et al. EURASIP Journal on Information Security

(2020) 2020:14

Page 5 of 14

Table 3 Different forms of injection code with their common patterns

 

 

S/N Injection type Common pattern Example
1 Boolean-based "OR'... =| >| >=) < |< =|<>]l='...4# "OR ‘1! = ‘1H
123’ OR ‘a’ <> ‘b’ i#
"OR '2 + 3' < ='10' i#
2 Union-based ‘union select ... from ...;# ‘union select * from users; #
‘union select name from a;#
3 Error-Based "...convert ( |avg( | round(.. 111’ convert(int, ‘abcd’)
A’ avg('&%S#@*’)
4 Batch query '; drop | delete | insert | truncate | update | select... .;# aaa’ ; delete * from users; #
‘; drop table users; #
5 Like-based ‘OR ... LIKE '...%'# “OR username LIKE 'S%'#
6 XSS <script> ...'...;</script> <script>alert(Xss’);</script>

 

input will be filtered for any illegal characters before
further processing.

3 The proposed detection and prevention
technique

With a view to come up with a technique that could de-
tect and prevent the various forms of SQL injection and
XSS attacks, the patterns for each attack were studied,
and solutions were proffered based on these patterns.
The methodology employed in this study is in five
phases: formation of SQL injection string pattern, de-
signing parse tree for the various forms of attacks, de-
tecting SQL-injection and XSS attacks, preventing SQL-
injection and XSS attacks using KMP algorithm, and for-
mulating the filter functions.

3.1 Formation of SQL injection string patterns

Every form of attacks has certain characters and key-
words that hackers do manipulate to perpetuate their at-
tacks. These are retrieved and documented as made
available in Tables 1 and 2.

These characters and keywords are used to form mali-
cious codes that are used to carry out the various forms
of attacks. Identifying these injection codes will help in
coming up with how to detect and prevent these attacks.
The injection codes common to the various forms of at-
tacks are provided in Table 3.

3.2 Designing parse tree for the various forms of attacks
Parse tree was used to represent the syntactic pattern of
the various forms of SQL-Injection and Cross Site
Scripting attacks. The parse trees are as follows:

(i). Boolean-based SQL injection attacks

start:
input: array of characters S (the text to be searched) and array of characters W (the word sought)
output: array of integers P (positions in S at which W is found); an integer nP (number of positions)
define variables:
an integer j <— 0 (the position of the current character in S)
an integer k <— 0 (the position of the current character in W)
an array of integers T (the table computed elsewhere)
letnP — 0
while j < length(s) do
if W[k]= S[j]thenletj ~j+1,k —k+1
if k = length(W) then let P[nP] <— j —k, nP <Np+1
(occurrence found if only first occurrence is needed, may be returned here)
Let K <—T[k] if k<Othen let J <—j+1, letk —k+1
Let K <—T[k] (T[length (W)] can’t be -1)
Else
LetK —T[k]ifK<Oletj ~j+1,k —k+1

Stop

3.3 Detecting SQL injection and XSS attacks
The various types of SQL injection and XSS attacks were
detected thus:

(i). Boolean-based SQL-injection attacks: As presented
in Table 3, it was deduced that most Boolean-Based
SQL injection strings have a single quote (°)
followed by logical operator OR and a true state-
ment such as ‘1’ = ‘1’;#, ‘a’ <> ‘b’ 5#_, ‘2 + 3’ < = ‘10’
;# (Fig. 1).

(ii). Union-based SQL injection attacks: Also, most
union-based SQL injection strings have a single
quote (‘) followed by a UNION keyword, the SQL
keyword SELECT, one or more identifiers, the SQL
keyword FROM, one or more identifiers then a
semicolon (;) with hash (#). Example includes ‘union
select * from users; # or ‘ union select name from a;
# (Fig. 2).
Abikoye et al. EURASIP Journal on Information Security (2020) 2020:14

Page 6 of 14

 

Boolean Based

 

string
Relational
Operator

Fig. 1 Parse tree to depict Boolean-based SQL injection attacks. (ii). Union-based SQL injection string

ab ‘OR’1' =’1'#

        
     
       

 
   
   

(iii) Error-based SQL injection attacks: The presence of (v). Like-based SQL injection attack: from Table 3,

a single quote (‘) from the user’s input, followed by
zero or more SQL functions, indicates the presence
of error-based SQL injection attacks. Example in-
cludes 111’ convert (int, ‘abcd’); A’ avg(‘&%$#@”’),
and ‘ round (‘abc’, 2) (Fig. 3).

(iv).Batch query SQL injection attacks: Input strings
with a single quote (‘) followed by a SQL keyword
“DROP”, “DELETE”, “INSERT” etc. then one or
more identifiers, followed by semicolon (;) with a
hash (#). Examples include aaa’; delete * from users;
# or ‘; drop table users; # (Fig. 4).

category (e) shows the different forms of like-based
SQL injection attack, and it is detected when the in-
put string contains a single quote (‘) followed by the
logical operator OR, followed by one or more iden-
tifiers, followed by the SQL keyword LIKE, followed
by a single quote (‘), followed by the wildcard oper-
ator (%), followed by a single quote (‘), followed by
semicolon with hash. Example include ‘OR user-
name LIKE ‘S%'# and ‘OR password LIKE °%2%’;#
(Fig. 5).

(vi).XSS attack: this can be detected when a JavaScript

open tag “<script>” is encountered from the input

“UNION SELECT * FROM
Users

& Select List (From Table List

 

 

Fig. 2 A parse tree to depict union-based SQL injection attacks. (ii). Error-based SQL injection string
Abikoye et al. EURASIP Journal on Information Security (2020) 2020:14 Page 7 of 14

 

111; convert (int, ‘abc’)
string SQL Function

Fig. 3 Parse tree to depict error-based SOL injection attacks. (ii). Batch query SQL injection attacks

 

; DELETE * FROM Users; #

Que rv SQL Query Que ry Comment
Terminator Terminator O
perator

C:) Table List

Fig. 4 Parse tree to depict SOL injection attacks using batch query. (ii). Like-based injection attack

 
Abikoye et al. EURASIP Journal on Information Security (2020) 2020:14 Page 8 of 14

 

“OR USERNAME LIKE ‘S %’ #

ee,
perator Operator
Table SQL Wildcard
C+) (on) Attribute Keyword Statement CH)

Fig. 5 Parse tree to depict like-based injection attacks. (ii). XSS injection attacks

 

XSS Injection String <Script>alert(‘XSS’) </script>

Javascript Javascript Javascript
Opening Tag Statements Closing Tag

Fig. 6 Parse tree to depict XSS injection attacks

 
Abikoye et al. EURASIP Journal on Information Security

string, followed by zero or more characters and/or
a single quote (‘), followed by a JavaScript closing
tag “</script>” as in <script>alert(‘XSS’);</script>. If
it were to be encoded XSS attack, such will have a
JavaScript open tag “<script>” followed by one or
more ASCII code, hexadecimal number, HTML
name, or HTML number of a character and/or a
single quote (‘), followed by a JavaScript closing tag
“</script>” as in <script>alert(&#34; XSS &#34;);
</script> (Fig. 6).

3.4 Preventing SQL-injection and XSS attacks using KMP
algorithm

KMP string matching algorithm was used to compare
user’s input string with different SQL injection and XSS
attacks patterns that have been formulated. The algo-
rithm goes thus:

n

T= ». fi Where f is the user's input from each form text field
i=0

filter() { data = convertASClItoString (1);
if (data <>""){
a = checkBooleanBasedSqli(data)
b = checkUnionBasedSqli(data);
c = checkErrorBasedSqli(data);
d = checkBatchQuerySqli(data);
e = checkLikeBasedSqli(data);

f = checkXss(data);

if (true (a|lbI|c||d|lel|f)) {
blockUser();
resetHTTP();

warning Message();

else {grantAccess();}

3.5 Formulating the filter functions

The filter() function was formulated to prevent SQL in-
jection and XSS attacks. This function contains other
functions that have been written each to detect a par-
ticular form of attack. If at least one function returns
True, then, the filter () will block that user, reset the
HTTP request, and display a corresponding warning
message. The first statement in the algorithm below rep-
resents user’s input which is collected from the web
form using POST Method, and it is donated by J. The

(2020) 2020:14

Page 9 of 14

filter() then collects the user’s input and firstly converts
any ASCII String found in order to prevent encoded in-
jection attack. If there is no any ASCII String and it is
not empty, then, the user’s input will be parsed to other
functions in order to check whether it contains some in-
jection code of Boolean-based SQLI, Union-based SQLI,
Error-based SQLI, Batch query SQLI, Like-based SQLI,
and XSS, and the outcomes of the functions are repre-
sented as a, b, c, d, e, and f respectively. If one of the re-
sult returns true, then, an injection string is found in the
user’s input, and it then triggers some functions: blockU-
ser(), resetHTTP(), and warningMessage() so that to
block the user, reset the HTTP request and issue a
warning message. Otherwise, access is granted. The
pseudo code illustrating this process goes thus:
checkBooleanBasedSqli(input){

injPattern[] = (U" "Nyy aue ee nape.
lOprt[] = {"or","||"3;
rOprt{]) = (=! > >=) <<a <> ="h
for(i = 0;i < injPattern. length; i+ +)
{
if (KM Psearcn(inputinjpattern{i]) > 0)
{
if (i == 0){counter = 0;
forG =0;j < lOprt.length; j + +){

if (KMP_Search(input, lOprt|j|) > 0){counter + +; }}

if (counter == 0){result = false; break; }

if(i == 2)
{counter = 0;
for(k =0;k < rOprt. length; k + +){
if (KMPsearch(inputropre|k]) > 0){counter + +;}
}
if (counter == 0){result = false; break; }
if (i +1) == injPattern. length){result = true;}
input = end(slice (injPattern|i], input, 2));
}else{ result = false; break; }

return result;

“Ss
_

i). Formulating the checkBooleanBasedSqli(_) function:
this was used to prevent Boolean-based SQL injec-
tion attack:
Abikoye et al. EURASIP Journal on Information Security (2020) 2020:14

CheckUnionBasedSqli(input){

oyu wow mow wow

injPattern[] = {"'","union"," select ","from" ,"#"};
for(i = 0;i < injPattern. length; i+ +)

{

if (KM P search (input.injpattern|i)) > 0)

if (Ci + 1) == injPattern. length){result = true;}

input = end(slice(injPattern[i], input, 2));

else{ result = false; break;

}return result;

}

(ii). Formulating the checkUnionBasedSqli() function:
this was used to prevent union-based SQL injection
attack:

checkErrorBasedSqli(input){
injPattern[] = {"'",")"};

mow wow wow wom wow

sqlFn[] = {"convert(","avg(","round(","sum(","max(","min("};
for(i = 0;i < injPattern. length; i+ +){

if (KM Psearch(inputinjpattern|i}) > 0)

{

if (i == 0){counter = 0;

forG = 0;j < sqlFn. length; j + +){
if (KMP_Search(input, sqlFn|j]) > 0){counter + +; }}

if (counter == 0){result = false; break; }
if (Ci + 1) == injPattern. length) {result = true; }
input = end(slice(injPattern|[i], input, 2));

} else{ result = false; break; }

return result;

(iii) Formulating the checkBatchQuerySqli() function:
this was used to prevent batch query SQL injection
attack:

Page 10 of 14

checkBatchQuerySqli(input){

injPattern[] = (Ur. "5","#"

sqlk[] = {"delete","drop","insert","truncate","update","select","alter"};
forG = 0;i < injPattern. length; i + +)

{

if (KMPsearcn(inputinjpattern{i}) > 9)
{
if (i == 0){counter = 0;
forG = 0;j < sqlk. length; j + +){
if (KMP_Search(input, sqlk[j]) > 0){counter + +;}}
if (counter == 0){result = false; break; }
if (Ci +1) == injPattern. length){result = true;}

input = end (slice (injPattern|i], input, 2));

else {result = false; break; }

return result;

(iv).Formulating the checkLikeBasedSqlis() function: this
was used to prevent like-based SQL injection attack:

checkLikeBasedSqli(input){
injPattern[] = {"'","like","'","%""'" "#"}y
lOprt[] = {"or","||"};
for(i = 0;i < injPattern. length;i + +)
{
if (KMPsearch(input;injpattern|il) > 9)

{
if (i == 0){counter = 0;

forG =0;j < lOprt. length; j + +)

if (KM Psearch(input lopre{j) > 0){counter + +;}

if (counter == 0) {result = false; break; }
if (G + 1) == injPattern. length){result = true; }
input = end(slice(injPattern[i], input, 2));
}else {result = false; break; }

return result;
Abikoye et al. EURASIP Journal on Information Security

(2020) 2020:14

Page 11 of 14

 

< C 8

localhost

Ej Facebook © TravelStart gBy eBay Ali—xpress SS Sports Betting

AL Aa BC

   

Home Contact Us Author's Guide

‘Bl ¢) Journal of Education

Enter Keywords or short phrases

www.abcjournal.com

Submit Paper

Login As Author Login As Admin

 

Volume 1 No. 1 Volume 1 No. 2

Volume 2 No. 1 Volume 2 No. 2

 

Fig. 7 Developed ABC journal of education

 

(v). Formulating the checkXss(_) function: this was used
to prevent XSS attacks.

checkXss(input){
injPattern[] = {"</script >","""," </script > "};
for(i = 0;i < injPattern. length; i++)
{
if (KMP_Search(input, injPattern|i]) > 0){
if (G +1) == injPattern. length){result = true; }

input = end (slice (injPattern{i], input, 2));

else { result = false; break; }

return result;

Therefore, to detect and prevent any of the attacks,
every input strings will be passed through all the func-
tions formulated. If at least one function return True,
then, the following functions will be triggered: blockU-
ser(), resetHTTP(), and warningMessage(). These func-
tions are used to interact with the prospective hackers.

4 Results and discussion

The proposed technique was implemented using PHP
Scripting Language and Apache XAMPP Server. The
PHP was selected as a scripting Language, because it is
the most widely used server-side scripting language in
building database-driven web-based application while
the Apache XAMPP Server was chosen due to its cross-

platform compatibility, it supports any operating system,
and it also supports both PHP scripting language and

SQL.

4.1 Test environment

Apache Web Server and Internet Information Server
(ISS) were used to host the system during the test. The
attack was launched on computers and mobile phones
of different brand, processor speed, and RAM size using
Windows, Linux, and Android operating systems. Opera
(Version 66.0.3515.44), Google Chrome (version
79.0.3945.130), Mozilla Fire fox (Version 67.0.4), and
Internet Explorer 11 were used as browsers to launch
the attack. The database to be targeted was stored on
mySQL database of size 4.998 MB. The test was con-
ducted on both remote server and local WAMP/XAMPP
server. To test the proposed technique, a vulnerable web
application shown in Fig. 7 was purposely developed.

An attempt was made to submit various known SQL
injection and XSS attack patterns using a “test plan”
shown in Table 4. The test plan consists of test cases
which contains input string for various attacks.

The input strings were supplied via the input fields of
the web application. When an attack was detected, the
uses would be blocked and The MAC address of the sys-
tems used to carry out the attack, types of attacks, the
input strings supplied, time stamp, and hacking status
was documented in a database table shown in Fig. 8.

Based on the results obtained from the various attack
attempts, the proposed technique was able to success-
fully detect and prevent all the attacks.
Abikoye et al. EURASIP Journal on Information Security (2020) 2020:14 Page 12 of 14

Table 4 The test plan

 

 

S/N Attack type Sample injection code

1 Boolean-based SQLi "OR “ ="; #

2 Boolean-based SQLi "OR '1'='15, #

3 Boolean-based SQLi "OR '3'| ='8' :#

4 Boolean-based SQLi "OR ‘a'<>'b’ #

5 Boolean-based SQLi aa’ OR '2 + 3'< ='7' #

6 Like-based SQLi a’ OR username LIKE ‘S%';#

7 Like-based SQLi “OR password LIKE '%2%':+#

8 Like-based SQLi ‘OR username LIKE ‘%e's#

9 Union-based SQLi ‘UNION select * from users; #

10 Union-based SQLi ‘UNION select cardNo, pin from customer; #
11 Error-based SQLi ‘convert( int, (select * from users LIMIT 1))
12 Error-based SQLi ‘ convert( int, “aaaa”)

13 Error-based SQLi ‘round((select username from users), 3)

14 Batch query SQLi ‘; drop table users ; #

15 Batch query SQLi ‘; delete * from customer ; #

16 Batch query SQLi ‘; insert into users values (‘Bala’, '1234') ; #
17 Batch query SQL injection ‘; update table users set username = ‘Bala’, password ='123' ; #
18 Encoded cross-site scripting <script> alert(&#34; XSS &#34;) </script>

19 Encoded SQL injection & # x39 & #xX85 & #X78& #x73& #x79

& #X78 & #X32& #X83.& #XO9O& #x/6

& #XO9 & #XO7 & #XB4& #x32& FX

42 & #xX32 & #xX70& #x82 & #x79 & #xX77
&#X382 & #X117& #X115 & #x101
&#XII4 & #X115& #x45 & #x45

20 Cross-site scripting <script> alert(XSS‘) </script>

2] Cross-site scripting <script>myFunction( );</script>

 

Al a~ Be eK

Cc Journal of Education

www .abcjournal.com

Blocked Hackers

Mac Address Type of Attack Injection Code Time Stamp Status Select

 

22-8G-4G-9]-5F-6A | Boolean-Based SQL Injection em 2 taal ae 2018-06-21 11:51:27 | Blocked

 

60-9C-02-8C-4B-9N | Like-Based SQL Injection or username like ‘'s%?'# 2018-06-21 11:51:27 | Blockea|

 

00-6R-8G-9J-5F-7U | Error-Based SQL Injection convert(int, "“www") 2018-06-21 11:51:27 | Blocked

 

01-4F-8G-9J-7H-6Y | Union-Based SQL Injection union select * from users; # 2018-06-21 11:51:27 | Blocked

 

00-9C-02-8C-4B-9K | Boolean-Based SQL Injection " or ‘'‘a'<>'b' # 2018-06-21 11:51:27 | Blocked

 

 

 

 

00-9C-02-S8C-S8T-4R | Batch Query SQL Injection | '"; drop table users;# 2018-06-21 11:54:04 | Biockea|

00-9C-02-7T-3E-5C | Cross-site Scripting <script>alert ('*xss')</script> 2018-06-21 11:57:32 | Blocked

 

00-9C-02-8C-4B-9C | Boolean-Based SQL Injection *" or '34+4'<='10' ;# 2018-06-23 08:39:51 | Blockes| &)

 

. | 00-9C-02-5N-4H-6F | Like-Based SQL Injection " or username like ‘tats'# 2018-06-23 08:39:31 | Blocked

 

 

 

00-9A-02-8C-4B-9E | Error-Based SQL Injection * round ("www", 10) 2018-06-23 09:28:47 | Blocked

 

 

Unblocked

 

 

Fig. 8 Attack detection interface showing the record of blocked hackers

 
Abikoye et al. EURASIP Journal on Information Security

Table 5 Results of existing works vs proposed technique

(2020) 2020:14

Page 13 of 14

 

Attack type

 

Ref. Boolean-based
SQLI SQL

Union-based

Encoded
injection

><
WN
WN

Error-based = Batch query __Like-based
SQLI SQLI SQLI

 

Methodology Using pattern matching [21] ¥ v
algorithm

Using data encryption [28]
algorithm

ISR [12]

©
KKK KRKRKRKRKR RRR KKK
KKK KRKRKRKRKR RRR KKK

Proposed algorithm

v v v X

KKK KRKRKRKRKR RRR KKK
KKK KRKRKRKRKR RRR KKK
KKK KRKRKRKRKR RRR KKK
Kx xX *& Kk kK KK KE KR RR KK
KK *& *K& & & & & & & &K &K K &K kK ™&

 

4.2 Results of existing works and the proposed technique
Results obtained from the proposed technique were
compared with those available in existing literature.
Seven (7) existing literature which used pattern match-
ing algorithms, six (6) literature which used data encryp-
tion algorithms, two (2) literature which used
instruction set randomization, and one (1) literature
which used PHP escaping functions were used for the
comparison. As documented in Table 5, existing tech-
niques which used data encryption algorithms were able
to prevent all the five forms of SQL injection attacks but
failed to prevent XSS attacks. Existing techniques which
used PHP escaping functions and pattern matching algo-
rithms were able to prevent all the five forms of SQL In-
jection attacks including the XSS attacks but failed to
prevent encoded injection attacks. Existing techniques
that used instruction set randomization were able to
prevent all the five forms of SQL injection but failed to
prevent XSS and encoded injection attacks. In a nut
shell, any of the existing methods has its own drawback
while the proposed algorithm prevents all the five forms
of SQL injection attacks including XSS and encoded in-
jection attacks.

5 Conclusion

A novel approach to detect and prevent SQL injection
and XSS attacks is presented in this paper. The various
types and patterns of the attacks were first studied, then

a parse tree was designed to represent the patterns.
Based on the identified patterns, a filter() function was
formulated using the KMP string matching algorithm.
The formulated filter() function detects and prevents
any form of SQL injection and XSS attacks. Every input
string is expected to pass through this filter () function.
If at least one function returns True, then, the filter()
function will block that user, reset the HTTP request,
and display a corresponding warning message. The tech-
nique was tested using a test plan that consist of differ-
ent forms of Boolean-based, union-based, error-based,
batch query, like-based, encoded SQL injections and
cross-site scripting attacks. The test results show that
the technique can successfully detect and prevent the at-
tacks, log the attack entry in the database, block the sys-
tem using its Mac Address to prevent further attack, and
issue a blocked message. A comparison of the proposed
technique with existing techniques revealed that the pro-
posed technique is more efficient because it is not lim-
ited to a particular form of attack, and it can handle
different forms of SQL injection and XSS attacks.

Acknowledgements

The authors appreciate Landmark University Centre for Research and
Development, Landmark University, Omu-Aran, Nigeria for fully sponsoring
the publication of this article.

Authors’ contributions
Authors AHD, AA, and AOC formulated and implemented the methodology
and drafted the manuscript. AOC adjusted the initial methodology and
Abikoye et al. EURASIP Journal on Information Security (2020) 2020:14

supervised the work. ANO and KAA carried out the survey of related work
and reviewed the manuscript. All authors read and approved the final
manuscript.

Funding

Publication of this research article was funded by Landmark University
Centre for Research and Development, Landmark University, Omu-Aran,
Nigeria.

Availability of data and materials
Not applicable

Competing interests
The authors declare that there are no competing interests.

Author details

"Department of Computer Science, University of Ilorin, llorin, Nigeria.
“Computer Science Department, Gombe State Polytechnic, Gombe, Nigeria.
*Computer Science Department, Landmark University, Kwara State,
Omu-Aran, Nigeria.

Received: 7 August 2019 Accepted: 24 June 2020
Published online: 18 August 2020

References

1. Acunetix_web_application_vulnerability_report_2019

2. _ B. Soewito, F.E. Gunawan, Prevention structured query language injection
using regular regular expression and escape string. Procedia Comput. Sci.
135, 678-687 (2018) https://doi.org/10.1016/j.procs.2018.08.218

3. MA. Ahmed, F. Ali, Multiple-path testing for cross site scripting using
genetic algorithms. J. Syst. Archit. 000, 1-13 (2015) https://doi.org/10.1016/j.
sysarc.2015.11.001

4. Y. Jang, J. Choi, Detecting SOL injection attacks using query result size.
Comput Security, 1-15 (2014) https://doi.org/10.1016/j.cose.2014.04.007

5. P.R. Mcwhirter, K. Kifayat, Q. Shi, B. Askwith, SOL injection attack classification
through the feature extraction of SQL query strings using a gap-weighted
string subsequence kernel. J. Inform. Sec. Appl. 40, 199-216 (2018) https://
doi.org/10.1016/jjisa.2018.04.001

6. O.C. Abikoye, A.D. Haruna, A. Abubakar, N.O. Akande, E.O. Asani, Modified
advanced encryption standard algorithm for information security. Symmetry
11, 1-17 (2019) https://doi.org/10.3390/sym11121484

7. NO. Akande, CO. Abikoye, M.O. Adebiyi, A.A. Kayode, A.A. Adegun, R.O.
Ogundokun, in International Conference on Computational Science and Its
Applications. Electronic medical information encryption using modified
blowfish algorithm (Springer, Cham, 2019), pp. 166-179 https://doi.org/10.
1007/978-3-030-24308-1_14

8. AO. Christiana, AN. Oluwatobi, G.A. Victory, O.R. Oluwaseun, A Secured One
Time Password Authentication Technique using (3, 3) Visual Cryptography
Scheme. IOP Conf. Series: Journal of Physics: Conf. Series 1299, 1-10 (2019
https://doi.org/10.1088/1742-6596/1299/1/01 2059)

9. Q Temeiza, M. Temeiza, J. ltmazi, A novel method for preventing SQL
injection using SHA-1 algorithm and syntax-awareness. Sudanese J. Comput.
Geoinform. 1(1), 16-26 (2017)

10. G Buja, T.F. Abdul, B.AJ. Kamarularifin, M.A. Fakariah, T.F. Abdul-Rahman,
Detection model for SQL injection attack : an approach for preventing a web
application from the SQL injection attack, Symposium on Computer
Applications and Industrial Electronics (2014), pp. 60-64

11. AS. Piyush, AN. Mhetre, International Conference on Pervasive Computing
(ICPC). A novel approach for detection of SQL injection and cross site scripting
attacks (2015), pp. 1-4

12. C. Ping, W. Jinshuang, P. Lin, Y. Han, Research and implementation of SQL
injection prevention method based on ISR, IEEE International Conference on
Computer and Communications (2016), pp. 1153-1156

13. U. Upadhyay, K. Girish, SQL injection avoidance for protected database with
ASCII using SNORT and honeypot, International Conference on Advanced
Communication Control and Computing Technologies (ICACCCT), (978)
(2016), pp. 596-599

14. B. Appiah, E. Opoku-mensah, SQL injection attack detection using fingerprints
and pattern matching technique, \EEE International Conference on Software
Engineering and Service Science (ICSESS) (2017), pp. 583-587

20.

22.

23.

24.

25.

26.

28.

29.

30.

32.

33.

Page 14 of 14

C. Ping, A second-order SQL injection detection method, 2017 IEEE 2nd
Information Technology, Networking, Electronic and Automation Control
Conference (ITNEC) (2017), pp. 1792-1796

A. John, A. Agarwal, M. Bhardwaj, An adaptive algorithm to prevent SQL
injection. 4 (2015), pp. 12-15 https://doi.org/10.11648/j.ajnc.s.2015040301.13
A. Ramesh, An Authentication Mechanism to Prevent SQL Injection by
Syntactic Analysis (2015)

D. Karis, J. Vanajakshi, KN. Manjunath, P. Srikanth, An effective method for
preventing SQL injection attack and session hijacking, |EEE International
Conference on Recent Trends in Electronics Information & Communication
Technology (RTEICT) (2017), pp. 697-701

A. Pramod, A. Ghosh, A. Mohan, M. Shrivastava, R. Shettar, SQL! detection
system for a safer web application, International Advance Computing
Conference (IACC) (2015), pp. 237-240

O.P. Voitovych, O.S. Yuvkovetskyi, L.M. Kupershtein, SQL injection prevention
system, International Conference “Radio Electronics & InfoCommunications”
(UkrMiCo) (2016), pp. 2-5

P. Chen, J. Wang, L. Pan, H. Yu, Research and implementation of SQL injection
prevention method based on ISR, IEEE International Conference on Computer
and Communications (IEEE, Chengdu, 2016), pp. 1153-1156

G. Ahmad, A hybrid method for detection and prevention of SQL injection
attacks, Computing Conference (London, 2017), pp. 833-838

P, Amith, G. Agneev, M. Amal, S. Mohit, S. Rajashree, SQL/ detection system
for a safer web application, IEEE International Advance Computing
Conference (IACC) (IEEE, Banglore, 2015), pp. 237-240

R. Ashwin, B. Anirban, V.L. Anand, An authentication mechanism to prevent
SQL injection by syntactic analysis, International conference on trends in
automation, communications and Computing technology (I-TACT-15) (IEEE,
Bangalore, 2015), pp. 1-6

A. Prabakar, M. Karthikeyan, K. Marimuthu, An efficient technique for
preventing SQL injection attack using pattern, International Conference on
Emerging Trends in Computing, Communication and Nanotechnology
(ICECCN) (2013), pp. 503-506

A. Ghafarian, A hybrid method for detection and prevention of SQL injection
attacks, IEEE Comput Conference (2017), pp. 833-838

P. Amutha, M. Karthikeyan, K. Marimuthu, An efficient technique for
preventing SQL injection attack using pattern matching algorithm, EEE
international conference on emerging trends in Computing,
communication and nanotechnology (ICECCN) (2013), pp. 503-506

T. Qais, T. Mohammad, |. Jamil, A novel method for preventing SQL injection
using SHA-1 algorithm and syntax-awareness, International conference on
information and communication Technologies for Education and Training
and international conference on Computing in Arabic (ICCA-TICET) (IEEE,
Khartoum, 2017), pp. 1-4

U. Utpal, K. Girish, SQL injection avoidance for protected database with ASCII
using SNORT and honeypot. International conference on advanced
communication control and Computing technologies (ICACCCT) (IEEE,
Ramanathapuram, 2016), pp. 596-599

J. Ashish, A. Ajay, B. Manish, An adaptive algorithm to prevent SQL injection.
Am. J. Networks Commun., 12-15 (2015)

M. Srivastava, Algorithm to Prevent Back End Database against SQL Injection
Attacks International Comference on Computing for Sustainable Global
Development (INDIACom) (2014), pp. 755-757

T. Pravallica, S. Betam, An application to prevent SQL injection attacks using
randomized encription algorithm. International journal of computer trends and
technology (UCTT) (2013), pp. 2782-2786

B. Geogiana, B.A. Kamarularifin, B.H. Fakariah, F.A. Teh, Detection model for
SQL injection attack: an approach for preventing a web application from the
SQL injection attack, Symposium on Computer Applications and Industrial
Electronics (IEEE, Penang, 2014), pp. 60-64

Publisher’s Note
Springer Nature remains neutral with regard to jurisdictional claims in
published maps and institutional affiliations.
