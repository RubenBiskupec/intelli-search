Liu et al. Cybersecurity (2020) 3:17
https://doi.org/10.1186/s42400-020-00057-3

Cybersecurity

RESEARCH Open Access

Lightning-fast and privacy-preserving
outsourced computation in the cloud

Check for
updates

 

Ximeng Liu'?” ®, Robert H. Deng!, Pengfei Wu? and Yang Yang!

Abstract

In this paper, we propose a framework for lightning-fast privacy-preserving outsourced computation framework in
the cloud, which we refer to as LightCom. Using LightCom, a user can securely achieve the outsource data storage and
fast, secure data processing in a single cloud server different from the existing multi-server outsourced computation
model. Specifically, we first present a general secure computation framework for LightCom under the cloud server
equipped with multiple Trusted Processing Units (TPUs), which face the side-channel attack. Under the LightCom, we
design two specified fast processing toolkits, which allow the user to achieve the commonly-used secure integer

computation and secure floating-point computation against the side-channel information leakage of TPUs,
respectively. Furthermore, our LightCom can also guarantee access pattern protection during the data processing and
achieve private user information retrieve after the computation. We prove that the proposed LightCom can
successfully achieve the goal of single cloud outsourced data processing to avoid the extra computation server and
trusted computation server, and demonstrate the utility and the efficiency of LightCom using simulations.

Keywords: Privacy-preserving, Secure outsourced computation, Homomorphic encryption, Secret sharing

technique, Against side-channel attack

Introduction

THE internet of things (oT), embedded with electronics,
Internet connectivity, and other forms of hardware (such
as sensors), is a computing concept that describes the idea
of everyday physical objects being connected to the inter-
net and being able to identify themselves to other devices.
With large numbers of IoT devices, a colossal amount of
data is generated for usage. According to IDC!, the con-
nected IoT devices will reach 80 billion in 2025, and help
to generate 180 trillion gigabytes of new data that year.
A quarter of the data will create in real-time, and 95% is
to come from IoT real-time data. With such a large vol-
ume, real-time data are generated; it is impossible for the

 

*Correspondence: snbnix@gmail.com

'College of Mathematics and Computer Science, Fuzhou University, Fuzhou,
China

*School of Information Systems, Singapore Management University,
Singapore, Singapore

Full list of author information is available at the end of the article
‘http://www.vebuso.com/2018/02/idc-80-billion- connected-devices-2025-
generating- 180-trillion- gb- data-iot- opportunities/

o) Springer Open

 

resource-limited IoT devices to store and do the data ana-
lytics in time. Cloud computing (Ali et al. 2015; Wei et al.
2014; Wazid et al. 2020; Challa et al. 2020), equipped the
almost unlimited power of storage and computing pro-
vides the diversity of services on demand, such as storage,
databases, networking, software, analytics, intelligence.
With the help of cloud computing, 49 percent of data will
be stored in public cloud environments by 20257. Unsur-
prisingly, the massive volume of data generated by IoT
devices is outsourced to the cloud for long-term storage
and achieve real-time online processing.

Despite the advantages provided by IoT-cloud data out-
sourcing architecture, the individual IoT users hesitate
to use the system for data storage and processing with-
out any protection method. On the Internet of Medi-
cal Things example (Dimitrov 2016), patients wearable
mHealth devices that always equipped with biometric
measurement sensors (such as heart rate, perspiration

 

*https://economictimes.indiatimes.com/tech/internet/global-data-to-
increase- 10x- by- 2025- data-age-2025/articleshow/58004862.cms?from=mdr

© The Author(s). 2020 Open Access This article is licensed under a Creative Commons Attribution 4.0 International License, which
permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit
to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The

images or other third party material in this article are included in the article’s Creative Commons licence, unless indicated
otherwise in a credit line to the material. If material is not included in the article’s Creative Commons licence and your intended
use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the
copyright holder. To view a copy of this licence, visit http://creativecommons.org/licenses/by/4.0/.
Liu et al. Cybersecurity (2020) 3:17

levels, oxygen levels) to record the physical sign of the
patient. The hospital can use clients PHI decision-making
model to automatically check a patients health status.
According to a new report by Grand View Research, The
global IoT in healthcare market size is projected to reach
USD 534.3 billion by 2025 expanding at a Compound
Annual Growth Rate (CAGR) 19.9% over the forecast
period’. If no protection method is adopted, patients
physical signs can be capture by an adversary. Moreover,
the hospital model can be got by other third-party com-
panies to make a profit. Use the traditional encryption
technique can protect the data from leakage; however, the
ciphertext lost the original meaning of the plaintext, which
cannot do any computations.

Protecting the data and achieve the secure outsource
computation simultaneously is an eye-catching field to
solve the above problems. Currently, there are typically
two aspects of techniques to achieve secure outsourced
computation: theoretical cryptography solution and sys-
tem security solution. For the cryptography point of view,
homomorphic encryption (Naehrig et al. 2011) is con-
sidered as a super-excellent solution for the outsourced
computation, which allows the third-party to perform the
computation on the encrypted data without revealing the
content of the plaintext. Fully homomorphic encryption
(Van Dijk et al. 2010) can achieve arbitrary computation
on the plaintext corresponding to the complex operations
on the ciphertext. However, the computation overhead is
still tremendous, which is not fit for the piratical usage
(e.g., it requires 29.5 s to run secure integer multiplication
computation with a standard PC (Liu et al. 2018b)). Semi-
homomorphic encryption (Bendlin et al. 2011; Farokhi et
al. 2016; Ma et al. 2020) only supports one type of homo-
morphic (e.g., additive homomorphic), can achieve com-
plex data computation on the encrypted data with the help
of other honest-but-curious servers. However, the extra
computation server will increase the possibility of infor-
mation leakage. Recently, for the industrial community,
trusted execution environment (TEE, such as Intel® Soft-
ware Guard Extensions (SGX)* and ARM TrustZone”)
is developed to achieve the secure computation which
allows user-level or operating system code to define pri-
vate regions of memory, also called enclaves. The data in
the enclave are protected and unable to be either read
or saved by any process outside the enclave itself. The
performance of the TEE is equivalent to the plaintext
computation overhead. Unfortunately, TEE easily faces
the side-channel attack, and the information inside the

 

$https://www.grandviewresearch.com/press-release/global-iot-in-healthcare-
market

“*https://software.intel.com/en-us/sgx

>https://developer.arm.com/ip- products/security-ip/trustzone

Page 2 of 21

enclave can be leaked to the adversary® ’. Thus, a fasci-
nating problem appears for creating a system to balance
the usage of practical outsourced computation system
and eliminate the extra information leakage risk: how can
a single cloud securely perform the arbitrary outsourced
computation without the help of extra third-party com-
putation server or trusted authority, which interactions
between the user and the cloud kept to a minimum.

In this paper, we seek to address the challenges as men-
tioned above by presenting a framework for lightning-fast
and privacy-preserving outsourced computation Frame-
work in a Cloud (LightCom). We regard the contributions
of this paper to be six-fold, namely:

e Secure Data Outsourced Storage. The LightCom
allows each user to outsource his/her data to a cloud
data center for secure storage without compromising
the privacy of his/her data to the other unauthorized
storage.

e Lightning-fast and Secure Data Processing in Single
Cloud. The LightCom can allow in a single cloud
equipped with multiple Trusted Processing Units
(TPUs), which provides a TEE to achieve the
user-centric outsourced computation on the user’s
encrypted data. Moreover, the data in untrusted
outside storage are secure against chosen-ciphertext
attacks for the long-term, while data insider TPUs
can be protected against side-channel attacks.

e Outsourced Computation Primitive Combinable.
Currently, the outsourced computation methods
focus on a special computation task, such as
outsourced exponential computation. Different
specific outsourced tasks are constructed with
different crypto preliminary. Thus, the previous
computation result cannot be directly used for the
input of the next computation. Our LightCom can
directly solve the problem with a uniform design
method which can achieve computation combinable.

e No Trusted Authority Involved. In most of the
existing cryptosystems, trusted authority is fully
trusted, which is an essential party in charge of
distributing the public/private keys for all the other
parties in the system. Our LightCom does not involve
an extra fully trusted party in the system, which
makes the system more efficient and practical.

e Dynamic Key/Ciphertext Shares Update. To reduce
the user’s private key and data leakage risk during the
processing, we randomly split the key and data into
different shares which are processed in different
TPUs, cooperatively. To avoid long-term shares
leaking for recovering the original secrets, our
LightCom allows TPUs updating user’s “old”

 

®https://software.intel.com/en-us/articles/intel-sgx-and-side-channels
7https://www.arm.com/products/silicon-ip-security/side-channel- mitigation
Liu et al. Cybersecurity (2020) 3:17

data/private-key shares into the “new” shares
on-the-fly dynamically without the participation of
the data user.

e High User Experience. Most existing
privacy-preserving computation technique requires a
user to perform different pre-processing technique
according to the function type before data
outsourcing. The LightCom does not need the data
owner to perform any pre-processing procedure -
only needs to encrypt and outsource the data to the
cloud for storage. Thus, interactions between the
user and the cloud kept to a minimum - send the
encrypted data to the cloud, and received outsourced
computed results in a single round.

Motivation and Technique Overview. As the sensi-
tive information contained inside TPU can be attacked,
our primary motivation of the LightCom framework is to
achieve secure computation in a single cloud without the
help of an additional party. Also, as most of the devices
are mobile devices with battery restriction, we need to
guarantee users experience to make sure that the interac-
tions between the user and the cloud kept to one round.
The design idea of LightCom is to let the data store in the
outside storage, and achieve privacy-preserving computa-
tion insider TPU. The main challenges are how to achieve
both practical secure data storage and outsourced data
processing against side-channel attacks, simultaneously.

To solve the secure data storage challenge, we use a new
Paillier Cryptosystem Distributed Decryption (PCDD),
which can achieve semantic secure data storage. To pre-
vent information leakage inside TPU, our LightCom uses
one-time pad by adding some random numbers on the
plaintext of the PCDD ciphertext. Even the “padded”
ciphertext for the TPU enclave for decryption and pro-
cess, the attacker still cannot get the original message of
the plaintext. To achieve ciphertext decryption, our Light-
Com uses multiple TPUs, and each TPU only stores a
share of the private key to prevent the user’s key leak-
age risk. Even some partial private key/data shares may
leak to the adversary; our framework can successfully
update these shares dynamically inside the TPU to make
the leaked shares useless. More importantly, all the secure
execution environment (called TPU enclaves) in TPUs are
dynamically building and release for the secure compu-
tation in our LightCom framework, which can further
decrease the information leak risk in the enclave.

Applications with LightCom. The LightCom is a fun-
damental secure data computation framework which can
be used for the following four types of applications — see
Fig. 1.

1. Artificial Intelligence (AI) System. AI is the simulation
of human intelligence processes by machines, especially
computer systems, which can be used in expert systems,

Page 3 of 21

natural language processing (NLP), speech recognition
and machine vision. However, in most of the AI appli-
cations, the data for AI model training and decision are
sensitive which need to be protected before sending into
the AI model. Also, the AI model is considered as the
core asset of the company which requires a staggering
cost for training. With the help of LightCom, both data
and AI models can be protected, and all the basic secure
operations can be used for building the secure AI sys-
tem without leaking any information about the model
parameters.

2. E-Healthcare System. E-healthcare is a field in the
intersection of public health, and medical informatics,
referring to health services and information delivered
or enhanced through the Internet and related technolo-
gies. An Electronic Health Record (EHR) is considered
as the key to the e-healthcare system which provides
real-time, patient-centric records that make information
available instantly to the users. To ensure the privacy of
the record, some researchers provide secure techniques
to encrypt the EHR (Xu et al. 2020a, b; 2018). However,
encrypted EHR cannot do any operations without decryp-
tion. Thanks to the LightCom, the third-party company
can use the encrypted EHR in the e-healthcare system for
practical secure data analytics without any information
leakage. The patient can use his/her own private key to
decrypt and get the real-time analytic e-healthcare result.

3. Connected and Automated Vehicles (CAV). The trans-
portation system is rapidly evolving with new CAV tech-
nologies that integrate CAVs with other vehicles and road-
side infrastructure in a cyber-physical system (CPS). For
the vehicle to be truly capable of driving without user
control, an extensive amount of training must be initially
undertaken for the AI system to make the right decisions
in any imaginable traffic situation. However, the compro-
mised vehicle can capture data packet information, thus
acquiring sensitive and confidential data. Cryptography-
based solutions include encryption that can be used to
detect eavesdropping and secure vehicle privacy. How-
ever, the automated vehicle cannot make any operations
on the encrypted training data packets. In order to train
the self-divining model in a privacy-preserving way, the
LightCom can be used for constructing the model without
the training data leakage.

4. Social Network (SN). A social network is a social
structure made up ofa set of social actors (such as individ-
uals or organizations), sets of dyadic ties, and other social
interactions between actors. Social network user’s private
information including messages, invitations, photos, are
often the venues for other adversaries to gain access. How-
ever, these data are valuable for the service provider that
can be extracted useful knowledge from them. The tradi-
tional encryption technologies can successfully deal with
the user’s private information, but make the social media
Liu et al. Cybersecurity (2020) 3:17

Page 4 of 21

 

dOUdSIT[IIUT
jeDoyntIy

Internet of Things Data

    

\ \ it / ,

Social Networks
(SN)

Fig. 1 LightCom with the Applications

 

   

15 ah 3S ,
Platform ,

 

eee ae
*

   

 

  

 
  

  
 

ee =
2 \Y = Ws Connected and
\ —— = Automated

    
 

| /
\_/ | et69s /

E-healthcare
System

 

 

data unusable. With the LightCom, the service provider
can achieve secure data analytics without getting any
social actors’ private information.

Preliminary

Notations

Throughout the paper, we use ||x|| to denote bit-length of
x, while L(x) denotes the number of element in x. More-
over, we use pk, and sk, to denote the public and private
keys of a Request User (RU) a, skD, sk to denote the
partial private keys that form skz, || x]],x, to denote the
encrypted data of x using pk, in public-key cryptosys-
tem. For simplicity, if all ciphertexts belong to a specific
RU, say a, we simply use [x] instead of [ x]],x,. We use
notion (m) to denote the data share of m, i.e., each party i
(i= 1,---,P) holds m;, such that ey mM; = mM.

Additive secret sharing scheme (ASS)
Give m € G (G is a finite abelian group under addition),
the additive secret sharing scheme (a.k.a. P-out-of-P

secret sharing scheme) can be classified into the follow-
ing two algorithms — Data Share Algorithm (Share) and
Data Recovery Algorithm (Rec):

Share(m) : Randomly generate X1,--- ,Xp_i € G, the
algorithm computes Xp = m — (X, + --- + Xp-_i), and
outputs Xj,--- ,Xp.

Rec(Xj,::-,Xp) : With the shares Xj,---,Xp, the
algorithm can recover the message m by computing with
m= X,+---+Xp under group G.

Additive homomorphic encryption scheme

To reduce the communication cost of the LightCom,
we used an Additive Homomorphic Encryption (AHE)
scheme as the basis. Specifically, we use one of the
AHE support threshold decryption called Paillier Cryp-
tosystem Distributed Decryption (PCDD) in our previous
work which contains six algorithms called Key Genera-
tion (KeyGen), Data Encryption (Enc), Data Decryption
(Dec), Private Key Splitting (KeyS), Partially decryption
(PDec), Threshold decryption (TDec). The plaintext
Liu et al. Cybersecurity (2020) 3:17

belongs to Zy and the ciphertext belongs to Zj2. The
construction of the above algorithms can be found in Sup-
plementary Materials Section C. Here, we introduce the
two properties of the PCDD as follows: 1) Additive Homo-
morphism: Given ciphertexts [[7m]] and [m2] under a
same public key pk, the additive homomorphism can
be computed by ciphertext multiplication, i.e., compute
1] - m2] =[| m1 +m2]. 2) Scalar-multiplicative Homo-
morphism: Given ciphertext || m]] and a constant number
c € Zn, it has ([ m]] )° =| cm].

With the two properties given above, we show that our
PCDD have the polynomial homomorphism property, ie.,
given [ x,]],---, [| %,]] and q,--- , day, it has

[| 41-41 +42-K2+- + AyXy]] [x1] [xo] --- [xn].

Mathematical function computation
In this section, we define the function which is used for
data processing in our LightCom.

Definition 1 (Deterministic Multiple-output Multivari-
able Functions) Let D = {(x],-:-,%y) : x € G} be
a subset of G’. We define the deterministic multiple-
output multivariable function as follows: (I) A multiple-
output multivariable function F of v variables is a rule
which assigns each ordered vector (x1,---,xy) in Dtoa
unique vector denoted (yj,--- , Vw), denote (y1,--* 5 Vw) <—
F (x1,°++ xy). ID) The set D is called the domain of F. (III)
The set {F (x1,--- ,xy)|(*1,--- xy) € D} is called the range
of F.

Note that the deterministic multiple-output multivari-
able function is the general case of the deterministic
multiple-output single-variable function (v = 1), deter-
ministic single-output multivariable function (w = 1), and
deterministic single-output single variable function (v =
1,w = 1). As all the functions used in our paper can be
successfully executed by a polynomial deterministic Tur-
ing machine (See Supplementary materials Section A), we
omit the word “deterministic” in the rest of the paper.

System model & privacy requirement
In this section, we formalize the LightCom system model,
and define the attack model.

System model

In our LightCom system, we mainly focus on how the
cloud server responds to a user request on outsourced
computation in a privacy-preserving manner. The system
comprises Request User (RU) and a Cloud with Untrusted
Storage (UnS) and Trusted Processing Units (TPUs) - see
Fig. 2.

Page 5 of 21

e A RU generates his/her public key, private key shares,
and data shares. After that, the RU can securely
outsource the public key and private/data shares to
the cloud’s UnS for secure storage (See @).
Moreover, the RU can also request a cloud to
perform some secure outsourced computations on
the outsourced data and securely retrieve the final
encrypted results (See ©)).

e A UnS of the cloud has ‘unlimited’ data storage space
to store and manage data outsourced from the
registered RU. Also, the UnS stores all the
intermediate and final results for the RU in encrypted
form.

e The TPUs of the cloud provides online computation
ability for each RUs. Each TPU provides isolation
secure computing environment for individual RU and
can load RU’s data shares from UnS (See @), perform
certain calculations over the data shares (See @)), and
then securely seal the data shares in UnS for storage
(See @)®. Note that one TPU cannot load other
TPU’s sealed data, which are stored in UnsS.

Attack model

In our attack model, the cloud is curious-but-honest party,
which strictly follow the protocol, but are also interested
in learning data belonged to the RUs. The UnS inside the
cloud is transparency to both the cloud and the outsider
passive attackers. Every TPU can provide a secure execu-
tion environment (a.k.a., TPU enclave) for a RU, which is
secure against the other RU, the cloud, and outsider pas-
sive attackers. The inside non-challenge RUs and outside
attackers can also be interested to learn challenge RU’s
data. Therefore, we introduce three active adversaries

1, A5,A3, which can simulate the malicious actions cor-
responding to the outside attackers, non-challenge RUs,
UnS, respectively. The goal of these adversaries is to get
the challenge RU’s plaintext or try to let the challenge RU
get wrong computation result with the following capabili-
ties:

1) Aj acts as the outside attacker that may eavesdrop on
all communication links and CP’s Un§, and try to decrypt
the challenge RU’s encrypted data. 2) A} may compro-
mise RUs, except for the challenge RU, to get access to
their decryption capabilities, and try to guess all plaintexts
belonging to the challenge RU. 3) A} may compromise
the TPU to guess plaintext values of all data shares sent
from the UnS by executing an interactive protocol. Noting
that the above adversaries A}, A}, Aj are restricted from
compromising (i) all the TPUs concurrently’, and (ii) the
challenge RU.

 

8See the algorithm Seal and UnSeal in “ecure TPU-based data seal &
UnSeal” section.

°Note that P > 3 TPUs are required in LightCom for the security
consideration.
 

Liu et al. Cybersecurity (2020) 3:17 Page 6 of 21
>
|: @:Trusted Processing Unit @ Data Unseal .
acl @) Secure Data Processing
[Svmirusted Storage @©pata seal _ __ |

=a

—_—_ ._ ——

Request Users

Fig. 2 System model under consideration

 

sen —~Y Tig @ Upload Encrypted
/ “ Data
/ \_5_,
)
\ cece / —_————
\ 7 A
~ = © Encrypted Result
Retrieval

   

 

 

 

Basic privacy preserving computation protocols

In this section, we introduce our general design method of
the mathematical function for LightCom. Moreover, the
dynamic private/data share update without the participa-
tion of the DO are also introduced.

The LightCom design method for the single functions

Our LightCom achieves the user data’s privacy during the
efficiency in the outsourced cloud with three-dimensional
protection: 1) secure storing in the untrusted cloud stor-
age; 2) secure processing in TPUs against side-channel
attack; 3) efficient and dynamic outsourced key and data
shares updating. Specifically, to outsource the data to
the cloud, the RU first initializes the system, uses the
RU’s public key to encrypt the data, and outsources these
encryptions and the system parameters to UnS for storage.
To achieve the second-dimensional protection, our Light-
Com uses the data sharing-based secure computation
method between TPUs, which can resist the side-channel
attacks even the PPCD ciphertexts are decrypted. After
finishing the processing, the data are sent back to UnS for
further processing to complete the corresponding func-
tionality defined in the program, and the enclaves in TPUs
are released. Moreover, to tackle the leaked private key
and data shares, all the TPUs can jointly update these
shares without the help of RU. Thus, the LightCom can
classify into the following four phases.

1) System Initialize Phase: Firstly, the RU generates a
public key pk and private key is sk of appropriate pub-
lic key crypto-system, and then splits the private key sk
into P shares sk; (i = 1,---,P) with the Share algo-
rithm. After that, for each TPU i in the cloud, it initials
an enclave i, builds a secure channel, and uploads the sk;
to the enclave i securely. Finally, the TPU i uses the data
sealing to securely stored the pk, sk; in to UnS.

2) Data Upload Phase: In the phase, the RU randomly
separates the data xj1,---,%j,p € G, such that «1 +
+ a,p = x forj = 1,---,v. Then, the TPUi (i =
1,--- ,P) creates the enclave i. After that, the RU defines
the program C; for some specific computation function,
builds a secure channel with TPU enclave i, remotely

loads x1,;,--- ,Xy,i, Cj into the enclave i, and securely seals
X1is°++ »Xyji,C; in the UnS. After that, TPU i releases the
enclave i.

3) Secure Computation Phase: The goal of the phase
is to achieve the secure computation among the TPUs
according to the user-defined program C;. Thus, it works
as follows:

e (3-I) Each TPU i generates an enclave i. After that, all
the TPUs build a secure channel with each other.
Load sealed data x1 j,--- xy, pk, skj, Cj to enclave i
from UnS, and denote them as §;.

e (3-II) TPUs jointly compute (y1,1,--- ,¥w1 t+:
Y1L,Pr*** > Ywp) <— GenCpt(S, :---: Sp) according
to the user-defined program Cj,--- ,Cp19.

e (3-III) All the TPUs jointly update the private key
shares and data shares dynamically.

After the above computation, the TPU i seals
Y1,i2°** »¥w,i into the UnS, and releases the enclave.

4.) Data Retrieve Phase: If the RU needs to retrieve the
computation results from the cloud, the TPU i creates
an enclave i, opens the sealed data y1j,--- , Yj, builds a
secure channel with the RU, and sends the data shares
back to RU. Once all the shares are sends to RU, the RU

computes yj = ey yji for j = 1,--- ,w.

The LightCom Design for Combination of the Functions
Our LightCom can support for single data outsourced
with multiple function operations. The procedure is as
follows:

1) System Initialize Phase: Same to the LightCom with
single function in “The LightCom design method for the
single functions” section.

2) Data Upload Phase: After the system initialize phase,
the RU defines the program C;; for TPU i (i = 1,--- ,P)
with function computation step ¢ (¢ = 1,--- ,¢) and ran-
domly separates the data xj,1,1,--- ,j1,p, such that 41,1 +

 

10The construction of General Secure Function Computation Algorithm
(GenCpt) can be found in “General secure function computation algorithm
(GenCpt)” section.
Liu et al. Cybersecurity (2020) 3:17

+ xp = «x forj = 1,-:-,v ll” After that, the
RU builds a secure channel with TPU enclave i, remotely
loads Cyj,-++ ,Cc,is ¥1,1,i5°* + »%v,1,¢ into the enclave i, and
securely seals these data in the UnS. After that, TPU i
release enclaves i for all thei = 1,--- ,P.

3) Secure Computation Phase: The goal of the phase
is to achieve the secure computation among the TPUs
according to the user-defined program C;; for function t
(¢ = 1,--- ,¢). Thus, for each step f, the phase works as
follows:

e (3-I) Each TPU i generates an enclave i. After that, all
the TPUs build a secure channel with each other.
Load sealed data *1,,i, +++ »Xv,t,is PK; Skis C1is +++ 5 Ce,i
to enclave i from UnS, and put them in a set €;;.

e (3-II) TPUs jointly compute (y1,41,°-° > Yweliccc:
Vitn + Swit) <— GenCpt (Ep; +--+: Ei),
according to the user-defined program Cj,j;,--+ ,Cz,ji.

e (3-III) All the TPUs jointly update the private key and
data shares. Ift = ¢, the TPU i seals y1,¢4,-- + , Yw,c,i
into the UnS, release the enclave. Otherwise, move to
(3-IV) for further computation.

e (3-IV) Select *1241,i,--+ »%v,c+1, from the
Yitir’** »¥w,t,i for TPU i. Then, the TPU i seals
X1Lt+Li*** »%vt+1, into the UnS, release the enclave,
and move to (3-I) for next step computation.

After the ¢ step is finished, the TPU i seals the set €; into
the UnS, and releases the corresponding enclave.

4) Data Retrieve Phase: After the computation, TPU i
new an enclave i, opens the sealed data y1¢,--+ ,Vw,c,is
builds a secure channel with the RU, and sends these
data back to the RU. Once all the TPU’s data are sent,
the RU computes the result y,- = ey yj,c,i for step ¢
(j = 1,--- ,w) to get the final results.

General secure function computation algorithm (GenCpt)
As the key component of the LightCom, the General
Secure Function Computation Algorithm (GenCpt) are
proposed to achieve the secure deterministic multiple-
output multivariable function * computation which
is introduced in definition 1. Assume TPU i @@ =
1,---,P) holds x1j,--- ,x);, GenCpt can securely out-
put y1i,°-- »¥w,i for each TPU i, such that (y1,--- ,Yw) <—
F (x1,+++ ,%y), where x1 +--+ +%j,p = aj and yyy +++°+
Yep = ye forj=1,---,vy;kK =1,---,w. The GenCpt can
be classified into offline/online stages and constructed as
follows:

Offline Stage: Each TPU i (i = 1,---,P) creates an
enclave i, loads the sealed keys pk, sk; and program C; into
the enclave from the UnS, builds a secure channel with the

 

1 Data share «jz; is for TPU enclave i for data j of function computation step-t.

Page 7 of 21

other TPUs!?. With the help of homomorphic cryptosys-
tem, all the TPUs can collaboratively generate the shares
of random numbers and put them into a set R;. Note the
shares in set 7; cannot be known by all the other TPUs
during the generation. After the above computation, each
TPU i seals the 7; into the UnS, respectively.

Online Stage! For each TPU i (i = 1,--- , P), loads the
sealed random numbers set 7; from offline stage into the
enclave i. All the TPUs cooperatively compute and output
the results

1b °° * > Ywi) KfiOrir ++ 1 %y,i Ri),

where f; is the combination of +, x for Zy and 9, A for Z
with specific functionality according to the program (Cj.

Private key share dynamic update
The private key shares are more sensitive and vulnera-
ble, as the adversary can use the private key to decrypt
the RU’s data in the untrusted storage if the side-channel
attack leaks all shares of the private key. Thus, we should
frequently update the key shares in the TPU enclave.
The intuitive idea is to let the RU choose a new pri-
vate key, separate the new private key into different key
shares, update these key shares in the different individ-
ual enclaves, and update all the ciphertext with the new
key. However, the above strategy has the main drawback:
the RU has to be involved in the private/public key update
phase, which brings extra computation and communica-
tion costs. Thus, in this case, the RU needs to frequently
generate and update the public/private keys, impracti-
cal. Therefore, we bring the idea of proactive secret
sharing into the LightCom: keeps the public/private key
unchanged, the TPU will periodicity refresh the key shares
without the participation of the RU. Mathematically, to
renew the shares at period t (tf = 0,1, 2,---), we need to
update the shares such that ey sk) = ey sk? +
an ia 8 where ia bi; = 0, ey sk = sk and
sk = sk; fori = 1,---,P (See Fig. 3 for example of
private key update procedure with P = 3). The special
construction is as follows:

1) Each TPU i(i = 1,--- ,P) creates an enclave i. After
that, TPU i the builds a secure channel with TPU j’s
enclave (j = 1,--- ,P3j7 # i).

2) TPU i picks random numbers 6;),--- , 46; € G such
that 6;1 +---+6;~ = 0 under the group G, and then sends
6; to TPU enclave j.

3) After received 6;;, TPU i computes the new shares

sk) _ sk 4 5) 4 5 foe eb 55), € G. After that,

 

12 As offline stage of the secure computations needs to do TPU enclave
initialization, we just omit the description in the rest of the section.

13The input data x1,;,--+ ,xy,,, public key pk, private key shares sk;, and the
program C; are loaded in the step of (3-1) of both “The LightCom design
method for the single functions” and “The LightCom Design for Combination
of the Functions” sections.
 

 

 

 

 

 

 

 

Liu et al. Cybersecurity (2020) 3:17 Page 8 of 21
. t t t
Period t shy shy" sks
Le ee eee ee
v Vv 6° v
TPU 1 5 TPU 2 TPU 3
aa 60) 2,2aa8 68 ae
a » 1,2 a » « B (t)’
Update 6.9 « @- « @> « @® »>:;
, td (t) a B (t) 4 D
eg 03 4 weg 65 3 ee
| 68 | |
ble ee ee eae Joc cece ee eee dee eee eee eee eee efe eee.
v v vV
Periodt +1 — sk\* sk ot) skeet
Fig. 3 Key Shares Update (example of P = 3)
TPU i erases all the variables which it used, except for its m,m,---,mp € Dy. For the binary shares, RU exe-
current secret key skh, cutes Share(m), such that m = mj + --: + mp, where
m,mj,,---,Mmp € Zp. After that, RU securely sends integer

Data Shares Dynamic Update

As data shares need to load to TPU for processing, the
shares can be leaked to the adversary by side-channel
attack, and reconstruct the RU’s original data. Thus, we

also need to dynamically update data shares x) oe

at period t (t¢ = 0,1,2,---), such that ey oh) =
Pt) P oP P (0) (0)
in1%j + Deed j=l bij, Where )/j1%, = % xj =
xj, and ae 6,; = O fori = 1,---,P. The construc-
tion is same to the private key share update method in
“Private key share dynamic update” section.

TPU-based basic data shares operations
In this section, we introduce some basic TPU-based data
shares operations, which can be used as LightCom.

Data domain and storage format

Here, we introduce three the data group domain
for LightCom: Zy = {0,1,---,N — 1}, Dy =
{-|],--- ,O,-+:, LSI), and Z. = {0,1}. As we use
PCDD for offline processing and its plaintext domain is
Zn, we define the operation [x], which transforms data
x from group Zy into the group Dy, ie.,

rly < | O<x<WN/2
x—-N, N/2<x<WN.
Moreover, the data [x|jy in group Dy can be directly
transformed into group Zy with x = [x] mod N.Itcan
be easily verified that group Dy and Zy are isomorphism.
To guarantee the security of secret sharing, two types
of data shares are used in the LightCom, called integer
share (belonged to Zn) and binary share (belonged to Z2).
For the integer share separation, RU only needs to execute
Share(m) described in “Additive secret sharing scheme
(ASS)” section, such that m = m, + --- + mp, where

share m; or binary shares m; to TPU i, and seals to UnS for
securely storage.

System initial and key distribution

The LightCom system should be initialized before achiev-
ing the secure computation. Firstly, the RU executes
KeyGen algorithm, and outputs public key pk = (N,g)
and private key sk = @. Then, the system uses KeyS to
split key 6 into P shares sk; = 0; (i = 1,---,P). After
that, for each TPU i in the cloud, it initials an enclave i,
builds a secure channel, and uploads the sk; to the enclave
i securely. Beside, the RU’s PCDD public key pk and pro-
gram C; for the specific function F are needed to securely
send to TPU i (i = 1,--- , P). Finally, the TPU i securely
seals the data pk, sk;, C; into UnS. As all the parameters
need to load to the TPU enclaves along with the data
shares according the specific functionality, we will not
specially describe it in the rest of the section.

Secure distributed decryption algorithm (SDD)

Before executing the TPU-based operation, we first con-
struct the algorithm called Secure Distributed Decryption
(SDD), which allows all the TPUs to decrypt PCDD’s
ciphertext. Mathematically, if enclave in TPU x contains
the encryption [| x]], the goal of SDD is to output x, which
contains the following steps: 1) The TPU enclave x estab-
lishes a secure channel with the other TPU enclave i(i ~
x). Then, enclave x sends |] x]] to all the other enclave i.
2) Once received [x], the TPU i uses PDec to get C7j,
and securely sends CT; to enclave x. 3) Finally, the TPU x
securely uses CT, with TDec algorithm to get x.

Secure TPU-based data seal & UnSeal

As TPU enclaves only provide an isolated computing
environment during the secure processing, the data in
the TPU enclave needs to seal to UnS for long-term
Liu et al. Cybersecurity (2020) 3:17

storage. Thus, we propose two algorithms called Seal
and UnSeal to achieve.

Seal(xj) : The TPU i encrypts the data share x
into [[x;]], then uses hash function H {0,1}/*¥ —
Zn with input the [~;]] associated with TPU t-time
period private key share sk to compute Sj; <—
A(x \|sk ||ZD;||t), where JD; is the transaction iden-
tity for [ x;]]. Then, TPU i sends [ x;]] with S;; to UnS for
storage.

UnSeal([x],S;,;) : The TPU i loads [ x;] with S;; to
the enclave i, and computes H([ x] I|sk? ||ZD;||t) to test
whether the result is equal to S;;. If the equation does not
holds, the algorithm stops and outputs L. Otherwise, the
TPU iuses SDD to get the share x;.

Random shares generation

The secret sharing based privacy computation requires
one-time random numbers for processing. Before con-
structing the TPU-based computation, we design a proto-
col called Random Tuple Generation Protocol (RTG). The
goal of RTG is to let TPUs cooperatively generate random
tuple 0, tae 0 € Zo andr; € Dy for each TPU i
(i = 1,---,P), such that r = —r26-1! + ia rV2-1
and rt) = wl @--@erw andr = r; +---+ rp holds,
where ¢ is the bit-length of random number r € Dy. The
RTG generates as follows:

1) The TPU 1 randomly generates wi), vee yw?

encrypts them as re] yee, ree], denotes them as
[cP ],---, [rr], and sends these ciphertexts to TPU 2.

2) The TPU i (i = 2,--- , P) generates ®, , me E Zy
and computes

€ LZ,

[eM] —peoya-w). (110 fe] ye =[c) rl].
Ifi 4 P, the TPU isends [r],--- , [r©] to TPUi+ 1.
Ifi = P, the TPU P computes

[r] —PrOP prep... [re].
3) For TPUi (i = P,,--- ,2), randomly generates r; € Dy
and computes [ r] <[r] -[—7;]], and sends [ r] to TPU
i—1.Once TPU 1 gets [ r], uses SDD to get r, and denotes

[r]n as r;. After computation, each TPU i (i = 1,--- ,P)
holds randomly bits 0, vee 0? € Zp» and integer r; €
Dy.

Share domain transformation

Binary share to integer share transformation (B21)

Suppose TPU i hold a bit share a; € Z2, where a; @--- @
ap = s € Zp, the goal of the protocol is to generate a
random integer share b; € Zy for each TPU i, such that
bj +---+ bp = 5. To execute B21, the TPU 1 randomly
generates b; € Zy, denotes x = bj and s = qj, encrypts
x as [| x]], s as [ 5]], and sends | x] and | s]] to TPU 2. After
that, the TPU i (i = 2,--- ,P — 1) generates b; € Zy and
computes

Page 9 of 21

[s] —[s]°™ «(1 Ls)" )™

=[s 6a], [«] [+] -L4],
and sends [x],[] 5] to TPU i + 1. Once received the
[x], | s], TPU P computes

[s] -[s]°°” (1) -[sI**)%”
=[s ap], [bp] Is] [x]*",
and uses the SDD to decrypt and gets bp.

Integer share to binary share transformation (I 2B)

Suppose TPU i hold an integer share a; € Zn, where a, +
--- + ap = § € Zp, the goal of the I12B protocol is to
generate a random bit share b; € Zz for each TPU i, such
that b;} ®--- @ bp = s. To execute I2B, the TPU 1 lets
y = aj, encrypts yas [| y]], and sends the ciphertext to TPU
2 for computation. After that, the TPU i (i = 2,--- ,P)
uses the share to compute [ y] <[ y] -[a,;]. Ifi 4 P, TPU
i sends [| y] to TPUi+ 1. After that, denote [ s] <[y],
and each TPU i (i = P,---,2) generates 6b; € Zo and
computes

Is] <[s]°~°? -(l1] fs] )" =[s @ by],

and sends | s]] to TPU i — 1. Once received | s]], TPU 1
uses the SDD to decrypt [| s]] and denotes the result s as by.

TPU-based secure outsourced computing toolkits
in the cloud

In this section, we introduce and construct the commonly
used secure outsourced binary and integer computation
sub-protocols for a single cloud.

Secure computation over binary shares
Secure bit multiplication protocol (SBM)
The SBM can achieve plaintext multiplication on bit shares
and output bit shares, i.e., given two shares r;,; € Zo (i =
1,--- ,P) for TPU ias input, SBM securely outputs f; € Z2
for TPU i, such that OF, fi = (OL) A (BE, vv.
Offline Stage: All the TPUs initialize their enclaves and
load the public parameters to UnS. For enclave 1, gen-
erate aj,6; € Zo, compute c = ay - by € Zp». Encrypt
ai], 61]] and [c]], and denote them as [| a], [ 6], [c],
respectively. After that, TPU enclave i (i = 1,--- ,P — 1)
sends [ a], [6], [ c] to enclave i+ 1, TPUi+ 1 generates
aj;11,6;,; and computes

[A] [a] [fc] =[a-a— 6),

[B] —[ 6] -[c]*-*=[6-aQ-a)],

[C] —[1)-(ay*™ -[o]** fc] =[ d—6)-G-a],

Ic] <] c] ott Gb) ll Cy tit bent Apt bint
[BIH OP =I (a @ ay) A (6 @ bi41) I.

[a] —faJ?~% . (fafa) =f @ aiid,
Liu et al. Cybersecurity (2020) 3:17

[6] oy?) . (Qa Loy’)! = 6 @ baal.
After the above computations, enclave i (i = P,--- ,2)
randomly generates c¢; € Zy and computes [c] <—
[cJC- «(diy Pe!) =[c @ ¢,]. When the TPU 2
sends [cl] to TPU 1, the TPU 1 uses SDD to get ¢ and
denotes as cj < c. After the above computations, each
enclave holds aj, 6;,¢;, which satisfies a, 68 --- Pap = a,
b6,@---@bp = b,c, ®---Oep =candc=aAb. Finally,
each TPU i seals aj, 6;, c¢; to UnS for storage individually.
Online Stage: For each TPU i (i = 1,--- ,P), load the
a;,6;,¢; into the enclave i. Then, compute X; = 4; ® q;
and Y; = y; © 6;. Securely send X; and Y; to other enclave
JG = 1,---,P3;j # i). After receiving other x; and Y;,
each TPUs computes X = OD. X and Y = PI Yj.
For TPUi i = 1,--- ,P — 1), compute f; <— cj @ (6; A
X) ® (a; A Y). Then, TPU P computes fp <— cp @ (bp A
X)P(ap AY) B(X AY). Here, we denote the protocol as
(f) — SBM((r), ()).

Secure bit-wise addition protocol (BAdd)

The BAdd describes as follows: the TPU i holds bit shares
al, ree, al) of £ bit-length integer a and 9, ree, ri? of £
bit-length integer r. The goal is to compute yi en ae
such that y = a+r, where y = —n2°-1 + ia yV-1,

andr) = wl ox! Q: er!) The idea is easy and simple:

use the binary addition circuit to achieve the addition, i.e,
compute the integer addition as h = a” @r” @ ce and
SD = (a) nr) @ (a? @ ce) A) forj = 1,---,2.
The procedure of BAdd works as follows:

1) For each TPU i (i = 1,---,P) and each bit posi-
tion j = ol

av @ vy > and a) <— SBM((a”), (t)). After using the
computation of SBM, it indeed computes e? = a) Ar.

2) Each TPU i sets c) < Oand yi? <— at”, Then, for
j= 2,---,€, all TPUs jointly computes

(Q9-Y) — sBm((oY~P), (eF~Y)),

,, all the TPUs jointly compute <_

Moreover, for each TPU i locally computes

D 99) we andy? <a”

C; j De; ”)

and tj, Be; .

and outputs ny for all j.

Secure bit extraction protocol (BExt)
Suppose TPU i (i = 1,---, 7) contains an integer share
u;, Where u = ey u;. The goal of BExt is to out-
put the bit extraction shares ul, .. ; uP for each TPU i
(i =1,---,P), where u = _ ye Py at u%2/—! and
u = DO. uv ’. The BExt also contains offline/online
phase which describes as follows:

Offline Phase: Execute RTG to get ,. - se) and 7;
for party i. Then, all the TPUs need to jointly compute

j=l,-:-

Page 10 of 21

a... a © Zo, such that a? @---@BaW = 0. Firstly,

TPU 1 1 randomly generates a... sa € Zp and let

) = av? for j = 1,---€. After that, the TPU i generates

al, - a) € Zy, computes

pe] pee” (Cay POP)? =f Mea,

and sends these ciphertexts to TPU i + 1. Once the
pt-P],---, [t@] are received, the TPU P uses the
SDD to decrypt, gets t,--- ,t™ and denotes them as

a, ree, a. After that, each TPU i seals Oi. vey 0, Vis
oe al? j in UnS, respectively.

Online Phase: The TPU i computes yj, = uj — Fj,
encrypts v; and sends [ v;]] to TPU P. After received all
the encryptions, the TPU P computes [ v]] — Me. Lvil
and executes SDD to get the v, and computes [v|jy. Then,
TPU P generates its twos complement binary representa-
tion —),.-- ,»p©, and computes vv <— pV) ea, where
,£. Other TPU i (i = 1,--- ,P — 1) keeps other
pi <— a, vey pi? <— al) unchanged.

After that, all the TPUs jointly compute

(uu, — , Up) <—_ BAdd(01, —

, Op; Tt, ve stp),
where uj = (u)?, a?) bj = (0(?, 0?) a
,. (1)

pret yt ). Finally, the BExt algorithm outputs U;
.u?) for TPUi=1,---,P.

a.

Secure integer computation

Secure multiplication protocol (SM)

The SM achieves integer multiplication over integer
shares, ie., given shares x;,y;j (i = 1,---,P) for TPU
i as input, SM securely outputs f; for TPU i, such that
fi = x-y, where data shares xj, y; satisfy x = 77, x;
and y = Yo Ji.

Offline Stage: All the TPUs initialize their enclaves
and load the public parameters to the UnS. Then, for
the enclave 1, it generates a,,b,; ©€ Dy, computes
Z = a, - by, encrypts [a;],[4:],[z], and lets them
be [a], [4], c], respectively. After that, enclave i (i =
1,---,P—1) sends [a], [ b],[ c]] to enclave i+ 1, TPU
i+ 1 generates a;41,bj;,; and computes

Lol Del Daina - diya] Lal’ -L 1,

Lal —La] -Lai4i1], 04] —1 4) 14411.

After the computation, for i = P,---,2, TPU enclave
i generates c; € Dy and computes [c] =[c] -[c]*?.
After the computation, the TPU 2 sends [c]] to TPU 1.
Then, TPU 1 uses SDD to get c and denotes the final result
[c]n as c,. After the above computation, each enclave hold
aj, bj, cj, such that [a, +---+ap|n = fa|n, |b) +--- +
bp\n = [b\n, [c1 +--+ +cep|n = [clw andc =a-b
Liu et al. Cybersecurity (2020) 3:17

mod WN. After the computation, each TPU enclave i seals
aj, bj, c; to UnS for storage individually.

Online Stage: TPU i loads the aj, b;, cj into the enclave
i. Then, compute X; = x; — aj and Y; = y; — b;. Securely
send X; and Y; to other enclave j = 1,---,P;j 4 i).
After receiving other X; and Y;, the each TPU i computes
X=>°2,Xj;andY = 7, Y;. After that, for each TPU i
(i= 1,---,P—1), compute fj — [cj + b:X + ajY |n. For
TPUP, compute fp <— [cp +bpX+apY+X-Y|n. Here,
we denote the protocol as (f) <— SM((x), (y)).

Secure Monic monomials computation (SMM)
The SMM protocol can achieve monic monomials com-
putation over integer shares, i.e., given a share x; (i =
1,---,P) and a public integer number k for TPU i
as input, SMM securely outputs f; for TPU i, such that
rf = «*, where data shares x; satisfy x = 77, xj.
The construction of the SMM is list as follows: Denote k as
binary form €;,--- , €;. Initialize the share f; < x; for each
TPU i. For 7] = €—1,---,1, compute (f*) — SM((f), (f)).
If &; = 1, compute (f) < SM((f*), (x)). Otherwise, let
(f) <— (f*). Here, the algorithm outputs (f) and denotes
the protocol as (f) <— SMM((x),k).

Secure binary exponential protocol (SEP>2)

The SEP» can achieve exponential over binary shares with
a public base, ie., given a binary share x; € Z2 (i =
1,--- ,P) anda public integer 6 for TPU ias input*, SEP2
securely outputs an integer share f; ¢ Zy for TPU i, such
that 77, ff = BY, where r = Qj ti.

Offline Stage: All the TPUs initialize their enclaves
and load the public parameters to the UnS. Then, for the
enclave 1, it generates a; € Zo, encrypts a; as [ a;]], and
lets it be [aj]. After that, enclave i (i = 1,---,P — 1)
sends [ a]] to enclave i+ 1, TPUi+1 generates aj; € Zp,
computes

[a] La}? (Qi) La] 4 =a @ ail,

Once | al] is received, TPU P computes

[>] =a)’ -(l1)-La]**) = 8 -a+a-oa)]
=[ 6°], 06°) =o] (11) Lal")?
=[a+ 60 -a)]=[f"].

After the computation, fori = P,--- ,2, TPU i gener-
ates b;,b; € Dy and computes [ db] =[ J] -Lb,]—! and
[| o*] =[ b*] -I br ~1. After the computation, the TPU 2
sends [| b]] and [ b*]] to TPU 1, and TPU 1 uses SDD to get
b, b* and denote them as b, and b7, respectively. After the
above computation, each TPU i holds aj, b;, which satisfies
a10---@ap =a,b,+->-+bp = B%, be +---+b% = Bi-",
After the computation, each TPU i seals a;, b; to UnS for
storage individually.

 

148 is a small positive number which satisfies gcd(B, N) = 1.

Page 11 of 21

Online Stage: TPU i loads the data share ry; and ran-
dom shares aj, b; into the its enclave. Then, TPU i locally
computes X; = zr; © aj. Securely send X; to other enclave
JG = 1,:::,P;j # i). After receiving other X;,
each TPU i locally computes X = @P, X; and ff <—
[(b*)* - (bj) * |n. We can easily verify that ey fi =
BU-VYeoa)t+al—rea) — Br, Here, we denote the protocol
as (f) <— SEPo({r), B).

Secure integer exponential protocol (SEP)

The SEP can achieve exponential over integer shares with
a public base, i.e., given an integer share xj € Dy (i =
1,---,P) and a public integer 6 for TPU i as input, SEP
securely outputs shares fj € Dy for TPU i, such that
fi = 6%, where data shares x; satisfyxx = )7/_, x; and
x is relative small positive number with ¢ bit-length.

i) Compute (f1,---,fp) <_ BExt(x1,---,xp), where
B= (r?,--- 2) for TRU i = 1,---,P, andr? =
OP, WY, and « = i -t,

ii) Execute (f) — SEP2((r), B). For j = 2,--- ,£, com-
pute (fj) <— SEP9((r”), B), (f°) <— SMM((f;),2/~+), and
(f) — SM((f), (f°)). The SEP outputs (f), and we denote
the protocol as (f) <— SEP((x), B).

Secure comparison protocol (SC)

The SC can securely compute the relationship between
integer uw and v, where each TPU i holds shares u; and
vj, where u = uy +-:-+up,v = v+-:-+ vp. The
construction of SC is listed as follows:

i) Each TPU i (i= 1,--- , P) locally computes w; = uj; —
v;. After that, all TPUs jointly compute

(101,---,t0p) <— BEXxt(wj,---,wp).

ii) As we use twos complement binary representation,
the most significant digit of u — v will reflect the relation-
ship between the uw and v. After the above computation,
TPU i outputs wi)
wD of w = S72, w; decides the relationship of u and
v, specifically, if B?, wi)
Otherwise, it denotes u < v.

€ ;. The most significant digit

= 0, it denotes u > v.

Secure equivalent protocol (SEQ)

The goal of secure equivalent protocol SEQ is to test
whether the two values u,v are equal or not by giving
the shares of the two values (uz), (v). Mathematically, given
two shares (u) and (v), SEQ (Liu et al. 2016a) outputs
the shares f; for each TPU i (i = 1,--- , P) to determine
whether the plaintext of the two data are equivalent (i.e.
test u = v. If OP, f; = 1, then u = 1; otherwise, u # v).
The SEQ is described as follows:

i) All the TPUs jointly calculate

(t]) < SC({u), (v)); (t) <— SC((v), (u)).
Liu et al. Cybersecurity (2020) 3:17

ii) For each TPU i, it computes fj = t}; ® t) ; locally, and
outputs f; € Zo.

Secure minimum of two number protocol (Min 2)
The TPU i (i = 1,--- , P) stores shares (x) and (y) of two
numbers x and y, The Ming protocol outputs share (B)
of minimum number B, s.t., B = min(x,y). The Ming is
described as follows:

i) All the TPUs can jointly compute

(u) <— SC((x), (y))3 (u) <— B21 ((u)); (X) — SM((x), (4);

(Y) <— SM({y), (u)).
ii) The TPU i computes locally and outputs Bj = y; —

Y; + Xj.

Secure minimum of H numbers protocol (Miny)
The goal of Miny is to get the minimum number among H
numbers. Given the shares x1 j;,--- ,*H,; for TPU i, the goal
is to compute the share x7 for TPU i such that x* stores
the minimum integer value among 1, --- ,x, where x* =
ey x, xj = ey xi; for j = 1,--- ,H. The Miny exe-
cutes as follows: Each TPU i puts x1;,--- ,xz; into a set
S;. If £(S;) = 1, the share remaining in £(S;) is the final
output. Otherwise, the protocol is processed according to
the following conditions.

e If £(S;) mod 2 = Oand L(S;) > 1, 1) set S; <— 9; 2)
for j = 1,--- ,£(S;)/2, compute

(xj) < Ming((xy-1), (x2;)), (1)

and add x;; to the set S’; 3) clear set S; and let S; <— Sj.

e If £(S;) mod 2 £ 0 and L(S;) > 1, take out the last
tuple xc,s,)-1, from set S; s.t., £(S;) mod 2 = 0. Run the
above procedure (£(S;) mod 2 = 0 and L£(S;) > 1) to
generate set S’. Put xc s,)-1, into a set S; and denote S; <—
Si.

After computation, each set S; in TPU i only contains
one element and we denote it as x. Thus, we denote the
protocol as (x*) <— Maxy((x1),--- 5 (xH)).

Security extension of integer computation

The above secure computation only considers data pri-
vacy. Two types of information can be leaked to the
adversary: 1) the access pattern of function’s input, and 2)
the access pattern of RU’s result retrieve. Here, we give
two security extensions to achieve access pattern hiding
and private information retrieval, respectively.

Achieve input access pattern hiding (APH)

As data are directly sealed in the UnS, the adversary
may analysis the access pattern of UnS without knowing
the function's input. Suppose the system contains H data
x},°++,«7, € Dy. The data shares x;; are hold by each
TPUiGj=1,---,H;i =1,---,P), such that 41 +---+
x,P = x; To achieve access pattern hiding, the homo-
morphic property of PCDD can be used. Specifically, the

Page 12 of 21

RU uploads [ a;],--- , | ay] to each TPU i, s.t., for a spe-
cific l < y < H, it has a, = 1, and otherj ¢ y and
1 <j < H, it holds a; = 0. Then, the goal of the algo-
rithm is to securely select the shares of x,,; from the input
shares, and constructs as follows:

1) Obviously select encrypted shares. Each TPU initial-
izes an enclave. Then, for each TPU i (i = 1,---,P),
compute

 bi]] [Lai] -[[ ao]? ----- | ay

2) Securely update share [ b;]| for TPU i. Without any
share update, the adversary can still know the access pat-
tern once the ciphertexts are decrypted. Thus, all the
shares should be dynamically updated before the decryp-
tion.

The TPU i picks random numbers 6;),--- ,d;p € Zn
such that 633 +---+6;p =0O mod N, and then encrypts
6,; and sends [[ 6;;]] to TPU enclave j. Once all the update
shares are received, TPU i computes

1671-14) 151] 142] ----- [6p] mod N’.

Finally, each TPU i uses the SDD to get b* and denotes
[b* | as the final share output.

mod N?.

Achieve private information retrieve (PIR)

If the computation results are needed, the RU will let
the TPU send the data shares back via a secure chan-
nel. However, if one of the TPU has been compromised,
the adversary will know the retrieve access pattern even
if the data are encrypted. Suppose the system contains
H data x7,---,«;, € Dy. The data share x;; are hold
by each TPUi G = 1,---,H;i = 1,---,P), such that
xj,1 +++: +4;,p = x*. Thus, to achieve the private infor-
mation retrieve, the RU uploads [a;]],--- , | a] to each
TPU, s.t., for a specific 1 < y < H, it has a, = 1, and
other j # y,1 < j < H, it holds a; = 0. The goal of
PIR is to let RU privately retrieve x,. Then, the algorithm
computes among all TPUs as follows:

1) For each TPU i, compute

 bi]] [Lai] -[[ ao]? ----- | ay

2) TPU 1 denotes [| b*]] <-[ b1]], and sends [[ b*]] to TPU
2. Then, each TPU i = 2,---,P, computes [ b*] <—
[ b*] -[b;] mod N?. If i = P, then send [b*] to RU.
Otherwise, || b*]] is sent from TPU i toi + 1. Finally, RU
uses the Dec to get the b*, and denotes x, < [b*]|n as
final output.

mod N?.

Secure floating point number computation

Data format of floating-point number

To achieve the real number storage and computation, we
can refer to the IEEE 754 standard to use Floating-Point
Number (FPN) for real number storage. To support the
LightCom, we change the traditional FPN and describe
Liu et al. Cybersecurity (2020) 3:17

the FPN by four integers: 1) a radix (or base) 6 > 2; 2)
a precision n > 2 (roughly speaking, 7 is the number of
“significant digits” of the representation); 3) two extremal
exponents @yyj, and €yaqx Such that eyjn < 0 < Cmax. A
finite FPN a in such a format is a number for which there
exists at least one representation two-tuple (m,e) with
public parameters 6, 7, €mins Cmax, Such that,

a=-=m- pooh

e misan integer which satisfied
—B"+1<m < B" —1.Itis called the integral
significand of the representation of x;

e eis an integer such that ein < e < Cmax, called the
exponent of the representation of a.

As only the significand and exponent contains sensitive
information, we assume all the FPNs have the same public
base 6 = 10, and use the fix bit-length to store the inte-
ger m. Thus, to achieve the secure storage, the RU only
needs to random share the @ into a] = (m},€)),°+:,a@p =
(mp,ep), and sends a; to TPU i for storage, respectively.

For the secure FPN computation, if all the FPNs are
transformed with the same exponential, we can directly
use secure integer computation methods introduced in
“TPU-based secure outsourced computing toolkits in the
cloud” section. Thus, the critical problem to achieve
secure FPN computation is how to allow all the FPNs
securely transformed with the same exponential. Here, we
first construct an algorithm called Secure Uniform Com-
putation (UNI) and then achieve the commonly-used FPN
computations.

Secure uniform computation (UNI)
Assume each TPU i(i = 1,---,P) stores into aj; =
(mj,i,@,;) » the goal of UNI is to output qj = (mi; i, e*)
for j = 1,---,H, and the construction of UNI can be
described as follows:

i) All the TPUs jointly compute

(e") <— Miny((e1),--- , (e#)). (2)
ii) Each TPUs locally computes (cj) = (e) — (e7).
As @& — is a relative small number, TPUs jointly

e*
executes (10%-©") —
SM((109~*’), (m))).
After computation, all the (a1),--- , (az) will transform
to (a;),--+ , (a@z,) which shares the same e*, where (a;') =
((m), (e*)) for j= 1,--- ,H.

SEP((cj),10) and (mr) <—

Computation transformation

The secure floating-point number computation can be
transformed into the secure integer computation proto-
cols with the usage of UNI. Formally, given FPN shares
(aj) = ((mj), (e)), (for j = 1,--- ,H), we can first compute

((a}), a) (471)) <—— UNI((a1), mrt (au)),

Page 13 of 21

where (a;') = ((m;), (e*)). Then,

where SZF denote secure integer computation proto-
col designed in “IT PU-based secure outsourced computing
toolkits in the cloud” section, and (yj),--- , (Ve) can be
either integer shares or binary shares according to the
function type. If the SZF is the SC and SEQ, then the
STF output the binary share (t)*) as the final output, and
we denote these two algorithms as secure FPN compari-
son (FC) and secure FPN equivalent test protocol (FEQ).
If the SZF is the SM, SMM, Min and Miny, then the
STF outputs the integer share (y*), and denotes (j*) =
((y*), (e*)) as the secure FPN’s output, and we denote
above four algorithms as secure FPN multiplication (FM),
secure FPN monic monomials computation (FMM), secure
minimum of two FPNs protocol (FMin2), and secure min-
imum of H FPNs protocol (FMiny), respectively. Specif-
ically, for the multiple FPN addition (FAdd), given FPN
shares (aj) = ((mj),(@)), (for 7 = 1,---,H), we can

first compute (4}),--- , (47,) with the UNI, where (a;) =
((m;); (e*)). Then, compute (y*) <— i 1(™;) and denote

the final FPN addition result as (v) = ((y*), (e*)).

Secure extension for FPN computation
Similar to the secure integer computation, we have the
three following extension for LightCom.

Access Pattern Hiding: As all the secure FPN computa-
tion can be transformed in to secure integer computation
with the help of the UNI, we can also use the same method
in “Achieve input access pattern hiding (APH)” section
to achieve input access pattern hiding for the secure FPN
computation.

Achieve Private FPN Retrieve: In out LightCom, one
floating-point number is stored as two integer numbers.
Thus, we can use the method in “Achieve private infor-
mation retrieve (PIR)” section to privately retrieve integer
for twice to achieve the private FPN retrieve.

Functional extension for LightCom

Non-numerical data storage and processing

For the non-numerical data storage, the traditional char-
acter encodings with Unicode (Consortium and et al.
1997) and its standard Unicode Transformation Format
(UTF) scheme is used which maps a character into an
integer. Specifically, for secure storage, use UTF-8 to map
the character into 32-bit number x, randomly splits x into
x1,°+:+,xp, such that x] +---+x%p = «x, and sends a; to
TPU i for processing. In this case, all the non-numerical
data processing can be transformed into secure integer
computation which can be found in “TPU-based secure
outsourced computing toolkits in the cloud” section. For
the secure storage, each TPU i securely seals the share
Liu et al. Cybersecurity (2020) 3:17

a; into the UnS with the algorithm Seal in “Secure
TPU-based data seal & UnSeal” section. Once the data
shares are needed for processing, TPUs need to use
UnSeal algorithm to recover the message from UnS.

Extension of multiple user computation

All the secure computations in the previous section are
designed for the single user setting, i.e., all the data are
encrypted under a same RU’s public key. If all RUs want
to jointly achieve a secure computation, each RU jj =
1,--- ,w) executes KeyGen to generate public key pk;
and private key is sk; locally. Then, RU j uses KeyS to
split key sk; into P shares (sk;), and sends these shares
to TPUs in the cloud. Assume RU /’s ciphertext [| x;] pk; is
securely stored in UnS, TPUs can get data shares (x;) with
UnSeal and achieve the corresponding secure computa-
tions GenCpt in Section 3 with these shares.

Security analysis

In this section, we first analyze the security of the basic
crypto primitives and the sub-protocols, before demon-
strating the security of our LightCom framework.

Analysis of basic crypto primitives

The security of secret sharing scheme

Here, we give the following theorem to show the security
of the additive secret sharing scheme.

Theorem 1 An additive secret sharing scheme achieves
an information-theoretic secure when the P participants
can reconstruct the secret x € G, while any smaller set
cannot discover anything information about the secret.

Proof The shares Xj,--- ,Xp are selected with random
uniform distribution among ? participants such that X; +
---+ Xp = m € G. Even the attacker A holds P — 1
shares, (s)he can only compute x’ = ye X;, where X; is
selected from X1,--- , Xp. The element x is still protected
due to the x = x’+X%,. Since random value X, is unknown
for A, it leaks no information about the value x. O

Theorem 2 A proactive additive secret sharing scheme
achieves an information-theoretic secure if the scheme sat-
isfies the following properties: I. Robustness: The newly
updated shares correspond to the secret x (i.e., all the new
shares can reconstruct the secret x). II. Secrecy: The adver-
sary at any period knows no more than P shares (possible
a different share in each period) learns nothing about the
secret.

Proof The data shares x in time period ¢ are stored

in party i, s.t., ey x = 4. Each party i generates

shares 5”, vee 50>, which satisfies 5? ttt 5 = 0

Page 14 of 21

mod N. Thus, the new shares denote xin) — x +

l

5) feet 5, and satisfy 77, xr =P, xi +

Poe 5 = x which the robustness property hold.

To guarantee the secrecy property, the data shares in
time period ¢ can achieve the information theoretic secure
according to the Theorem 1. Even adversary can get P — 1
shares in each time period ¢t (t < ¢*), the adversary can
compute x = x—Xip) = Lic, X, where X5 is the
non-compromised share in time period ¢. The adversary
A* still cannot get any information from x,..- , 4)
as Sp» vee Opp, are independently and randomly
generated and cannot be compromised by the adversary.
Thus, the secrecy property holds. O

The security of PCDD
The following theorem gives the security of our PCDD.

Theorem 3 The PCDD scheme described in
“Additive homomorphic encryption scheme” section is
semantically secure, based on the assumed intractability
of the DDH assumption over Zy.

Proof The security of PCDD has been proven to be
semantically secure under the DDH assumption over Z,,,
in the standard model (Bresson et al. 2003). L

Security of TPU-based basic operation

Theorem 4 The RTG can securely generate random
shares against adversary who can compromise at most
P —1TPUs, assuming the semantic security of the PCDD
cryptosystem.

Proof For each TPU i (0 < i < P), only the PCDD
encryption (reP],---, [cr] are sent to TPU i+ 1. After
that, PCDD encryption [7] is sent from TPUi+ 1 toi.
According to semantically secure of the PCDD (Theorem
3), the TPU i+ 1 cannot get any information from
the ciphertext sent from TPU i. Even the adversary can
compromise at most P — 1 TPUs and get the shares

ol, ree, 9, r;, (s)he cannot get the secret r,--- ,r,r
due to r), ree, rl), rp are unknown to adversary accord-
ing to the security of Theorem 1. O

The security proof of the secure share domain trans-
formation in section, secure binary shares operation in
section, secure integer computation, and secure FPN
computation are similar to the proof of Theorem 4. The
security of the above operations are based on the seman-
tic security of the PCDD cryptosystem. Next, we will
show that AHP and PIR can achieve its corresponding
functionality.

Theorem 5 The AHP can securely achieve the access
pattern hidden for the function input under the semantic
security of the PCDD cryptosystem.
Liu et al. Cybersecurity (2020) 3:17

Proof In the select share phase, all a1,---,ay are
selected and encrypted by RU, and are sent to TPUs for
processing. The adversary cannot know the plaintext of
the ciphertext due to the semantic security of PCDD. Also,
the shares are dynamically updated by computing b? <
bi + 61, + 62; +--+ 6p; mod N. As 4); is randomly
generated by TPU i and is sent from TPU j to TPU i. It
is hard for the adversary to recover b;; even the adversary
compromises the other P — 1 TPUs due to the secrecy of
Theorem 2. Thus, it is still impossible for the adversary to
trace the original shares with the update shares, which can
achieve the access pattern hidden. O

Theorem 6 The PIR can securely achieve the private
information retrieve under the semantic security of the
PCDD cryptosystem.

Proof In PIR, all a,--- , ay are selected and encrypted
by RU, and sent to TPUs for processing. After that, [| b*]
is transmitted among TPUs. As all the computations in
the PIR are executed in the ciphertext domain, the adver-
sary cannot know the plaintext of the ciphertext due to
the semantic security of PCDD, which can achieve private
information retrieval. LJ

Security of LightCom

Theorem 7 The LightCom is secure against side-channel
attack ifte+ty+tq < P-ta where t,, ty and tq are the run-
time of secure computation GenCpt, private key update,
and data share update, respectively; tq is the runtime for
attacker successfully compromising the TPU enclave; P is
the number of TPUs in the system.

Proof In the data upload phase, RU’s data are randomly
separated and uploaded to TPUs via a secure channel.
According to Theorem 1, no useful information about
the RU’s data leaked to the adversary by compromising
P —1TPUs enclaves. For the long-term storage, the data

Page 15 of 21

shares are securely sealed in the UnS with PCDD crypto-
system. With the Theorem 3, we can find the encrypted
data shares are semantically secure stored in the UnS.

In the secure online computing phase, all the cipher-
texts are securely loaded to the TPUs with UnSeal. Then,
all the TPUs jointly achieves the secure computation with
the GenCpt. During the computing phase, the system
attacker can launch the following three types of attacks:
1) compromise the TPU enclave: the adversary can com-
promise a TPU enclave to get current data shares and
private key shares with the time t,; 2) store the old pri-
vate key shares: the adversary tries to recover the RU’s
private key with current and old private key shares. 3)
store the old data shares and try to recover the RU’: orig-
inal data: the adversary tries to recover the RU’s data
with current and old data shares. To prevent the first type
of attack, RU separates and distributes his/her own data
among P TPUs. Unless the adversary can compromise all
the TPU enclaves at the same time, A can get nothing
useful information from compromised shares according
to Theorem 1. Thanks to the secrecy property of a proac-
tive additive secret sharing scheme in Theorem 2, it is
impossible for the adversary to recover the private key and
RU’s data by getting ? — 1 TPUs at each time period.
As the TPU enclaves are dynamically released after the
computation, the attacker needs to restart to compromise
the TPU enclaves after the enclaves are built for secure
computation.

Thus, the adversary fails to attack the LightCom system
if the data shares are successful seals in the UnS, and all
the TPU enclaves are released before the adversary com-
promises all the enclaves in the secure computation phase.
In this case, the LightCom is secure against adversary
side-channel attack iff, + ty + tg < P- ta. O

Evaluations
In this section, we evaluate the performance of LightCom.

 

Running time (ms)
nN ao P~ oa
So o o So

=
o

=
ao
SY

2500

   

1500 v
-, 1000 exer
Uy 0 500 param

~10)

Fig. 4 Simulation results of Basic Protocols

 

 

4
Misemontine) 10

 
   
   

    
 

-}- SBM(Offline)
-C BAdd(Offline)
4 SM(Offline)

-B-SEP,,(Offline)

Online Runtime (us)
Offline Runtime (ms)

eee 4107

50

 

 

 

3 5 7 9 11
The Parameter P

(a) Performance with N (Vector Length (b) Performance with Encrypted Vector
Length (N = 1024)

 
 

Liu et al. Cybersecurity

(2020) 3:17

 

 

1000 1 1 —
HERTG(Online) -=-MIN, (Offline)

TEMIN, (Online) -c UNIOffline)

| GlAPH(Online) uae 0
Tu ntontiney oor -

  
  
    
   
   
   
   
  
  
 
 
 

800
saan

600- g--

400;

Online Runtime (ms)

200;

 

0
3 5 7 9 11

The Parameter P
(a) Runtime with P (€ = 32,
||| = 1024, H = 8)

1000

 

HBRTG(Online) -=-MIN, (Offline)
EEMIN, (Online) ~> UNKOftline)
800 | GRAPH(Online) eee ro)
[uniontiney or

or

°°
o

600- g--

400;

Online Runtime (ms)
3
ra

Offline Runtime (ms)

200;

 

0

  

3 5 7 9 11

The Parameter P
(c) Runtime with P (€ = 32,
||| = 1024, H = 8)

 

800 10°

HBAdd(Online)

700 | Lsmm(Online)
= BAdd(Offline)

600 | © SMM(Offline)

    
  

Online Runtime (us)
&
o
3.
_
Offline Runtime (ms)

 

 

3 5 7 9 11
The Parameter P

(e) Runtime with P (€ = 32,
||. N || = 1024, H = 8)

 

a
S
So
oS

7
Hisc(online) -=-sccottline)
[EMIN, (Online) ~¢ MIN, (Offline)

 

o
a
o
o

 

> o
@ 3000 £
© o
E 2500 £
= =
2 é
< 2000
2 =
5 1500
1000
500
16 24 32 40 48 56 64
The Parameter |
(g) Runtime with @ (P = 3,
||. || = 1024, H = 8)
4500
HsAdd(oniine)
[smmooniine) “ 4000
-= BAdd (Offline) °
S : :
_ SMM(Offline) uo 3500 >
@ i
3 =
> 3000 @
E &
= 2500 §
E &
2 2000 ¢
= =
6 6

 

16 24 32 40 48 56 64
The Parameter |

(i) Runtime with @ (P = 3,
\|N|| = 1024, H = 8)

400 -
HERTG(Online) -=-MIN, (Offline)

   

350 | HEMIN, (Online) -o UNI(Offline)
[Quntonline)

w
S
o

o

o

Nn
a
o

a
o

Online Runtime (ms)
3 8
o o

Offline Runtime (ms)

a
o

16 24 32 40 48 56 64
The Parameter |

(k) Runtime with @ (P = 3,
||. N || = 1024, H = 8)

 

>
So
So

  
    
  
 
  

7 7 1 1 1
HisBm(Oniine) 2
14} Hilsmontiney “ 350
[SEP (Online)
_.12| © SBM(Offline) 300 >
g -© SM(Offline) £
> 10 | “SEP, (Offline) 250 @
£ E
= =
Bf 200
z &
£6 150 £
§ =
4 100 9
2 50
0

 

 

 

°

The Parameter P
(b) Runtime with P (€ = 32,
||. N'|| = 1024, H = 8)

7000

 

MBExt(Offline)
Lsmmottiney
© BExt(Online)
-© SMM(Online)
5000 | “8 SC(Online)

6000
18

4000

3000

Offline Runtime (ms)
o Fe} > o
Online Runtime (us)

Nn
S
S
o

1000

 

 

b OH ow

0
3 5 7 9 11

The Parameter P
(d) Runtime with P (€ = 32,
||N'|| = 1024, H = 8)

30

 

7
HEBExt(Online) -¢-BExt(Offline)
Gsep(Online) -C SEP(Offline)

 

Online Runtime (ms)
Offline Runtime (ms)

16 24 32 40 48 56 64
The Parameter |

 

       
  
     

    

 

(f) Runtime with @ (P = 3,
||. V|| = 1024, H = 8)
600 -— 4500
HBAdd(Online)
[osmmonline) 4000
= BAdd(Offline)
-© SMM(Offline) 3500 —
gy é
Ss =
® 3000 o
£ E
2 2500 3
£ 2000 £
5 =
° 1500 9
1000
500
16 24 32 40 48 56 64
The Parameter |
(h) Runtime with @ (P = 3,
|| V|| = 1024, H = 8)
7 4000
Hisc(online) -2-SC(Offline)
[QMIn, (Online) -o MIN, (Offline) 3500
Boo 3000 2
oa o
£ 2500 E
515 5
2 2000 °
=10 =
6 1500 6
5 1000
0 500
16 24 32 40 48 56 64
The Parameter |
(j) Runtime with € (P = 3,

|| N'|| = 1024, H = 8)

 

-4- MIN, (Online)
> APH(Online)
= PIR(Online)
-2- UNK(Online)

°.
Be

 

 

Runtime (ms)

a

 

(1) Runtime with H (P = 3,
|| N || = 1024, = 32)

Fig. 5 Simulation results of LightCom

 

 

Page 16 of 21

Experiment analysis

For evaluating the performance of the LightCom, we build
the framework with C code under the Intel® Software
Guard Extensions (SGX) environment as a particular case
of TPU!°. The experiments are performed on a personal
computer (PC) with a 3.6 GHz single-core processor and
1 GB RAM (we use the single-thread program) on a vir-
tual machine with a Linux operation system. To test the
efficiency of our LightCom, there are two types of metrics
are considered, called runtime and security level (asso-
ciate with PCDD parameter N). The runtime refers to the
secure outsourced computation executing duration on the
server or user’s side in our testbed. The security level is
an indication of the security strength of a cryptographic
primitive. Moreover, we use SHA-256 as the hash function
H(-) in LightCom. As the communication latency among
CPUs is very low (use Intel® UltraPath Interconnect (UPI)
with 10.4 GT/s transfer speed and theoretical bandwidth
is 20.8 GB/s)!©, we do not consider the communication
overhead as a performance metric in our LightCom.

Basic crypto and system primitive

We first evaluate the performance of our basic opera-
tion of cryptographic primitive (PCDD cryptosystem) and
basic system operations (Seal, UnSeal and SDD proto-
col). We first let N be 1024 bits to achieve 80-bit security
(Barker et al. 2007) to test the basic crypto primitive and
basic protocol. For PCDD, it takes 1.153 ms to encrypt a
message (Enc), 1.171 ms for Dec, 1.309 ms to run PDec,
5.209 ws to run TDec. For the basic system operations
(See Fig. 4), it takes 1.317 ms for Seal, 1.523 ms for
UnSeal, and 1.512 ms for SDD (P = 3). Moreover, Seal,
UnSeal and SDD are affected by the PCDD parameter
N and the number of TPUs P (See Fig. 4a and b respec-
tively). From Fig. 4a and b, we can that the parameter N
will significantly affect the runtime and communication
overhead of the protocols.

Performance of TPU-based integer computation

Generally, four factors affect the performance of TPU-
based integer computation: 1) the number of TPUs P;
2) the PCDD parameter N; 3) the bit-length of the inte-
ger €; 4) the number of encrypted data H (See Fig. 5).
In Fig. 5a-e, we can see that the runtime of all the pro-
tocols increase with P. It is because more runtime is
needed, and more data in the online phase and random
numbers in the offline phase are required to process with
extra parties. Also, we can see that the runtime of all the

 

15 Currently, Intel SGX is considered as the most practical and typical TEE.
Thus, we use SGX as the TPU for testing the LightCom. Note that the
LightCom is designed as a generic privacy computation framework and can be
fit for any trusted execution environment. Any types of TPU can be used in
the LightCom.

16h ttps://www.microway.com/knowledge-center-articles/performance-
characteristics- of- common-transports- buses/
Liu et al. Cybersecurity (2020) 3:17

TPU-based integer computations increase with the bit-
length of N from Table 1. It is because the running time of
the basic operations (Enc and Dec algorithms of PCDD)
increases when WN increases. Moreover, in Fig. 5f-k, the
performance of RTG, SMM, BAdd, BExt, SEP, SC, SEQ,
Ming, Miny, UNI are associated with £. The computa-
tional cost of above protocols are increased with @, as
more computation resources are needed to process when
€ increase. Finally, we can see that performance of APH
and PIR are increased with H in Fig. 51. It is because more
numbers of PCDD ciphertexts cost more energy with the
homomorphic and module exponential operations.

Performance of TPU-based FPN computation

For the basic TPU-based FPN computation, four factors
affect the performance of LightCom: 1) the number of
TPUs; 2) the PCDD parameter N; 3) the bit-length of the
integer €; 4) the number of encrypted data H. The run-
time trends of FPN computation protocols (e.g. FC, FEQ,
FM, FMM, FMing, FMiny) are similar to the trends of cor-
responding secure integer computation (e.g. SC, SEQ, SM,
SMM, Minz, Miny), as the runtime of FPN computation
is equal to the runtime of corresponding secure integer
computation add the runtime of UNT.

Theoretical analysis

Let us assume that one regular exponentiation operation
with an exponent of ||N'|| requires 1.5 ||N|| multiplications
(Knuth 2014). For PCDD, it takes 3||N|| multiplications for
Enc, 1.5||N|| multiplications for Dec, 1.5||N|| multiplica-
tions for PDec, ? multiplications for TDec, 1.5||N || mul-
tiplications for CR. For the basic operation of LightCom, it
takes 1.5P||N|| multiplications to run SDD, 3]|N || + thasy
multiplications for Seal, 1.5P||N|| + ts, multiplications
for UnSeal, O((€ + P)||N]]) multiplications for RTG,
O(P\||N ||) multiplications for B21, I2B. For the integer
and binary protocol in LightCom, it takes O(P ||N’||) mul-
tiplications for offline phase of SBM and SM, O(€P||N|)
multiplications for offline phase of BAdd, BExt, SC,
SEQ, Ming, O(€P||N]|) multiplications for both offline
and online phase of SEP, O(HP||N ||) multiplications for
offline phase of APH and PIR, O([log, H]-€P||N||) multi-
plications for offline phase of Miny. For the FPN compu-
tation in LightCom, it takes O(H¢P||N]|) multiplications
for offline phase UNI and FAdd, O(£P||N]|) multiplica-
tions for offline phase FM, FMM, FC, FEQ, FMing, and
O({log, H] - €P||N||) multiplications for offline phase of
FMiny. All the above protocols only need O(1) multi-
plications in online phase, which is greatly fit for fast
processing.

Related work

Homomorphic Encryption. Homomorphic_ encryption
allows third-party to do the computation on the cipher-
text, which reflected on the plaintext, is considered as

Page 17 of 21

the best solution to achieve the secure outsourced com-
putation. Gentry proposed the first construction of fully
homomorphic encryption in 2009 under the ideal lattices,
which permits the evaluation of arbitrary circuits over
the plaintext (Gentry and et al. 2009). Later, some of the
new hard problems (such as Learning With Errors (LWE)
(Brakerski and Vaikuntanathan 2014), Ring-LWE (Brak-
erski et al. 2014)) are used to construct the FHE which
can greatly reduce the storage overhead and increase the
performance of the homomorphic operations (Chillotti
et al. 2016; Liu et al. 2020). However, the current FHE
solutions and libraries are still not practical enough for
the real real-world scenarios (Dor6z et al. 2015; Liu et
al. 2017). Somewhat homomorphic encryption (Damgard
et al. 2012; Fan and Vercauteren 2012) can allow semi-
honest third-party to achieve the arbitrary circuits with
limited depth. The limited times of homomorphic oper-
ations restrict the usage scope of the application. Semi-
homomorphic encryption (SHE) can only support addi-
tive (Paillier 1999) (or multiplicative Gamal (1985)) homo-
morphic operation. However, with the help of the extra
semi-honest computation-aid server, a new computation
framework can be constructed to achieve commonly-used
secure rational number computation (Liu et al. 2018a),
secure multiple keys computation (Peter et al. 2013), and
floating-point number computation (Liu et al. 2016b). The
new framework can greatly balance the security and effi-
ciency concerns; however, the extra server will still com-
plex the system, which brings more risk of information
leakage.

Secret Sharing-based Computation. The user’s data in
secret sharing-based (SS-based) computation are sepa-
rated into multiple shares with the secret sharing tech-
nique, and each share is located in one server to guar-
antee security. Multiple parties can work jointly together
to securely achieve a computation without leaking the
original data to the adversary. Different from the heavy-
weight homomorphic operation, the SS-based compu-
tation (Cramer et al. 2000; Chen and Cramer 2006;
Chida et al. 2018) can achieve the lightweight compu-
tation. Despite the theoretical construction, many real-
word computation are constructed for practical usage,
such as SS-based set intersection (Dong et al. 2013),
top-k computation (Burkhart and Dimitropoulos 2010)
and k-means (Liu et al. 2020). These basic computa-
tions can be used to solve data security problem in
data mining technique, such as deep learning (Huang
et al. 2019). Emekci et al. (Emekci et al. 2007) pro-
posed a secure ID3 algorithm to construct a decision
tree in a privacy-preserving manner. Ma et al. (Ma et al.
2019) constructed a lightweight privacy-preserving adap-
tive boosting (AdaBoost) for the face recognition. The
new secure natural exponential and secure natural log-
arithm which can securely achieve the corresponding
Liu et al. Cybersecurity

(2020) 3:17

Table 1 Protocol Performance: A Comparative Summary (€ = 32,H = 8,P = 3, 100-time for average)

Page 18 of 21

 

Online computation cost (Millisecond)

Offline computation cost (Second)

 

 

N 512 768 1024 1280 1536 1792 2048 512 768 1024 1280 1536 1792 2048
RTG 16.66 53.6] 117.0 225.92 369.92 675.15 933.13 - - - - - - -

B21 2.2 6.29 13.92 27.15 47.29 85.8 116.7 - - - - - - -

I2B 2.72 8.19 16.38 31.21 51.13 70.25 102.0 - - - - - - -

SBM 0.001 0.001 0.001 0.002 0.002 0.002 0.002 0.004 0.014 0.024 0.047 0.076 0.139 0.192
BAdd 0.053 0.053 0.054 0.054 0.057 0.059 0.084 0.222 0.915 1.569 3.024 4.868 8.897 12.346
BExt = 1.36 4.24 8.54 16.6 29.1 51.93 70.13 0.268 1.077 1.882 3.634 6.016 10.842 14.868
SM 0.003 0.003 0.005 0.007 0.008 0.012 0.013 0.009 0.031 0.066 0.128 0.228 0.387 0.530
SMM 0.140 0.215 0.248 0.356 0.457 0.46 0.614 0.305 1.006 2.114 4.108 7.313 12.396 16.965
SEP) 0.001 0.001 0.001 0.001 0.002 0.002 0.003 0.004 0.013 0.028 0.056 0.103 0.171 0.232
SEP 2.73 5.95 10.79 19.44 34.84 53.8 74.08 9.867 32.739 68414 132.96 236.28 400.87 548.76
sc 1.32 4.11 8.77 16.73 29.68 49.85 68.39 0.267 1.077 1.882 3.634 6.017 10.743 = 14.869
SEQ 2.59 8.06 16.96 32.84 54.17 98.8 139.1 0.535 2.155 3.764 7.269 12.034 21486 29.378
Min 3.37 9.26 20.34 38.14 66.58 97.9 145.4 0.286 1.14] 2.015 3.891 6.474 11.517 15.929
Miny 3.75 68.89 150.85 29449 510.82 869.74 1453.6 2.007 7.983 14.101 = 27.24 45.318 80.624 111.51
APH 4.955 15.12 33.29 63.58 117.79 = 191.25 228.5 - - - - - - -

PIR 0.926 2492 5.057 9.28 16.6 26.6 31.67 - - - - - - -

UNI 4458 11903 247.27 460.56 8109 1181.5 1686.9 81.016 27014 561.94 1090.9 19374 3290.7 4505.8

 

computation to balance accuracy and efficiency. Although
many of the privacy-preserving data mining techniques
with secret sharing are constructed (Ge et al. 2010; Gheid
and Challal 2016), the SS-based computation still needs
to build a secure channel among these parties. More-
over, the high communication rounds among the com-
putation parties still become an obstacle for a large-scale
application.

Intel® Software Guard Extensions. Intel® SGX is a
kind of TEE which provides strong hardware-enforced
confidentiality and integrity guarantees and protects an
application form the host OS, hypervisor, BIOS, and
other software. Although an increasing number of real-
world industry applications are securely executed in the
untrusted remote platforms equipped with SGX, the SGX
still faces the side-channel attack to expose the informa-
tion during the computation. Gotzfried et al. (2017) pro-
posed a new attack called root-level cache-timing attacks
which can obtain secret information from an Intel® SGX
enclave. Lee et al. (2017) gave a new side-channel attack
cannled branch shadowing which reveals fine-grained
control flows in a SGX enclave. Van Bulck et al. (2017)
constructed two novel attack vectors that infer enclaved
memory accesses. Chen et al. (2018) presented a new
attack call SGXPECTRE that can learn secrets inside the
enclave memory or its internal registers. Currently, three
types of solutions are used to protect the side-channel
attack: hardware method (Domnitser et al. 2012; Costan

et al. 2016), system method (Liu et al. 2016c; Zhou et
al. 2016), and application method (Coppens et al. 2009;
Shih et al. 2017). These methods can only guarantee
some dimension of protection, and cannot be used for
all-directional protection even against the unknown side-
channel attack. We list all the current main methods in
Table 2 for detailed comparison.

Conclusion

In this paper, we proposed LightCom, a framework
for practical privacy-preserving outsourced computa-
tion framework, which allowed a user to outsource
encrypted data to a single cloud service provider for
secure data storage and process. We designed two
types of outsourced computation toolkits, which can
securely guarantee the achieve secure integer com-
putation and floating-point computation against side-
channel attack. The utility and performance of our
LightCom framework were then demonstrated using
simulations. Compared with the existing secure out-
sourced computation framework, our LightCom takes
fast, scalable, and secure outsourced data processing into
account.

As a future research effort, we plan to apply our Light-
Com in specific applications, such as the e-health cloud
system. It allows us to refine the framework to handle
more complex real-world computations.
Page 19 of 21

(2020) 3:17

Liu et al. Cybersecurity

UBWUOIIAUZ UOINDEXJ paysn |, JO} UOYs S| FAI Huyeys 9199s, JOJ WOUS SI ,SS, ‘JAJSUEL] SNOIAIGO, 10} UOYS S| 10, {UONADAIDUFZ DYGIOWOWOH Ajjewed, 10f VOUS S$! JHd, ‘2|Ge} ay} Ul :a70N

 

MOT

IS
IS

DD

IS
DIplINads *} DAUSH

3UuQ
3UuQ

DD

L
IS
JHd+SSt+34L

INO

2|PPIW

x

DD

DD

x

UOlDISJOLU]

3UuQ
3UuQ

DD

(WO

x

SS+LO

(ELOZ Je 39 Huo)

MOT
x

DD

DD

x
dyads

3uQ
3uQ

ddl

(ZL0Z ‘Je 39 EIpUeYD)

YOIH
x

x

DD

x

Aeaulq

3UuQ
3uQ

IS
dH4

(7LOTZ Je 39 !Y4ss94 24g)

MOT
x

DD

DD

x
dyads

3UuQ
3UuQ

ddl

(9107 | 38 YNSN)

YOIH
IS

x

DD

x

dyads

3UuQ
3UuQ

IS
dH4

(070 Je 38 NN)

MOT
x

DD

x
x

Xe

3uQ
3uQ

IS
ddl

(ZLOZ
‘J Ja UORYS)

2|PPIW

x

DD

x
x

sylpads

OM |.

3uQ

DD

(DO
x
JHd

(vLOZ |e
jo eyNYJUeWEeS)

MOT
IS

x

x
x

ysooqepy

OM

OM

SS

(6102 Je 19 EW)

2|PPIW
IS

x

x
x

DIpI98dS

OM

3UuQ

IS
dHd

(ELOZ Je 19 J218q)

MOT
IS

x

x

x
Dyes
OM |.

OM |.

IS
SS

(6102
2 Jo Buen)

2|PPIW

x

x

x

IS
Dyes

OM |.

3UuQ

IS
dHd

(q9L0Z ‘Je 38 NIT)

MOT

IS
IS

x
x

UONIPPY

OM |.

9|diy]nW

DD

(WO

x

SS

(4002

"J Jo Sy)
9|PPIW

IS

x

x
x

dyads

OM |.

3UuQ

IS
dHd

(29107 |€ 39 NIT)

MOT

IS
IS

x
x

y-do|

9|dijnW
9|dijnW

DD

(UNO
x
SS

(OL0Z
SO|NOdOINWIG

pue yeyrying)

2|PPIW

x

x

x

IS
DIpI98dS

9|dijnW
3UO

DD

L
IS
dHd

(28102 8 19 NN)

DESUJBAO SPIS-IBAS
SAdy 9]Clyynuu Yoddns

dLL INOYUM

SIOAIOS

papnyjod-uoU INoOYUM
JEUUOJ eJep JIChyNy\
adj uoldun4

SIOMIAS
Jo Jaquunu WINUWIUIY\

JaAlas abesojs e1eq

yoeqe
jaUUeYD-apls suleBY

(asf)
PUNO UO!eD|UNWWWO?D

SAIDEIAIU!-UOU Spls-asp)

poulew

luywobyje/uonoun 4

DESUJBAO SPIS-JBAI9S
SAdy 9]diyynuu Yoddns
dLL INOYUM

SIOAOS
Papnjjod-UOU INOYUMA

JEUUOJ eJep JIChyNy\
adj uoldun4

SIOMIAS
Jo Jaquunu WINUWIUIY\

JaAlas abesojs e1eq

yoeqe
jaUUeYD-apls suleBY

(asf)
PUNO UO!eD|UNWWWO?D

SAIDEIAIU!-UOU Spls-sasy)

POV

Wuywobyy/uolaun4

 

SHIOM HUNSIXS BU] UUM UOSHEGWOD dAISUSYDIAWOD Z aqeL
Liu et al. Cybersecurity (2020) 3:17

Supplementary information
Supplementary information accompanies this paper at
https://doi.org/10.1186/s42400-020-00057-3.

 

Additional file 1: Supplementary materials.

 

Acknowledgements

We thank the editor-in-chief, associate editor, and the reviewers for their
valuable comments for us to improve the paper. This research is supported in
part by the AXA Research Fund, National Natural Science Foundation of China
under Grant Nos.61 702105, No.61872091, and the Cloud Technology
Endowed Professorship from the the 80/20 Foundation.

Authors’ contributions

Ximeng Liu — Writing and original draft preparation. Robert H. Deng —
Supervision. Pengfei Wu — Experiment. Yang Yang; writing-Review and
editing. The author(s) read and approved the final manuscript.

Authors’ information

Ximeng Liu received the B.Sc. degree in electronic engineering from Xidian
University, Xi’an, China, in 2010 and the Ph.D. degree in Cryptography from
Xidian University, China, in 2015. Now he is the full professor in the College of
Mathematics and Computer Science, Fuzhou University. Also, he was a
research fellow at the School of Information System, Singapore Management
University, Singapore. He has published more than 200 papers on the topics of
cloud security and big data security-including papers in IEEE Transactions on
Computers, IEEE Transactions on Industrial Informatics, IEEE Transactions on
Dependable and Secure Computing, IEEE Transactions on Service Computing,
IEEE Internet of Things Journal, and so on. He awards "Minjiang Scholars"
Distinguished Professor, "Qishan Scholars" in Fuzhou University, and ACM
SIGSAC China Rising Star Award (2018). His research interests include cloud
security, applied cryptography and big data security. He is a member of the
IEEE, ACM, CCF.

Availability of data and materials

All the data used in the paper are randomly constructed (integer randomly
selected from Zy and floating-point number are selected from Zi).
Submission of a manuscript to a cybersecurity journal implies that materials
described in the manuscript, including all relevant raw data, will be freely
available to any scientist wishing to use them for non-commercial purposes,
without breaching participant confidentiality.

Competing interests
The authors declare that they have no competing financial interests.

Author details

'College of Mathematics and Computer Science, Fuzhou University, Fuzhou,
China. *School of Information Systems, Singapore Management University,
Singapore, Singapore. *School of Software and Microelectronics, Peking
University, Beijing, China.

Received: 13 July 2020 Accepted: 16 August 2020
Published online: 02 September 2020

References

Ali M, Khan SU, Vasilakos AV (2015) Security in cloud computing: Opportunities
and challenges. Inf Sci 305:357-383

Barker E, Barker W, Burr W, Polk W, Smid M (2007) NIST special publication
800-57. NIST Spec Publ 800(57):1-142

Bendlin R, Damgard |, Orlandi C, Zakarias S (2011) Semi-homomorphic
encryption and multiparty computation. In: Annual International
Conference on the Theory and Applications of Cryptographic Techniques.
Springer. pp 169-188. https://doi.org/10.1007/978-3-642-20465-4_11

Brakerski Z, Gentry C, Vaikuntanathan V (2014) (leveled) fully homomorphic
encryption without bootstrapping. ACM Trans Comput Theory (TOCT)
6(3):13

Brakerski Z, Vaikuntanathan V (2014) Efficient fully homomorphic encryption
from (standard) Iwe. SIAM J Comput 43(2):83 1-871

Bresson E, Catalano D, Pointcheval D (2003) A simple public-key cryptosystem
with a double trapdoor decryption mechanism and its applications. In:

Page 20 of 21

Advances in Cryptology - ASIACRYPT 2003, 9th International Conference
on the Theory and Application of Cryptology and Information Security,
Taipei, Taiwan, November 30 - December 4, 2003, Proceedings. pp 37-54.
https://doi.org/10.1007/978-3-540-40061-5_3

Burkhart M, Dimitropoulos X (2010) Fast privacy-preserving top-k queries using
secret sharing. In: 2010 Proceedings of 19th International Conference on
Computer Communications and Networks. IEEE. pp 1-7. https://doi.org/
10.1109/icccn.2010.5560086

Challa S, Das AK, Gope P, Kumar N, Wu F, Vasilakos AV (2020) Design and
analysis of authenticated key agreement scheme in cloud-assisted
cyber-physical systems. Future Gener Comput Syst 108:1267-1286

Chandra S, Karande V, Lin Z, Khan L, Kantarcioglu M, Thuraisingham B (2017)
Securing data analytics on sgx with randomization. In: European
Symposium on Research in Computer Security. Springer. pp 352-369.
https://doi.org/10.1007/978-3-319-66402-6_21

Chen G, Chen S, Xiao Y, Zhang Y, Lin Z, Lai TH (2018) Sgxpectre attacks: Leaking
enclave secrets via speculative execution. arXiv preprint arXiv:1802.09085

Chen H, Cramer R (2006) Algebraic geometric secret sharing schemes and
secure multi-party computations over small fields. In: Annual International
Cryptology Conference. Springer. pp 521-536

Chida K, Genkin D, Hamada K, Ikarashi D, Kikuchi R, Lindell Y, Nof A (2018) Fast
large-scale honest-majority mpc for malicious adversaries. In: Annual
International Cryptology Conference. Springer. pp 34-64. https://doi.org/
10.1007/978-3-319-96878-0_2

Chillotti |, Gama N, Georgieva M, Izabachene M (2016) Faster fully
homomorphic encryption: Bootstrapping in less than 0.1 seconds. In:
International Conference on the Theory and Application of Cryptology and
Information Security. Springer. pp 3-33. https://doi.org/10.1007/978-3-
662-53887-6_1

Consortium U, et al. (1997) The Unicode Standard, Version 2.0. Addison-Wesley
Longman Publishing Co., Inc., Boston

Coppens B, Verbauwhede |, De Bosschere K, De Sutter B (2009) Practical
mitigations for timing-based side-channel attacks on modern x86
processors. In: 2009 30th IEEE Symposium on Security and Privacy. IEEE.
pp 45-60. https://doi.org/10.1109/sp.2009.19

Costan V, Lebedev |, Devadas S (2016) Sanctum: Minimal hardware extensions
for strong software isolation. In: 25th {USENIX} Security Symposium
({USENIX} Security 16). USENIX Association, Austin. pp 857-874

Cramer R, Damgard |, Maurer U (2000) General secure multi-party computation
from any linear secret-sharing scheme. In: International Conference on the
Theory and Applications of Cryptographic Techniques. Springer.
pp 316-334. https://doi.org/10.1007/3-540-45539-6_22

Damgard |, Pastro V, Smart N, Zakarias S (2012) Multiparty computation from
somewhat homomorphic encryption. In: Annual Cryptology Conference.
Springer. pp 643-662. https://doi.org/10.1007/978-3-642-32009-5_38

Dimitrov DV (2016) Medical internet of things and big data in healthcare.
Healthc Inf Res 22(3):156-163

Domnitser L, Jaleel A, Loew J, Abu-Ghazaleh N, Ponomarev D (2012)
Non-monopolizable caches: Low-complexity mitigation of cache side
channel attacks. ACM Trans Archit Code Optim (TACO) 8(4):35

Dong C, Chen L, Wen Z (2013) When private set intersection meets big data:
an efficient and scalable protocol. In: Proceedings of the 2013 ACM SIGSAC
Conference on Computer & Communications Security. ACM. pp 789-800.
https://doi.org/10.1145/2508859.2516701

Doréz Y, Oztiirk E, Sunar B (2015) Accelerating fully homomorphic encryption
in hardware. IEEE Trans Comput 64(6):1509-1521

Emekci F, Sahin OD, Agrawal D, El Abbadi A (2007) Privacy preserving decision
tree learning over multiple parties. Data Knowl Eng 63(2):348-361

Fan J, Vercauteren F (2012) Somewhat practical fully homomorphic
encryption. IACR Cryptology ePrint Archive 2012:144

Farokhi F, Shames |, Batterham N (2016) Secure and private cloud-based control
using semi-homomorphic encryption. IFAC-PapersOnLine 49(22):163-168

Gamal TE (1985) A public key cryptosystem and a signature scheme based on
discrete logarithms Vol. 31. pp 469-472

Ge X, Yan L, Zhu J, Shi W (2010) Privacy-preserving distributed association rule
mining based on the secret sharing technique. In: The 2nd International
Conference on Software Engineering and Data Mining. IEEE, Chengdu.
pp 345-350

Gentry C, et al. (2009) Fully homomorphic encryption using ideal lattices. In:
Stoc Vol. 9. pp 169-178

 

 
Liu et al. Cybersecurity (2020) 3:17

Gheid Z, Challal Y (2016) Efficient and privacy-preserving k-means clustering
for big data mining. In: 2016 IEEE Trustcom/BigDataSE/ISPA. IEEE.
pp 791-798. https://doi.org/10.1109/trustcom.2016.0140

Gdtzfried J, Eckert M, Schinzel S, Muller T (2017) Cache attacks on intel sgx. In:
Proceedings of the 10th European Workshop on Systems Security
(EuroSec'17). Association for Computing Machin, New York. Article 2,
pp. 1-6

Huang K, Liu X, Fu S, Guo D, Xu M (2019) A lightweight privacy-preserving cnn
feature extraction framework for mobile sensing. IEEE Trans Dependable
Secure Comput. https://doi.org/10.1109/tdsc.2019.291 3362

Knuth DE (2014) Art of Computer Programming, Volume 2: Seminumerical
Algorithms. Addison-Wesley Professional, Boston

KUgUk KA, Paverd A, Martin A, Asokan N, Simpson A, Ankele R (2016) Exploring
the use of intel sgx for secure many-party applications. In: Proceedings of
the 1st Workshop on System Software for Trusted Execution. ACM. p 5.
https://doi.org/10.1145/3007788.3007793

Lee S, Shih M-W, Gera P, Kim T, Kim H, Peinado M (2017) Inferring fine-grained
control flow inside {SGX} enclaves with branch shadowing. In: 26th
{USENIX} Security Symposium ({USENIX} Security 17). USENIX Association,
Vancouver. pp 557-574

Liu X, Choo K-KR, Deng RH, Lu R, Weng J (2018a) Efficient and
privacy-preserving outsourced calculation of rational numbers. IEEE Trans
Dependable Secure Comput 15(1):27-39

Liu X, Deng RH, Choo K-KR, Weng J (2016a) An efficient privacy-preserving
outsourced calculation toolkit with multiple keys. IEEE Trans Inf Forensic
Secur 11(11):2401-2414

Liu X, Deng R, Choo K-KR, Yang Y (2017) Privacy-preserving outsourced clinical
decision support system in the cloud. IEEE Trans Serv Comput. https://doi.
org/10.1109/tsc.201 7.2773604

Liu X, Deng R, Choo K-KR, Yang Y, Pang H (2018b) Privacy-preserving
outsourced calculation toolkit in the cloud. IEEE Trans Dependable Secure
Comput. https://doi.org/10.1109/tdsc.2018.2816656

Liu X, Deng R, Choo K-KR, Yang Y, Pang H (2020) Privacy-preserving
outsourced calculation toolkit in the cloud. IEEE Trans Dependable Secure
Comput 17(5):898-911

Liu X, Deng RH, Ding W, Lu R, Qin B (2016b) Privacy-preserving outsourced
calculation on floating point numbers. IEEE Trans Inf Forensic Secur
11(11):2513-2527

Liu F, Ge Q, Yarom Y, Mckeen F, Rozas C, Heiser G, Lee RB (2016c) Catalyst:
Defeating last-level cache side channel attacks in cloud computing. In:
2016 IEEE International Symposium on High Performance Computer
Architecture (HPCA). IEEE. pp 406-418. https://doi.org/10.1109/hpca.2016.
7446082

Liu Y,Ma Z, Yan Z, Wang Z, Liu X, Ma J (2020) Privacy-preserving federated
k-means for proactive caching in next generation cellular networks. Inf Sci.
https://doi.org/10.1016/j.ins.2020.02.042

Ma Z, Liu Y, Liu X, Ma J, Ren K, IEEE Internet Things J (2019) Lightweight
privacy-preserving ensemble classification for face recognition:1-1.
https://doi.org/10.1109/JIOT.2019.2905555

Ma Z, Ma J, Miao Y, Choo K-KR, Liu X, Wang X, Yang T (2020) Pmkt: Privacy-
preserving multi-party knowledge transfer for financial market forecasting.
Futur Gener Comput Syst. https://doi.org/10.1016/j.future.2020.01.007

Naehrig M, Lauter K, Vaikuntanathan V (2011) Can homomorphic encryption
be practical? In: Proceedings of the 3rd ACM Workshop on Cloud
Computing Security Workshop. ACM. pp 113-124. https://doi.org/10.
1145/2046660.2046682

Paillier P (1999) Public-key cryptosystems based on composite degree
residuosity classes. In: Advances in cryptologyEUROCRYPT99. Springer.
pp 223-238. https://doi.org/10.1007/3-540-48910-x_16

Peter A, Tews E, Katzenbeisser S (2013) Efficiently outsourcing multiparty
computation under multiple keys. IEEE Trans Inf Forensic Secur
8(12):2046-2058

Samanthula BK, Elmehdwi Y, Jiang W (2014) K-nearest neighbor classification
over semantically secure encrypted relational data. IEEE Trans Knowl Data
Eng 27(5):1261-1273

Shaon F, Kantarcioglu M, Lin Z, Khan L (2017) Sgx-bigmatrix: A practical
encrypted data analytic framework with trusted processors. In: Proceedings
of the 2017 ACM SIGSAC Conference on Computer and Communications
Security. ACM. pp 1211-1228. https://doi.org/10.1 145/3133956.3134095

Page 21 of 21

Shih M-W, Lee S, Kim T, Peinado M (2017) T-sgx: Eradicating
controlled-channel attacks against enclave programs. In: NDSS. https://doi.
org/10.14722/ndss.2017.23193

Van Bulck J, Weichbrodt N, Kapitza R, Piessens F, Strackx R (2017) Telling your
secrets without page faults: Stealthy page table-based attacks on enclaved
execution. In: 26th {USENIX} Security Symposium ({USENIX} Security 17).
USENIX Association, Vancouver. pp 1041-1056

Van Dijk M, Gentry C, Halevi S, Vaikuntanathan V (2010) Fully homomorphic
encryption over the integers. In: Advances in Cryptology — EUROCRYPT
2010. EUROCRYPT 2010. Lecture Notes in Computer Science, vol 6110.
Springer, Berlin. pp 24-43

Wazid M, Das AK, Bhat V, Vasilakos AV (2020) Lam-ciot: Lightweight
authentication mechanism in cloud-based iot environment. J Netw
Comput Appl 150:102496

Wei L, Zhu H, Cao Z, Dong X, Jia W, Chen Y, Vasilakos AV (2014) Security and
privacy for storage and computation in cloud computing. Inf Sci
258:37 1-386

Xu S, Ning J, Li Y, Zhang Y, Xu G, Huang X, Deng R (2020a) Match in my way:
Fine-grained bilateral access control for secure cloud-fog computing. IEEE
Trans Dependable Secure Comput. https://doi.org/10.1109/tdsc.2020.
3001557

Xu S, Yang G, Mu Y, Deng R (2018) Secure fine-grained access control and data
sharing for dynamic groups in the cloud. IEEE Trans Inf Forensic Secur
13(8):2101-2113

Xu S, Yuan J, Xu G, Li Y, Liu X, Zhang Y, Ying Z (2020b) Match in my way:
Fine-grained bilateral access control for secure cloud-fog computing. Inf
Sci. https://doi.org/10.1109/tdsc.2020.3001557

Zhou Z, Reiter MK, Zhang Y (2016) A software approach to defeating side
channels in last-level caches. In: Proceedings of the 2016 ACM SIGSAC
Conference on Computer and Communications Security. ACM.
pp 871-882. https://doi.org/10.1145/2976749.2978324

Publisher’s Note
Springer Nature remains neutral with regard to jurisdictional claims in
published maps and institutional affiliations.

 

Submit your manuscript to a SpringerOpen”®
journal and benefit from:

> Convenient online submission

> Rigorous peer review

> Open access: articles freely available online
> High visibility within the field

> Retaining the copyright to your article

 

Submit your next manuscript at > springeropen.com

 

 

 
