Journal of Information Security and Applications 55 (2020) 102609

 

Contents lists available at ScienceDirect

INFORMATION

AND APPLICATIONS

Journal of Information Security and Applications

os

ELSEVIE

   

journal homepage: www.elsevier.com/locate/jisa

 

®

Check for

Efficient protocols for private wildcards pattern matching” ates

Tushar Kanti Saha**, Deevashwer Rathee”, Takeshi Koshiba ‘

4 Department of Computer Science and Engineering, Jatiya Kabi Kazi Nazrul Islam University, Bangladesh
> Department of Computer Science and Engineering, Indian Institute of Technology (BHU), Varanasi, India
© Faculty of Education and Integrated Arts and Sciences, Waseda University, Tokyo, Japan

ARTICLE INFO ABSTRACT

Keywords:

Privacy-preserving

Repetitive wildcards

Compound wildcards

Secure pattern matching

Somewhat homomorphic encryption
Hamming and Euclidean distances

A wildcard character in a pattern adds an additional feature in the field of pattern matching. In this paper,
we consider two problems of secure pattern matching (SPM) with wildcards: (i) SPM with repetitive wildcards
(SPM-RW) and (ii) SPM with compound wildcards (SPM-CW). Here we consider that a type of wildcard
characters “*" is used to represent gaps in the pattern for the first problem of SPM with wildcards. Usually,
a wildcard character “*" is used to replace with zero or more letters in the text for the pattern matching
problem. Yasuda et al. (ACISP 2014) proposed a protocol with an existing data packing method for secure
wildcards pattern matching using symmetric somewhat homomorphic encryption (SwHE) in the semi-honest
model in which a wildcard character in the pattern is replaced with just one letter in the text. Furthermore,
we enhance their work to replace a wildcard with any sequence of letters in the text then propose SPM-RW
protocols by using the symmetric and public-key SwHE schemes in the semi-honest model. Also, we propose
a packing method that improves the number of homomorphic multiplications by a factor of k compared to a
naive usage of Yasuda et al.’s method to solve the SPM-RW problem in which k is the number of sub-patterns.
Next, we consider the SPM-CW problem for processing private database queries, which allows a few types of
wildcards (“$", ““*", and “!") to appear in the pattern. To solve this problem, we propose an SPM-CW protocol
using a double-query technique with public-key SwHE encryption in the semi-honest model. Our experiments
exhibit the practicality of the new protocols for SPM-RW and SPM-CW, which outperforms state-of-the-art.

1. Introduction public. Here, data encryption is one of the techniques to secure the

outsourced data. Moreover, the users need to perform computations on

Outsourced computation is now popular due to the availability of
cloud services at a low cost. In addition, cloud service providers like
Google, Amazon, Microsoft, IBM, and so on have already established
themselves as reliable service providers for their users. They are also
facilitating massive storage service of data along with the computation
using those data. Furthermore, data are gradually increasing due to the
extensive use of computers, laptops, smart-phones, and so on by their
users. Currently, the users are interested in storing their data online
not only for saving space of local computers but also for accessing
those data anytime and anywhere from the world. Besides, private
computation has vast applications in various fields like biometrics
authentication [1], bioinformatics [2,3], data searching [4], private
database queries (PDBQ) [5]. Now these computations are outsourced
to the cloud securely without revealing any private information to the

the encrypted data without decryption because the decryption within
the cloud reveals the data to the cloud. In these respects, securing data
and searching and computing on secured data are needed at the same
time.

In particular, the secure pattern matching (SPM) within a text is a
vital problem that is explored in the earlier works [2—4,6-10]. Since
patterns may include errors and gaps in the practical applications, it
is important to cope patterns with errors and gaps. We can handle
them by inserting wildcard characters (“$”, “*”, “!”) in the patterns.
Here “$” is used in the pattern to replace with a single non-empty
letter in the text, which is similar to the method in [6]. A wildcard
‘““«”? replaces with zero or more letters in the text. “‘!” takes a variable
mz as an argument, where z specifies any non-empty string of arbi-
trary length such as “a”, “bec”, “adcab”, and so on. Now “‘!(z)’’ is

* This is a full version of the work (Saha and Koshiba, 2017) which was presented at the 9th International Symposium on Foundations & Practice of Security
(FPS 2016). This paper extends the contribution in Saha and Koshiba (2017) by adding a protocol using a public-key encryption scheme (Section 4.4.2 and 7.2)
with experimental analysis (Section 9.5.1). This paper also adds another problem called SPM with compound wildcards and its application to private database
queries (Section 5 and 8) and shows the experimental evaluation as well (Section 9.5.2).

* Corresponding author.
E-mail address: tushar@jkkniu.edu.bd (T.K. Saha).

https://doi.org/10.1016/j.jisa.2020.102609

Available online 18 September 2020
2214-2126/© 2020 The Author(s).

(http://creativecommons.org/licenses/by-nce-nd/4.0/).

Published by Elsevier Ltd.

This is an open access article under the CC BY-NC-ND license
T.K. Saha et al.

replaced with any non-empty string other than z. Essentially, SPM with
wildcards can be used in many fields like database search [5,11,12],
bioinformatics [2,3,6,10], and information retrieval [4]. Depending on
the appearance of wildcards in the pattern, we can classify pattern
into several categories such as patterns with no wildcards (e.g., AGT),
patterns with a single wildcard (e.g., AT*), patterns with repetitive
wildcards (e.g., AC*CTA*T), and patterns with compound wildcards
(e.g., *AAG$CC! (AA) TG*). Similarly, we can also classify SPM into
several categories such as SPM with no wildcards, SPM with a single
wildcard, SPM with repetitive wildcards (SPM-RW), and SPM with
compound wildcards (SPM-CW). Most of the earlier works in secure
computation handle the patterns with no wildcards [2,8] or a single
wildcard [6,7,9]. Generally speaking, a pattern with a single wildcard
may find an erroneous pattern in the text. However, patterns with
repetitive wildcards and compound wildcards provide more flexible
search to users than the patterns with a single wildcard do. We consider
ways to outsource computations of the SPM problems to the cloud.

Here one solution to the above problem is to use homomorphic com-
putation. Homomorphic encryption (HE) has allowed service providers
to facilitate computation on encrypted text for their users. At the early
stages of the investigation on secure computation, cryptosystems of
Goldwasser and Micali [13], El Gamal [14], Cohen and Fischer [15],
Paillier [16] allow only single homomorphic computation either addi-
tion or multiplication but not both operations. In 2005, Boneh et al.
enabled us to perform both operations at the same time [17]. However,
they have the limitation of doing many additions but a single multipli-
cation. After that Gentry [18] did the revolutionary work in the field of
homomorphic computation, which can freely perform both operations
on encrypted data. His method is called fully homomorphic encryption
(FHE) that was designed by applying squashing and bootstrapping tech-
niques to somewhat homomorphic encryption (SwHE), which allows us
to perform many additions and a few multiplications on encrypted data.
The limitation of FHE is that it generates ciphertext of the large size
and makes the processing speed slow [19]. After these breakthroughs,
Brakerski and Vaikuntanathan [20] proposed more efficient SwHE than
Gentry’s one which is based on ring learning with errors (ring-LWE)
problem supporting many additions and a few multiplications. Actually,
they used polynomial ring-based computations in which many plain-
texts are packed into a single polynomial of a finite degree, called the
packing method that produces a single packed ciphertext after the en-
cryption using the key of SwHE. Therefore, it reduces the ciphertext size
and speeds up the computation performances of SWHE. In 2011, Lauter
et al. [21] used ring-LWE based SWHE for the efficient computation of
statistics (e.g., mean and variance) and discussed some other practical
applications including medical, financial, and advertising and pricing.
Using the same ring-LWE based SwWHE [21], Yasuda et al. [2,6,22] and
Saha and Koshiba [23,24] presented several efficient secure applica-
tions in the cloud with semi-honest model by introducing new packing
methods to speed up the performances of those applications. Thus,
we consider to use ring-LWE based SwHE with yet another packing
methods for solving the SPM problems in the cloud.

1.1. Recent secure pattern matching techniques

Pattern matching computation can be secured in two ways. One is
by application-specific protocols and the other is by general protocols.
In this paper, we focus on application-specific protocol. To our knowl-
edge, Troncoso-Pastoriza et al. [3] first addressed the SPM problem
using an oblivious automata evaluation for their secure computation.
Jha et al. applied Yao’s garbled-circuit protocol [25] to secure genomic
computation [26]. Here they improved Yao’s protocol by dividing
problem instances into smaller sub-circuits and sharing the result of
evaluating each sub-circuit between the participants. Blanton et al. pre-
sented an SPM technique using finite automata for DNA searching [8].
Katz et al. described a new keyword search protocol for private DNA
pattern matching by modifying Yao’s garbled circuit approach [27].

Journal of Information Security and Applications 55 (2020) 102609

In the above works, the authors did not mention any pattern which
contains a wildcard character (*) to be matched with actual text. So
far we have observed that SPM with single-character wildcard was
first solved by Baron et al. [7]. They proposed a new protocol for
more expressive search queries including a single-character wildcard
and substring pattern matching of an arbitrary alphabet. Beck and
Kerschbaum [28] proposed a method for the string matching using
additively homomorphic encryption scheme with Bloom filters. There-
after, Defrawy et al. performed a comparative study among some SPM
protocols and measured their performances for a wildcard pattern
matching [4]. Hazay et al. [9] proposed a few protocols for variations
of the SPM problem, which were significantly more efficient than the
existing solutions. Their protocols are not suitable for cloud computing
because supporting wildcards increases the communication and com-
putational complexity linearly with the increase of size of the text and
the pattern. Yasuda et al. [2] proposed a practical solution to an SPM
problem for analyzing personal DNA sequence by using ring-LWE based
SWHE of [21], which is suitable for the cloud. To perform the SPM with
the Hamming distance technique, they proposed a new packing method
suitable for an efficient computation of many Hamming distances over
the encrypted data. Furthermore, they have a limitation of using the
pattern with a single wildcard (*) like “AT*G”, “AT*”, “*AT” in their
paper. To overcome this limitation, Yasuda et al. in their succeeding
paper [6] proposed an SPM technique with a wildcard using the same
SWHE for searching real-world genome data. To solve the problem of
SPM with a wildcard, they used the packing method of [2] to match the
pattern including a single wildcard which is replaced with a letter in
the text of practical genome data. For example, for the DNA alphabet
x = {A,G,C,T}, the pattern “AT*” matches any of the texts like “ATC”,
“ATG”, “ATA”. Here Yasuda et al. [6] addressed only a letter in the
text to be replaced with a wildcard character “*” occurred in the
pattern. Usually, “*” is used to replace with zero or more letters in the
text for the pattern matching problem. However, none of the methods
discussed so far address SPM-RW or SPM-CW problems. Therefore, a
new method is indispensable, which allows several letters in the text
to be replaced with a wildcard character appeared in the pattern. Very
recently, Kim et al. [5] proposed an SPM-CW protocol for the PDBQ
problem in which they engaged two-step computation of high-depth for
the pattern matching of their protocol. Moreover, they in [5] admit that
their performance is far from the practicality. To solve these SPM-RW
and SPM-CW problems, new methods are urgently necessary.

1.2. Problem statements

In this paper, we consider two problems of SPM with wildcards: (i)
the SPM-RW problem and (ii) the SPM-CW problem.

1.2.1. Secure pattern matching with repetitive wildcards
To define the SPM-RW problem, let us consider a text T = (aga),...,
a,_;) of length / and a pattern P = (bj 9b, 1 +++ by p,-1 * 52,9b2,1 +++ b2,p-1 *
- * byob + Og p,-1) Containing k sub-patterns, where the length of
each sub-pattern P, is p, for 1 < y < k and Yet Py < /!. Now securely
searching a text T of a cloud database for a pattern P is the first
task of our work in which “*” replaces with zero or several letters
in the text. In addition, the wildcard appears in the pattern many
times; we call it repetitive-wildcards pattern matching. In reality, we
have been motivated by the DNA search method used in mtDB' in
which a wildcard “*” has represented a gap. Furthermore, we consider
two scenarios for the security of the SPM-RW problem. The first one
is a symmetric scenario which provides security to the user’s pattern
only, that is similar to the security used in [6]. The second one is an
asymmetric scenario which provides security to the text and the pattern
and is suitable for many practical applications in which data owner and
query owner do not want to reveal their information to each other.

1 (See http://www.mtdb.igp.uu.se/ for the on-line version of DNA
searching.)
T.K. Saha et al.

1.2.2. Secure pattern matching with compound wildcards

Similar to the recent work in [5], we study another wildcards-based
SPM problem called SPM-CW problem and its application to the PDBQ
problem. In the SPM-CW problem, a query with compound wildcards
(e.g., *AAG$CC! (AA) TG*) means that the query string represents a
pattern with many wildcards (“$”, “*”, and “!’’) rather than repetitive
wildcards stated in the first problem. To define this problem, suppose
that we need to compare the pattern with compound wildcards P =
(bo ++ $b Mint + Cie )bi4e41 7 $bg_1) Of length 9 with + records of the
table for any attribute in a database. Moreover, each record of that
attribute can be represented by the text 7 = (aga, --- a,_,) of length @.
Here the wildcard “$” matches any letter in the text and “!(z)’” matches
a single non-empty string except z.

1.3. Existing solutions of secure pattern matching with repetitive wildcards
problem

Now we describe a solution to the SPM-RW problem using Yasuda
et al.’s scheme in [6]. In this paper, we consider the SPM-RW prob-
lem for non-binary vectors, which can be realized by measuring the
squared Euclidean distance (SED) between sub-text vector T, and each
sub-pattern vector P, as

Py-l
_ 2
Eya = » (gn — 5yn)
n=0

for 1 < y < k and0O <d < (/—p,). Here T, denotes the (d + 1)-th
sub-vector (4449, ---»4a4p,-1) of the text T with |T| = p,. Moreover,
Py = (dy os Dy.ts +++ + yp -1) is the yth sub-pattern vector of the pattern of
P where |P,| = p, for 1 < y<k and Ye Py <I.

Yasuda et al. [6] showed a solution to the SPM problem with a
wildcard using symmetric SWHE based on ring-LWE. They used the SED
technique to measure the distance between the text and the pattern
of non-binary vectors. Using the technique in [6], we can compute
many SEDs using three homomorphic multiplications. If we use the
technique in [6] for our SPM-RW problem containing k sub-patterns
in the query, each sub-pattern P, is needed to be matched separately
with the text 7. Then we need to send k queries separately to the cloud
which incurs an extra communication cost. Besides, this technique
needs 3k homomorphic multiplications to find the SEDs between each
sub-pattern P, and sub-text T,, which will increase the computation
cost to solve the SPM-RW problem (See Section 4.3.1 for the details).

1.4. Existing solution of secure pattern matching with compound wildcards
problem

If we want to solve the SPM-CW problem using the technique of
Kim et al. [5], we need to use their two-step solution. In the first
step, they used the equation to decide the equality between the text
T = (a, 4),.--,@y_;) and pattern P = (wp, W),..., Wy_;) as follows:

I
—

P
Ze = I (EQG;, w; + é-))
J

ll
°o

where 0 <7 < o—9 and w; is any character in the pattern P with

the wildcard indicator flag é>. Moreover, é; = | if Ws is a wildcard;
otherwise, é; = 0. From the above equation, it is evident that the

multiplicative depth of the above equality computation is log@g. In

the second step, they used another equation to finalize the pattern

matching result with (non)-equalities with the help of a set of constants

d;. Here the constants d; = 1 if0 <i<g-8andd;=0ifg-S9+1<

i < g—1. The equation used in the second step is expressed as follows:
g-1

f=1+][d+z-d).
j

If the pattern P matches the text 7, f = 1; otherwise, 7 = 0. From the
above equation, it is obvious that the multiplicative depth of the above

Journal of Information Security and Applications 55 (2020) 102609

computation for pattern matching is log g. Furthermore, the depth in-
creases with the increase of the text length g. We know that high-depth
computation is expensive. Therefore, a new technique is required to
improve the cost of the computation for solving the SPM-CW problem.

1.5. Our contributions

Our contributions in this paper are threefold which are stated as
follows:

1. For the SPM-RW problem with k sub-patterns, we propose two
efficient protocols in the semi-honest model. The first one is
using symmetric SwHE based on ring-LWE, called symmetric
SPM-RW protocol in which only the pattern is encrypted. The
second one is using public-key SwHE based on ring-LWE, called
public-key SPM-RW protocol in which the text and the pattern
are encrypted. To avoid k queries for k sub-patterns and enable
a faster computation of the SPM-RW protocols than [6], we
propose a new packing method which allows us to pack all
sub-patterns into a single polynomial and send the encrypted
polynomial as a single query to the cloud. In addition, our
packing method allows us to calculate all the SEDs using 3 homo-
morphic multiplications instead of 3k multiplications required if
we follow the technique in [6].

2. For the SPM-CW problem of processing PDBQ, we propose an
SPM-CW protocol using a double-query technique with the same
packing method and public-key SwHE in the semi-honest model.
Here we deal with the pattern with compound wildcards, which
is absent in [6]. In addition, we consider three types of wildcard
symbols “$”, “*’, and “!” to solve the SPM-CW problem.

3. To evaluate the efficiency of our SPM-RW and SPM-CW pro-
tocols regarding two problems, we make experiments of the
protocols. The experiments of SPM-RW protocols are performed
to show their applications in searching DNA sequences. The
experiment of the SPM-CW protocol is performed for processing
PDBQ with compound wildcards. For searching DNA sequence,
our technique shows more efficiency than the technique of Ya-
suda et al. [6]. Besides, our symmetric encryption protocol is
suitable for evaluating private patterns of any user. In addition,
our public-key protocol is suitable for the applications where
the text and the pattern are needed to be secured during the
pattern matching computation. To process the PDBQ with com-
pound wildcards, our SPM-CW protocol outperforms that in [5].
Moreover, our experiments demonstrate the practicality of our
protocols.

1.6. Outline

This paper is organized in the following way. Section 2 gives the
preliminaries related to distance measurement techniques for pattern
matching. The symmetric and public-key variants of SwHE scheme for
our SPM protocols with their security and correctness are described
in Section 3. Section 4 mentions about the solving technique of the
SPM-RW problem in the cloud along with their protocols. Section 5
highlights the solving technique of the SPM-CW problem along with the
protocol. In addition, many inner products computation which helps
secure computation of SPM-RW and SPM-CW protocols is explored in
Section 6. Section 7 narrates the secure computation of the protocol
mentioned in Section 4. Section 8 shows secure computation of the
protocol as referred in Section 5. We evaluate the performance of
our protocols both theoretically and practically in Section 9. Finally,
we conclude our paper with an indication of future works through
Section 10.
T.K. Saha et al.
2. Preliminaries

In this section, we discuss the SPM using the distance measurement
techniques. Before the discussion, we present some notations used in
the paper.

Notations. Z denotes the ring of integers. For a prime number gq, the
ring of integers modulo q is denoted by Z,. Let n be the lattice dimen-
sion of the RLWE-based SwHE. For a vector A = (dg, a),...,a,_1), the
maximum norm of A is max |a;|. Let (T, P) be the inner product between
two vectors T and P. The distribution Dz, indicates the discrete
Gaussian error distribution with an n-dimensional integer vector Z"” and
a standard deviation o. Moreover, let / be the length of the text T for
the SPM-RW problem. Also, let P be a pattern for the SPM-RW problem
and P, be the yth sub-pattern of P with |P,| = p,. Also, b,; denotes the
ith character of the yth sub-pattern. Let @ (resp., 9) be the length of the
text JT (resp., pattern P) for the SPM-CW problem. Furthermore, a, Y,
and tr denote the number of attributes in a table, a record in the table,
and total records in the table respectively. In addition, y represents the
number of texts packed within the lattice dimension n. Finally, log(t,,,,)
defines the logarithmic runtime of an attack that is used to show the
security level of a protocol using ring-LWE SwHE scheme and e defines
the adversarial advantage.

2.1. Pattern matching using distance measurement

We present how the distance measurement techniques help us in
pattern matching. For a given alphabet 2, the exact pattern matching
is the process of deciding whether a pattern P € >” appears in the
text T © LX” or not, where w < 7. The matching decision can be
made by measuring the distance between the text vector 7 and the
pattern vector P. We can measure the distance for pattern matching
using the Hamming distance technique for binary vectors [2] and the
SED technique for non-binary vectors [6]. Let us consider a text vector
T = (ao,q1,...,a,-,) and a pattern vector P = (bo, b,,...,5,—;) for the
distance measurements that are discussed in the following subsections.

2.1.1. Hamming distance
If T and P are binary vectors, the Hamming distance H, between
them can be measured by the following equation as

u-1 u-1
Ay = » lda+n — Dal = » Gas + by — 2+ Gash’ On)
h=0 h=0

for 0 <d <n-vu. Here if H, = 0 for some position d then the pattern
P is found in the text T at the index d + 1; otherwise, the pattern is
not found. For example, we set T = (11101010) and P = (1010), where
y =8 and yw = 4. By following the arithmetic computation in the above
equation, we obtain that 7 — «+ 1 = 5 Hamming distances as Hy = 1,
H, =3, H, =0, H; =4, and H, = 0. From this result, we can say that
there are matches at the 3rd and 5th indices of the text, i.e., the pattern
P occurs at two places in the text T.

2.1.2. Squared Euclidean distance

We know that the Euclidean distance technique is used to find the
distance between two non-binary vectors, which includes a square root
operation. Here we use the SED instead of the Euclidean distance to
avoid square the root operation and its cost over the encrypted data.
Suppose that T and P are non-binary vectors, then the SED E,, between
them can be measured by the following equation as

y-1 y-1
Eq = Yash — by) = Gen — 2+ dgyn* bp +b;
h=0 h=0

for0 <d<yn-vu. If E, = 0 for some position d, we can say that the
pattern P is found in the text T at the index d+1; otherwise, the pattern
is not found. For instance, consider the DNA alphabet as » = {A,G,C, T}
which can be encoded by the set {1, 2, 3,4}. Also, consider that we need

Journal of Information Security and Applications 55 (2020) 102609

to find the pattern P = (ATT) = (144) in the text T = (AGCGATTG) =
(12321442), where 7 = 8 and yw = 3. Here we can find at most 6 SEDs,
where 6 comes from the equations 7 —-w+1= 8-341 = 6. Using
the arithmetic in the above equation, we compute 6 SEDs as Ey = 5,
E, =6, E, =17, E; = 10, Ey, = 0, and E; = 13. Among these distances,
since E, = 0, the pattern P is found at the index 5 of the text 7.

Remark 1. From the above discussion, it is evident that the distance-
based techniques can be used in pattern matching. This paper considers
two problems of wildcards pattern matching over the alphabet 2»,
which are encoded as non-binary vectors. Therefore, we use the SED
technique for the distance measurement between the text and the
pattern instead of the Hamming distance technique.

3. Security using homomorphic encryption

We review both symmetric [6] and public-key [2] SwHE schemes
based on ring-LWE and their correctness, which are the variants of
SWHE in [20] and [21].

3.1. Required parameters

For the SWHE schemes in [2,6], we consider the following parame-
ters.

- n: the lattice dimension such that n € Z and n = 28 with & € Z.

* f(x): a cyclotomic polynomial such that f(x) = x" +1.

* g: modulus qg is an odd prime such that gq = 1(mod 2n).

- R,: a ring where R, = R/qR = Z,[x]/f), denoting a ciphertext
space.

* t: an integer t < q, defines the message space such that R, = Z,[x]/
f(x).

* o: a parameter which defines a discrete Gaussian error distribu-
tion y = Dz,,, with a standard deviation o such that 4 < o <
8.

3.2. Symmetric somewhat homomorphic encryption

Yasuda et al. [6] showed a symmetric SWHE based on the public-
key SWHE scheme in [21]. Now we can discuss the key generation,
encryption, homomorphism, and decryption property of this scheme as
follows.

Key generation. Generate a ring element R > s < y for the secret key
Sk= 5;

Encryption. Firstly, samples a — R, ande < y. For me R, encryption
is defined as follows:

Enc(m, sk) = (as + te +m, —a) = (cg, cy) = ct. (1)

Homomorphic operations. In our symmetric SPM-RW protocol (See Sec-
tion 4.4.1 for the details), one is plaintext m’ and another is ciphertext
ct. Now the homomorphic operation between ct = (cp,c,) and m’ € R,
can be defined as

Hom Add. : ctagg = ct Am’ = (co Aim’, c))

2
Hom. Mul. : ct,,,,; = ct Km’ = (co Xi m’,c, Km’). (2)

Decryption. For ct € (R,), t € R,, and the secret key sk, a general
decryption can be defined as

Dec(ct, sk) = [m], mod t, (3)

where fi = >", ¢;s'. For the secret key vector s = (1,5,5°,...,s%), we
can simply rewrite Dec(cr, sk) = [(ct,s)], mod t. For example, a fresh
ciphertext ct = (cg, c,;) generated by Eq. (1) can be decrypted as follows:

(ct,S) =cg +c,-s=(asttet+m)+(-a):s=m+t-e. (4)
T.K. Saha et al.

From the above equation, we can recover text m by mod ¢ operation.
In the same way, homomorphic decryption can be defined by the
following ways:

Dec(ctgaa, Sk) = [Mgqq], mod t, where Magy = cg +m’ +cys =m+m!
Dec(ct

mul? SK) = [ny ]g mod t,where My = com’ + cym's =m- m’.

3.3. Correctness of symmetric scheme

The correctness of symmetric SWHE scheme depends on how the
decryption can recover the original result from the ciphertext after
some homomorphic operations. We can write the decryption process
as follows:

{eeu sk) = Dec((ct Hm’), sk) = m+n

Dec(Ct my, Sk) = Dec((ct Km’), sk) =m-m'. (5)

Actually, the above process is already described in Section 3.1 of [20].
Here ciphertext ct comes from m € R, after encryption and another
plaintext m’ € R,. The correctness of SwHE scheme in Section 3.2 holds
if it satisfies the following lemma as shown in [6].

Lemma 1 (Condition for Successful Decryption). For a ciphertext ct, the
decryption Dec(ct, sk) recovers the correct result if (ct,s) € R, does not
wrap-around mod q, namely, if the condition ||(ct,s)||,. < 5 is satisfied,
where |la||,, = max |a;| for an element a = rr a;x' € R,. Specifically, for
a fresh ciphertext ct, the co-norm ||(ct,s)||,, is given by ||m+te||,,. Moreover,
for a homomorphically operated ciphertext, the co-norm can be computed

by Eq. (2).
3.4. Public-key somewhat homomorphic encryption

In 2013, Yasuda et al. [2] showed a SWHE scheme which is a public-
key variant of BV’s SWHE scheme [20] and SwHE by Lauter et al. [21].
Now we review the algorithms of SwHE scheme in [21] and [2] as
follows.

$
SwWHE.KeyGen. Generate secret key sk = s such that RD s < y. Sample

a uniformly random element a, € R, and an error R>e < y. Now we
get the public-key pair as pk = (ag, a,) with ay = a,s + te.

$
SwHE.Enc. First samples R 5 u, f,g <— y. For a given message m € R,
and pk = (ag, a,), the encryption can be defined as follows:

Enc(m, pk) = (agu+tg +m, —(ajut+tf)) = (cg,c,) = ct. (6)
At this place, the plaintext m € R, is also in R, because t < q.

Homomorphic operations. Generally, homomorphic operations between
two ciphertexts ct = (cp,...,¢,) and cr’ = (ch ve Ch). can be defined as
follows:

Hom. Add. : Cladd =ct FA ct’ = (co + c’, ee » Cmax(a,B) + Cnax(a.p))

atp a B (7)
Hom. Mul. : ct,,,,; = ct Ki ct’ = » Ez = (> cz!) (> cj2/) ,
i=0 i=0 j=0

Here z denotes a symbolic variable such that {cr,cr’} © R,[z]. In
addition, we can define the subtraction as similar to component-wise
addition.

SwHE.Dec. For a fresh or homomorphically operated ciphertext ct =
(co, --->Cy) and t € R,, a general decryption can be defined as

Dec(ct, sk) = [fi], mod 1, (8)

where m = >), ¢;s'. For the secret key vector s = (1,s,s7,...), we
can simply rewrite Dec(ct, sk) = [(ct,s)], mod 1. For instance, a fresh
ciphertext ct = (cp,c,) generated by Eq. (6) can be decrypted as

(ct,S) =(agut+tg+m)—s-(ajut+tf)=m+t-(uet+g-sf), (9)

Journal of Information Security and Applications 55 (2020) 102609

where ay — a,s = te. If the value m+? -(ue + g — sf) does not wrap-

around mod gq (all errors e, f, g,u é x must be sufficiently small), we
have [(ct,s)], = m+t-(ue+g—sf) © R and can recover plaintext m
by mod t operation. If no wrap-around happens in the encrypted results
after homomorphic operations for two ciphertexts ct and ct’, we clearly
have the relations as follows:

oma" = (ct,s) + (ct’,s) =m+m'

(ct Rct’,s) = (ct,s) - (ct!,s) =m-m'. (10)

3.5. Correctness of public-key scheme

The correctness of this public-key SwHE scheme also depends on
the recovery of the original result from the ciphertext after some
homomorphic operations. Now we can show the decryption procedure
as follows:

{Deca sk) = Dec((ct Hct’), sk) = m+n

Dec(¢t mj» 8k) = Dec((ct ct’), sk) =m m’. (11)

mul?
Brakerski and Vaikuntanathan discussed the above procedure in Section
3.2 in [20]. Here ciphertexts ct and ct’ come from me R, and m' € R,
respectively after the encryption. The SwHE scheme in Section 3.4
holds if it satisfies the following lemma as shown in [2].

Lemma 2 (Condition for Successful Decryption). For a ciphertext ct, the
decryption Dec(ct, sk) recovers the correct result if (ct,s) € R, does not
wrap around mod gq, namely, if the condition ||(ct,s)||,, < . is satisfied,
where |la||,, = max |a;| for an element a = re a;x' € R,. Specifically, for
a fresh ciphertext ct, the oo-norm ||(ct,s)||,, is given by ||m+t(ue+g—sf)]||,o-
Moreover, for a homomorphically operated ciphertext, the co-norm can be
computed by Eq. (10).

3.6. Security of the schemes

We can show the security of the mentioned SwHE schemes by the
polynomial ring-LWE assumption (ring-LWE,, , ,) as mentioned in [21]
for the given parameters (n, q,t,o). The assumption holds for any poly-
nomial number of samples of the form as (a;,b; = a; - 5 + e;) € (Rj)

where a, 2 R, and e < x. Here the a,’s are uniformly random in
R, and b;’s (b; = a;-s + e;) are also uniform in R,. Therefore, it is
hard to distinguish (a,,b,;) from a uniformly random pair (a,, b;) € (R,)’.
Besides, Lyubashevsky et al. [29] showed that the ring-LWE assumption
is reducible to the worst-case hardness of problems on ideal lattices,

that is believed to be secure against the attacks by a quantum computer.

4. Technique of secure pattern matching with repetitive wildcards
in the cloud

For the SPM-RW problem, let us consider the text vector T =
(dp, 4,,-.-,4;_;) Of length / outsourced to the cloud. Also, consider the
pattern P = (bj 9b, 1 +* by p,-1 * 2,9b2,1 + b2,p,-1 * 0 * OK ob K A Ok p,-1)
containing k sub-patterns in which each sub-pattern can be represented
by a vector P, = (by, by 1, sy Dyy 1) with |P,| = p,. For this pattern
matching problem, we need to search the text T for k sub-patterns
by maintaining the sequences of all sub-patterns as they appear in
the main pattern. Here we need to calculate every distance between
each sub-pattern P, and each sub-text T, of length p, for! < y<k
and 0 < d < (/ — p,). Besides, T, denotes the (d + 1)-th sub-vector
(Aq40> +++» 4qa+p,-1) Of the text T with |T,| = p,. Now we use the SED-
based pattern matching technique to solve the SPM-RW problem. For
1<y<kand0<d <(/—p,), the SED E,, between the sub-text T;
and each sub-pattern P, is calculated by the following equation:

Py-l Py-l
Eya = aan - yn) = Yi — 2+ Caen: yn + Dn) (12)
h=0 h=0

In the case of pattern matching with P,, if E,, = 0 for some d, the
pattern P, is found at the index d + 1 of the text T. For a faster com-
putation, we can use the inner product property in [30] for computing
E,_ in Eq. (12) using some packing methods.
T.K. Saha et al.

Algorithm 1: Sub-patterns’ order preserving

Data: All SEDs and their indices, k.

Result: Pattern matches, or no match found.
1ywi=-l; // set the pointer
2yi=l; // Initialization
3 for y<kdo

4 d :=0; 8 :=0; ply] :=0;

5 for d </—p, do

6 if E,y=0 ¢ d>y then

7 ply] :=d+1; // P, found at the position
d+1inT

8 w:=d+p,—-1; // Move forward the pointer
py — 1 positions

9 6 :=1;

10 return;

11 else

12 L Return to the loop;

13 if 0 = 1 then

14 | yisytl1; // Increment y
15 else
16 L Print(‘““No match found”); return;

17 Print(‘‘Pattern matches’); return;

4.1. Order preserving of the sub-patterns

In this subsection, we discuss how the sequences of k sub-patterns
{P,, P),...,P,} are maintained after computing the SEDs between the
sub-patterns P, and the sub-texts of T. Here, we use “match and move
(MaM)” technique to preserve the sub-patterns’ order during matching
all sub-patterns with the text T. After computing the SEDs, the algo-
rithm used for pattern matching by preserving sub-patterns’ sequences
with the MaM technique is shown in Algorithm 1. In this algorithm,
a pointer y is maintained to keep track of the index in the text where
the current pattern ends. Furthermore, the algorithm maintains another
array variable p to keep the indices of each sub-pattern’s match. For the
SPM-RW problem, the sub-pattern ordering will be done according to
their appearance in the main pattern P. For | < y < k, Algorithm 1
stores the non-zero index in p[y] in the order P,, P,,..., P,; otherwise,
declare no match found. Before processing SEDs for any sub-pattern
P,, y is set to —1. Then the algorithm process k sub-patterns one by
one. First, Algorithm 1 finds whether E,, = 0 or E,, # 0 for each
sub-pattern P, at the position d +1 in the text T. If E,, =Oandd>y,
P, is found in the text at the position d + 1. Then the pointer y is set
to the current position d and moved forward P, — 1 positions in the
text T. Moreover, the next sub-pattern P,,, matching, if F,.,4 = 0
for some position d, our algorithm choose d if d > yw. If p[y] = 0 for
some y, the algorithm prints no match found and terminates; otherwise,
pattern matches. In this way, sub-patterns’ sequences are maintained by
Algorithm 1.

Before discussing a solution to the SPM-RW problem, we review
some of the existing packing methods and describe our packing method
that will be used in our protocols.

4.2. Packing methods

The encoding of many bits into a single polynomial is called packing
method. Early researchers [2,21,22,31] used the packing methods to
make the secure computation faster using HE. In this subsection, we
review some of the existing packing methods and describe our packing
method for the SPM-RW problem.

Journal of Information Security and Applications 55 (2020) 102609

4.2.1. Chinese remainder theorem packing

In 2011, Smart and Vercauteren [31] presented the CRT packing,
also called polynomial-CRT based on the Chinese remainder theorem
(CRT), which helps to implement component-wise homomorphic op-
erations especially addition and multiplication. Suppose that Z is a
ring of integers and x” + 1 is an irreducible polynomial over Z in
which n defines the ring dimension. The component-wise operations are
possible because the polynomial x” +1 can be factored completely (into
linear factors) over Z,, where t is a prime that satisfies the condition
t =1 mod 2n. The polynomial x" + 1 factorizes as x” + 1 = Ij", (x — a;)
mod t, where a € Z, is an element of order 2n and a; = a”-' mod t. In
addition, for each linear factor (x—a,) of x” +1, we have a quotient ring
R,, = Z,[x]/(x — a;) = F, of order t. Since the (x — a;)’s are co-prime,
the following isomorphism holds from CRT as follows:

 

 

 

 

 

Ry = Ry xX Ry Xe XR, SPX BX XB. (13)

 

Now we can pack all the messages independently in these smaller
rings, only to apply CRT to construct a polynomial a(x) € R,, which
will be finally encrypted. During the homomorphic operations, the
homomorphism between R, and R, applies to each smaller ring R,,
independently due to co-primality as well as isomorphism. Moreover,
let 6 : Z' > R, be the isomorphic mapping which maps an integer

vector x = (x;,...,x,) € Zi to a polynomial in R,. The mapping is
defined as
d(x) = » x, A,(x)- B; mod t, (14)

i=]

where A,(x) = (x" +1)/(x—a,) and B, = (A,(x)) mod (x —a;) given by
the CRT. Moreover, the inverse mapping ¢"! : R, > Z; is defined as
follows:

p | (a) = (a(x) mod (x — a;), ...,a(x) mod (x — a,)) .

From the above equation, for an arbitrary polynomial P(x), the evalu-
ation of the polynomial P(a,) is the same as doing P(x) mod (x —a,). If
we have two vectors x,y € Z/, the following equations hold:

b | (P(x) x Py))
’'(o~)+¢y)) =
In this way, this packing method can help component-wise operations.

But this packing method requires additional procedure to obtain inner
product [6] for Hamming distance computation.

(X1* VpsX2 + Vos -++sXy * Vy) mod t
(x; + Yj,X2 +2,---,X, + y,) mod t.

4.2.2. Packing method of Lauter et al.

For encoding a long integer like 128 bits, a packing method was
proposed by Lauter et al. [21]. They have packed an integer of n bits
into a single polynomial of degree n — 1. They encoded an n-bit integer
into an n-bit binary vector A = (dp, a ,,...,a,_;) and used a univariate
polynomial to show the packing as follows:

n-1

Poly(A) = » a;x' .
i=0

Limitations: By using SwHE schemes in Section 3, Poly(A) can be
encrypted as ct(A) = Enc(Poly(A),K), where K represents either a
symmetric key or a public key. Besides, the homomorphic operations
may require several additions and multiplications. This packing method
has no problem for adding vectors like A = (ag, a),...,a,_;) and B =
(bo, b;,..., 5,1). On the contrary, the multiplication of Poly(A) and
Poly(B) will increase the degree of resultant polynomial greater than
n—1. If the highest degree of the polynomial is considered at most
n—1, this packing method can perform only d multiplications if the
polynomial is reduced to a polynomial of degree n/d — 1 to pack n/d
bits for 2 <d <n.
T.K. Saha et al.

4.2.3. Packing method of Yasuda et al.

To overcome the problem of Lauter et al.’s packing method men-
tioned above and support many multiplications within the degree n—1,
Yasuda et al. [2] proposed an extension of the packing method in [21].
Their packing method also facilitated secure inner product of two
vectors A = (do, q),...,4,-;) and B = (bo, bj,...,b,_,). They proposed
another packing method to serve a wide range of computations by
applying the inner products to the packed ciphertexts. Here the packing
method for the integral vectors A and B of length n are represented by
the following two univariate polynomials as follows:

n-1 i

PK,(B) = — ey b;x" 1 = ag — Diy bx".

Here the first polynomial PK, (A) is similar to packing method in [21],
but the main modification is performed in the second polynomial
PK,(B) in which Yasuda et al. [2] choose the degree of x in the
decreasing order for each coefficient b;. They used the trick to get inner
product (A, B) = a): by ta, +b) ++ +a,_) +b.) = r a,b, of vector
A and B as a coefficient of x” from the polynomial which is formed by
multiplying above polynomials as PK ,(A) x PK,(B). As mentioned by
Yasuda et al. in [30], this inner product helps the Hamming distance
and the Euclidean distance calculations.

Limitations: Yasuda et al. [6] used the above packing method with
inner product technique for their secure wildcards pattern matching
using symmetric SWHE. In their protocol, they also require three homo-
morphic multiplications for a pattern like “AT*” to match some DNA
sequences “ATA”, “ATT”, “ATG”, and “ATC” over the DNA alphabet. In
their paper, they used a wildcard character ‘“‘*” in the pattern to replace
with a single letter in the text. In this paper, we consider the problem in
which the pattern “GTGCT*CC*GT*T” including repetitive wildcards
can be matched with a DNA sequence “AAGTGCTGCCAGTCGT” as
shown in Fig. 1(a). Furthermore, there exist some gaps in the pattern
represented by the wildcard character “*” which can be used to replace
with zero or several letters in the text. If we split the pattern into
sub-patterns excluding the wildcards, we get 4 different sub-patterns
as “GTGCT”, “CC”, “GT”, and “T;;. For matching these sub-patterns
with the given DNA sequence in the cloud, Alice needs to send 4
queries if we apply the SED technique to our SPM using the technique
of Yasuda et al. [6] with the packing method in [2]. Here 4 queries
need 4 separate matches in the text as shown in Fig. 1(b). As men-
tioned in Section 2.1.2, the SED calculation for each query requires
3 multiplications. Then 4 queries require 12 multiplications if we use
Yasuda et al.’s technique (See Section 4.3.1 for the details). If we could
accomplish the computations by sending one query by Alice as shown
in Fig. 1(c) using some extended packing method, we can reduce the
multiplication cost along with communication cost, which will reduce
the overall computation cost of the pattern matching.

4.2.4. Our packing method

To overcome the above limitation, we define another packing
method than that in [2]. Consider the same pattern P and text vector
T € Z! with |T| =/, where / < n. Here n defines the lattice dimension of
the ring-LWE based SWHE scheme used for homomorphic computation
as mentioned in Section 3. For any computation using ring-LWE based
SWHE, the degree of the polynomial should be n — 1, which includes
n elements as the coefficients of that polynomial. Since each letter of
the text will be encoded into the coefficient of the polynomial, the
length of the text should be less than or equal to n. Furthermore,
the pattern P with k sub-patterns can be represented as an integer
vector P = (P,,P),...,P,) by omitting the wildcards, where P, =
(by.02 Dy.ts +++ Dy p,—1)s |P,| = py, and Die Py < |. To solve the SPM-
RW problem, we can perform the matching by measuring the SEDs
between the text and each sub-pattern of the same length as mentioned
in Section 2.1.2. Now we need to measure many SEDs of every sub-
pattern P, from every sub-text 7, of the text T with |P,| = |T,| = p,.

Journal of Information Security and Applications 55 (2020) 102609

Moreover, T, is the d + 1-th sub-vector (aj, aq41,... »Qa4p,-1) of T of
length p, with 0 < d < (/ — p,). In addition, P, is the y-th sub-pattern
vector of P for 1 <y<k.

Here we can find the SEDs between sub-text T,, and each sub-pattern
P, by the inner product property in [30] (See Section 4.3.2 for the
details). Then we can place those distances as a coefficient of different
degrees of x of a polynomial with the degree n — 1. Therefore, if we
use the packing method in [2] which packs all the sub-patterns into a
single polynomial (See PK,(B) in the previous sub-section), the pattern
matching results of most sub-patterns will be wrap-around the coefficient
with some degrees of x. Then it is difficult to extract each sub-pattern
matching result separately from the resultant polynomial. As a result,
it is necessary to get each sub-pattern matching result as a coefficient
of different degrees of x. Now we need to pack the pattern P in another
way than the packing in [2]. To overcome the above problem that is, to
avoid this wrap-around of coefficient for any degree of x, we take the highest
degrees of x as ly for the first element b,. in P, and decrease those degrees
for other elements b,, in that P, with | <v <p,—landil<y<k.
Therefore, using the packing method of [21] and modifying packing
method of [2], our packing method can be represented by the following
two polynomials in the ring R = Z[x]/(x” + 1) with n > (k + 1)/.

Poly (T) = Ying aj!
- -—1 .

Polyy(P) = Yo, Yi2g bax.

Here the packing method Poly,(T) is similar to the packing in [21].

The main modification is done in the second packing Poly,(P) to pack
k sub-patterns in a single polynomial.

(16)

Remark 2. Here we see that the degree of the polynomial Poly,(P)
increases with the increase of text length /. Furthermore, we know
that multiplication of higher degree polynomials is costlier than that
of lower degree polynomials. Consequently, we keep the value of
/ as small as possible to reduce the degree of the polynomial and
obtain a better result than existing methods (See Section 9.4 for the
details). Besides, we hope that this limitation will be overcome using
the upcoming high configurable machines.

4.3. Solving techniques of secure pattern matching with repetitive wildcards
We discuss two techniques to solve the SPM-RW problem as follows.

4.3.1. Yasuda et al.’s technique

Now we present the solving technique of the SPM-RW problem
using the method in [6]. If we perform the SPM computation of k
sub-patterns separately, the arithmetic computation in Eq. (12) can be
calculated by engaging the inner product property in [30] as follows:
Eyq = (TysVp,) + (PyVi) — 2+ (Ty, Py) (17)
Here V, (resp., Vd denotes a vector like (1,1,...,1) of length / (resp.,
py). If E,q = 0 for some position d in the text T, we can say that the
sub-pattern P, is found at the index d + 1 of the text T; otherwise, the
pattern is not found in the text. For instance, consider the DNA alphabet
as » = {A,G,C,T} encoded as {1,2,3,4}. For the SPM-RW problem,
suppose that the text T = (AGCGATTGC) = (123214423) with / = 9. Also,
suppose that the pattern P = (GC « TTG) = (23 « 442) with 2 sub-patterns
P, = (GC) = (23) and P, = (TTG) = (442). Here the lengths p, = 2 and
P) = 3. Now we can get at most / — p, + 1 SEDs for each sub-pattern
P,. First we need decide whether the pattern P, is occurred in the text
T. We compute E,, by measuring the distance between P, = (23) and
sub-text Ty = (12) using the arithmetic in Eq. (17) as

EF, 9 = (0,4), , 1)) + (4,9), d, D) — 2+ (1, 2), 2, 3)) =5413-2-8=2.

From the above calculation of F,,, it is evident that we can get
the SED through the inner product property. In the similar fashion, we
T.K. Saha et al.

SSS aoeoeehsueoy

MEDIIMNs tcc 7
(a)

pepe pepupede

Journal of Information Security and Applications 55 (2020) 102609

CLES AMMA AOC
|

st een
Een =
Et} ———_—_—_——><
+

 

(b)

SSRs
Ae we |

|

 

Pattern ac 5 G ©.

D-€O-€ D- -®P

Fig. 1. (a) Our problem domain; (b) Pattern matching for a non-binary vector of text and pattern using our sub-pattern matching concept; (c) Our pattern matching technique.

can compute rest of the SEDs for sub-pattern P, as E,,; = 0, EF,» = 2,
E,\3 = 4, Ej, = 2, Eys = 5, Eyg = 5, and E,, = 0. Among these
distances, since E,, and E,, are “0”, we can say that the pattern P,
is found at the indices 2 and 8 of the text T. By following the same
approaches like sub-pattern P,, it is easy to see that the sub-pattern P,
is found at the index 6 since E, 5 = 0.

From the above discussion and example, it is obvious that the
Eq. (17) represents many SEDs required to compute for our pattern
matching. If we follow naive approach to compute the SEDs, we need
to use /—p,+1 times Eq. (17) for each sub-pattern P, to find the pattern
matching distances from text T. Furthermore, Yasuda et al. [6] used an
efficient technique to compute many SEDs using many inner products
for their SPM with a wildcard. They also showed a polynomial-based
computation technique in which each of the SEDs can be found sepa-
rately as a coefficient of different degrees of x of a polynomial with the
degree n— 1. Now we use their approach to our SPM-RW problem. For
a vector A = (ap,...,a;_,;) in the same ring R with lattice dimension n,
they define the packing method as mentioned in Eq. (15). In addition,
we use this packing method to get the many inner products from our
vectors T and P, with p, < / <n. Since x” = —1 in the ring R, the
polynomial multiplication of PK,(T) and PK,(P,) is obtained as

[-1 py-l [-1 Py-1
(Sax!) x (=D bux) == DY ayant
h=0

i=0 i=0 h=0
I—-py Py-l
= » » AgsnbynX" + sub-poly of deg. > 1 — py
d=0 h=0
py
— d (T,, P,)x* + sub-poly of deg. > / — p, (18)

for 1 < y < k. As mentioned in [30], the multiple inner prod-
ucts in the above equation can be used for computing many SEDs
in Eq. (17). Now we use the polynomials in Eq. (15) and the inner
product in Eq. (18) for the computation of the SEDs between text T
and sub-pattern P, as follows:

E, = PK, (T*)- PKy(V,, )+PK(P2)- PK\(V)—2: PK, (T)- PK(P,). (19)

Here the above polynomial contains all the SEDs between sub-text T,,
and sub-pattern P, as the coefficients of x4 for0O <d <1- py. To
serve the purpose of secure computation in the symmetric case, the
above computation is performed between the encrypted pattern and
plaintext in the cloud. Then client needs to send the encrypted k sub-
patterns in the form of cf,(P,) and ct>(P*) in the cloud using SwHE
using the secret key. Now the secure computation can be realized by
the following equation.

ct(E,) = PK,(T*)- PKV, )+ cty(P*)- PK\(V,)—2- PK, (T)-ct(P,). (20)

Moreover, for the asymmetric case, the computation mentioned above
is performed between the encrypted pattern and ciphertext in the cloud.

Thereafter, one client needs to send the encrypted text in the form of
ct,(T) and ct,(T*) using the public key of SwHE. Another client needs
to send k sub-patterns in the form of ct,(P,) and cty(P.) in the cloud
using the same public key. Then the secure computation can be realized
by the following equation.

ct(E,) = ct, (T’) . cty(V, ) + ct>(P*) -cty(V,) —2- ct, (T)- cty(P,). (21)

Now we use all these secure SEDs to finalize pattern matching by
preserving the sub-pattern sequences with the help of Algorithm 1.

Limitations: If we use Yasuda et al.’s technique [6] to solve the SPM-
RW problem, we need to send k queries and requires 3k homomorphic
multiplications in the server, which is time-consuming along with the
communication cost (See the results in Sections 9.2 and 9.5.1). Can we
solve the SPM-RW problem with a few multiplications rather than 3k
multiplications to reduce the computation cost?

4.3.2. Our technique

To achieve more efficiency, we need to compute many SEDs of
Eq. (12) in a fewer multiplications than the technique in [6]. As men-
tioned in Section 4.3.1, Yasuda et al.’s technique allowed processing k
sub-patterns by sending k queries to the cloud separately. Here we can
achieve more efficiency if we are able to pack all the sub-patterns in one
polynomial and send it as a single query to the cloud. Now we engage
the polynomials in Eq. (16) which enable us to pack all sub-patterns
into a single polynomial. Moreover, we can get the SEDs between each
sub-pattern P, and sub-text 7, as the coefficients of a polynomial for
different degrees of x with the inner product property as follows.

Inner product property. As discussed in Section 3.2 of [30], the inner
product of two vectors helps to compute the Hamming distance and
Euclidean distance. To find the inner product property using our pack-
ing method in Eq. (16), the polynomial multiplication of Poly,(T) and
Poly,(P) can be shown as follows:

i-1 k Py-
Poly, (T) X Poly>(P) = (Sa st) x (x y by ;x!” “)

j=0 y=1 i=
k 1-1 Py-1
= » ajb, xi
y=1 j=0 i=0
k !—py py-l
=») dg4nby, nxt + TOHD + ToLD
y=1 d=0 h=0
k !-py
= Y(t, P,)x?*4 + ToHD + ToLD. (22)
y=1 d=0

The above equation shows that one polynomial multiplication in-
cludes many inner products (7;, P,). In addition, TOHD (terms of higher
degree) defines a sub-polynomial such that deg(x) > (/y +1 — py)
and ToLD (terms of lower degree) also defines another sub-polynomial
T.K. Saha et al.

Enc(Poly>(P),sk)= ct2(P)

  
  

C,., Pattern Matching Result (Encrypted)
) Toc
R, = Dec(C,, K)
P = {P1,P2, meg et
ToC: Table of Computation
sk : Secret key
© :Some homomorphic operations

 
     

Alice

C,=ct>(P)© Poly, (T)
Text,T

Fig. 2. SPM-RW protocol with symmetric SwHE.

such that deg(x) < ly. For instance, consider the problem of searching
DNA sequences over the alphabet X = {A,G,C,T}. We can encode the
alphabet by the set of integers as {1,2,3,4}. To illustrate the inner
product property using our packing method for solving the SPM-RW
problem, consider the text T = (CAGCGACTTG) = (3123213442) of length
/ = 10 and the pattern P = (AGCG « TTG) = (1232 « 442) with 2 sub-
patterns P, = (1232) and P, = (442) such that p, = 4 and p, = 3. Since
/ = 10 and k = 2, we set n = 32 to satisfy n > (k+1)/. If we pack the text
T using our packing method in Eq. (16), we can get the polynomial as
Poly, (T) = 3 +x + 2x? + 3x3 + 2x4 4+ x? +3x® + 4x7 + 4x8 4+ 2x?. Now
we pack two sub-patterns in one polynomial using our packing method
as Poly,(P) = x! + 2x? +3x8 + 2x7 + 4x79 + 4x!9 + 2x!8. If we multiply
Poly,(T) and Poly,(P) according to inner product property in Eq. (22),
we get the polynomial as follows:

Poly, (T) X Poly>(P)
= 6x! + 11x28 + 13x? + 17x!9 + 18x!) + 16x)? + 16x!3 + 21x!4 +27x)
27x!6 4 18x!7 + 14x18 + 16x!920x29 + 18x27! 4+ 24x72 + 22x73 + 18x24

QAx?? + 36x26 + 36x77 + 24x28 4 8x7?
(Tq,P\)

+ +

eo, HO
= (17x!9 + 18x!! + 16x!? + 16x!3 + 21x!4 + 27x! 4 27x!)
(Tq,P2)

_——————E—
+ (20x29 + 18x7! + 24x°? + 22x79 + 18x74 + 24x75 4+ 36x76 + 36x?)
ToLD ToHD

i _——EEEEEE
+ (6x? + 11x8 + 13x?) + (18x17 + 14x18 + 16x19 +. 24x78 + 8x79). = (23)

From the above example, it is obvious that we get two inner products
(T;,P,) and (T,, P,) for our two sub-patterns P; and P, respectively
according to inner product property in Eq. (22). Since / — p, +1 =
10-—4+1 = 7, we get total 7 SEDs for the sub-pattern P, which is
indicated in Eq. (23) as the coefficients of x!°+4 for 0 < d < 6, where
ly = 10-1 = 10 and/—-p, = 10-4 = 6. According to Eq. (23),
since / — p» + 1 = 10—3+1 = 8, we get 8 SEDs for the sub-pattern
P, as the coefficients of x?°+4 for 0 < d < 7, where /y = 10-2 = 20
and / — p» = 10-3 = 7. Furthermore, we indicate lower degree
sub-polynomial and higher degree sub-polynomial in Eq. (23).

The above inner product property will help us to get all SEDs as the
coefficients of x!’+? of a large polynomial. Moreover, we perform the
arithmetic computation of the SEDs in Eq. (12) using the polynomials
in Eq. (16) as

Eqis = Poly,(T’) - Polyy(Vip)) + Poly,(P?) - Poly, (V,;) —2- Poly, (T)

- Poly,(P), (24)
where V, (resp., Vp) denotes a vector like (1,1,...,1) of length / (resp.,
| P|).

4.4. Our protocols for secure pattern matching with repetitive wildcards

As mentioned in Section 1.2.1, we consider two scenarios for the
SPM-RW problem among several parties: one using symmetric ring-
LWE based SWHE and another using public-key ring-LWE based SwHE.

Journal of Information Security and Applications 55 (2020) 102609

Moreover, every pair of parties use private and authenticated point-
2-point channel for communication to avoid eavesdropping. Now we
discuss the SPM-RW protocols using two settings of ring-LWE based
SWHE by engaging the technique mentioned in Section 4.3.2.

4.4.1. Our protocol using symmetric encryption

To describe our protocol using symmetric SwHE, we consider a
scenario for an SPM between Alice and Bob. For example, Bob has the
text vector T = (ap, a),...,@)_,) of length / as Poly,(T) and Poly,(T’)
using our packing method in Eq. (16) to his secure server which
has a huge computation capability. Furthermore, Alice has a pattern
P= (byob Bip -1 * 42,0521 7° b2,p)-1 * * dp obk a ** Ok p,-1)
with some wildcards which can be found in the plaintext T. More-
over, Alice divides the pattern into sub-patterns as {P,, P),..., P,}
excluding the wildcard characters such that the length of each sub-
patterns P, = p, with 1 < y < k and Diet Py < /. Then Alice
concatenates all sub-patterns sequentially to form a pattern vector
as P= (b1.9.b1 15 ---+B1,p, 1+ 92,05 2,15 +++ + Ba,py 19 «+ 2 Dk, 02 Diets ++» kapg 1)"
Now Alice does not want to reveal his pattern to Bob. On the contrary,
Bob cannot reveal his information outside his server. Here homomor-
phic encryption property [32] can handle this situation. We know
that FHE can perform arbitrary operations which have large time
complexity. However, less costly SwHE as mentioned in Section 3.2 is
suitable for the above scenario. In addition, as shown in Fig. 2, our
protocol can be expressed concisely by the following points.

1. Alice has a pattern P with multiple wildcards. She breaks down
the pattern P into sub-patterns {P,, P),...,P,} excluding the
wildcard characters to form the vector P and packs them as
Poly,(P) and Poly,(P*) with our packing method mentioned in
Eq. (16).

2. Then, she encrypts Poly,(P) and Poly,(P*) with the homomor-
phic key generated by herself and sends the encrypted patterns
to Bob for performing a secure search.

3. With Eq. (24), Bob performs the required pattern matching
computation between text T and encrypted sub-patterns P by
Eq. (24) and adds some random masks to the result to protect
extra information leakage.

4. Bob then returns the resultant polynomial containing the en-
crypted SEDs to Alice in which all the SEDs can be found sepa-
rately as the coefficients of x!’+4 of the polynomial according to
Eq. (22).

5. Alice uses her keys to decrypt the results to check all the SEDs
separately whether they are “0” or not. Finally, she uses Al-
gorithm 1 for considering the wildcards in the pattern and
calculates her desired result of pattern matching.

4.4.2. Our protocol using public-key encryption

The symmetric SWHE encryption is not able to provide security
to the text and the pattern if we consider their owners are different
entities and do not want to disclose their information to each other.
Consequently, we propose another protocol using a public-key SwWHE
to provide security to the text and the pattern. For this protocol, we
consider an SPM scenario among Alice, Bob, Charlie, and a special
party called cryptographic service provider (CSP). For example, let us
consider a laboratory (Charlie) has DNA text T = (aga, +: a;_,) of length
1. Moreover, a doctor (Alice) wants to match her patient’s DNA pattern
P= (byob 1p, -1 * 92,0021 7 bap ®t Dg 0bE1 7 Pky, 1) With
wildcards against the data T belonging to Charlie. In addition, neither
Charlie can disclose his data to Alice nor Alice can disclose her patient’s
DNA pattern to Charlie due to the security. But they are agreed to
accomplish the computation in a secured fashion. Moreover, CSP is a
trusted party with less resources for many computations whereas all
other parties are semi-honest. We assume that Bob and CSP do not
collude with one another. If Alice and Bob agree, CSP performs the
SPM with the help of another party like Bob in the cloud server who
T.K. Saha et al.

  
   
    
     
 
    
  

      

Enc(Poly,(T),pk)= ct,(T)

2

C,.=ctz (P)O ct,(T)
Encrypted Text, ct,(T)

 
 
  

P={P,, Pyros Py}
C, : Pattern Matching Result (Encrypted)
ToC: Table of Computation

Charlie

 
   

 

 

pk sk: Secret key; pk : Public key
©: Some homomorphic operations
Enc(Poly>(P),pk)
=F Toc
{Cryptographic Ry =—=K
Service WE
Provider) K = Dec(C,, sk)

 

 

Alice

Fig. 3. SPM-RW protocol with public-key SwHE.

has massive computation capability. From the above scenario, the SPM-
RW protocol (See Fig. 3) based on public-key SwHE as mentioned in
Section 3.4 can be described concisely by the following points.

1. CSP generates a secret key and public key and provides the
public key to Alice and Charlie through a secure channel.

2. Using the packing method in Eq. (16), Charlie packs his text T
as Poly,(T) and Poly, (T7) and uses the public key to encrypt his
text Poly,(T) and Poly,(T”) and sends them to Bob.

3. Then Alice breaks down the pattern P into sub-patterns {P,, P),
..., P,} excluding the wildcard characters to form the vector P.
Then she packs P as Poly,(P) and Poly,(P”) by utilizing the
packing method in Eq. (16).

4. Alice then encrypts Poly,(P) and Poly,(P*) with the public key
and sends the encrypted patterns to Bob for performing a secure
search.

5. According to Eq. (24), Bob performs the required pattern match-
ing computation between the encrypted text T and all sub-
patterns P by Eq. (24).

6. Bob then returns the resultant polynomial containing the en-
crypted SEDs to CSP in which all the SEDs can be found sep-
arately as the coefficients of x!’+¢ of the polynomial according
to Eq. (22).

7. CSP decrypts the result using its secret keys and send the result
to Alice.

8. Alice check all the SEDs separately whether it equals “0” or
does not equal “0”. Then she uses Algorithm 1 for considering
wildcards in the pattern and calculates the final result of pattern
matching.

5. Technique of secure pattern matching with compound wild-
cards

In this section, we discuss the technique to solve the SPM-CW
problem in which we show the application of SPM for PDBQ processing
with compound wildcards. In the presentation of database query, the
wildcard “%” represents zero or multiple characters. We consider the
symbols “*” and “%” synonymously for the presentation of query
with compound wildcards. For example, a pattern “%con$lu%” can
be matched with the texts such as “conclude”, “conclusion”, ‘con-
clusive”, and so on. In addition, a pattern with compound wildcards
“%in!(con)$tab%” that can be used to exclude the words started with
“incon” from a word database. For processing the PDBQ, consider
a table “Record” with m attributes as Y = {Aj,,A),...,A,,} and rt
records. For this table, a user can send a pattern matching query with
compound wildcards as select V from Record where A; like “%P%”,
where V € Y, A; € Y, and P is a pattern string with compound
wildcards for 1 < k < w. Now we need to compare the pattern P with
t records of the table for the attribute A;. Moreover, each record of
attribute A; can be represented by the text T = (aga, ---a,_,) of length

10

Journal of Information Security and Applications 55 (2020) 102609

gy, where a; is any lowercase letter. Also, the pattern with compound
wildcards P = (bg ++ $b)\(Ci44 + Cpe) bige41 77 $bg_1) Of length 9 with
b;,c; © A in which A represents the English alphabet. In addition,
the wildcard “$” matches any character in the text and “!(z)” matches
a single non-empty character except z. Furthermore, we consider the
pattern with compound wildcards as a single pattern in which we
do not use any pattern splitting technique as mentioned in our SPM-
RW protocols. Therefore, we need an efficient method of processing
compound wildcards in the pattern to match the records. Here we
propose a double-query technique to efficiently process PDBQ with
compound wildcards. Let us discuss the technique to solve the SPM-CW
problem along with the SPM-CW protocol in the following subsections.

5.1. Double-query technique

We form the integer vectors from the text and the pattern by
mapping the letters appearing in that text and pattern to integers. Since
the wildcard “$” matches any character in the text, “$” is encoded
as 0 for the ease of our pattern matching. Now consider the record
T = (aoa, -*- ag_;) of length g (g < n), we can pack y = |n/@| records
of an attribute in a single ciphertext within the lattice dimension n.
For y records 7, € Z?, we merge them to construct an integer record
vector T = (J;,...,7,) € ZP’, where 7, = (a,9,4,),..-.4,g-1) € Z®
with 1 < 1 < y. Moreover, we deal with compound wildcards of
the form “%P%” in which P can have “$” and “!” wildcards. For
the pattern “%P%”, we do not need to process “%” wildcard because
it appears at the beginning and end of the pattern in which “%” is
replaced with zero or more letters in the text. In addition, consider
a pattern string P = (bg +: $b) M(ci44 + Cine )bi4e41 °° $bg_1) with “$” and
“1” wildcards in which the sub-pattern c;,, ---c;,~ of length ¢ appears
inside the “!Q” wildcard. To handle the “!” wildcard using our tech-
nique, a user needs to send two patterns as a query to accomplish
the matching for compound wildcards that we call “double-query”.
Therefore, we call our technique double-query technique. Here final
result can be calculated by taking the set difference of two pattern
matching results regarding two queries. Now we construct two pattern
strings from the single pattern P. The first pattern string is P, =
(bo «++ $b;$ +++ $;4241 + $h9_1) by inserting one “$” character in place of
every character in sub-pattern c;,, --- c,,. Furthermore, the second one
is Py = (by ++ $bjCi44 + Cpe bi 4e41 +7 $bg9_1) which is formed by removing
“!(Q” wildcard from the pattern P. From P, and P,, let us form a general
pattern vector P = (po,...,Py_,) € Z° of length 9. For 1 <1 < y and
0 < d < p-— 98, we compute the distance between the pattern vector
P = (Po, ..-,Py_) and sub-texts vector T,y = (@,4,.--,4),a49-1) Of T, by
the modified SED technique as follows:

9-1
E,a = » Pa: (Pa -4ia+n) - (25)
h=0

If E,, = 0 for some : and d, the pattern is found in the text 7, at the
position d+1. To support an efficient batch computation in Eq. (25), we
use our packing method in Eq. (16) to pack T and P by considering the
number sub-pattern k = 1. Now the distance between any character in
the sub-text and the character “$” will be 0 always, i.e., it will match
any character in the sub-text. Using our packing method in Eq. (16),
the arithmetic computation in Eq. (25) can be represented as

A = Poly,(V)q))- Poly(P*) + Poly,(T*)- Poly,(P)—2-Poly,(T)- Polys(P7),
(26)

where Viz; is a vector like (1,...,1) of length |T|. We calculate P? and
P? from P = (po, ...,Py_;) with each p,, being replaced with p* and p;,
respectively. To calculate these distances, we encode the text vectors T
and T’ using Poly,(X) encoding, where X is any integer vector of length
g-y = 1. In addition, the pattern vectors P,P’, and P* are encoded
using Poly,(Y), where Y is any integer vector of length 8 with k = 1.
Using the inner product property in Eq. (22), we can get each E,, as
T.K. Saha et al.

the coefficient of x?'t4 from A in Eq. (26). Since we have two query
strings P, and P, for the pattern P, we need to construct two query
vectors P, and P, as well.

Algorithm 2: Post-processing steps

Data: A, (Query-1 result vector), 4, (Query-2 result vector), y
(Number of texts), 9 (Pattern length), gy(Text length)
Result: Result of pattern matching

1 for: — 1 to y do

2 flag := false;

3 P :={} // Pattern Indices

4 | N,:={}// Not Pattern Indices
5 ford <0 to p— 8-1 do

6 if A,[g-1+d]=0 then

7 P.add(g-1+d);

8 if flag = false then

9 | flag := true;
10 end
11 end
12 end
13 if flag = true then
14 ford <0 to p— 8-1 do

15 if 4,[p-1+d]=0 then

16 | N,.add(g-1+d);

17 end

18 end

19 R,:= PB —N,;// set difference
20 if R, 4 {} then
21 print ('Pattern matched with the i-th

text");

22 else
23 | print ("No pattern matched");
24 end
25 end
26 end

5.2. Post processing

Now we describe the post-processing steps that are needed to solve
the SPM-CW problem as mentioned in Algorithm 2. In this algorithm,
we maintain the sets P, and N, that contain locations where the pattern
P, and P, match the sub-text respectively. Let 4, and A, be the
polynomials which are constructed by computing the Eq. (26) for P,
and P, respectively. Now we add the indices d € [0,y — 9] to PB
if the coefficient of x®'t4 in A, is 0. Similarly, we add the indices
d € [0,9 — 8] to N, if the coefficient of x®'+¢ in A, is 0. The “!Q”
wildcard character can match any string of same length other than the
sub-pattern appeared inside the “!()” wildcard. Therefore, if we take the
set difference between sets P and N, for each text 7,, i.e., R, = P —N,,
and if the set R, is not null, i.e., R, # {}, we can say that the pattern P
matches the text 7,.

5.3. Our protocol for secure pattern matching with compound wildcards

In this subsection, we describe the SPM-CW protocol regarding
PDBQ processing. Suppose that Alice has the pattern P with compound
wildcards and Charlie is the database owner who has the text 7. Here
Alice and Charlie want to perform the pattern matching blindly. Now
Bob in the cloud can help them in this secure computation. In addition,
we use three-party protocol among Alice, Charlie, and Bob in which
Alice generates a secret key and a public key by herself and provides
the public-key to Bob and Charlie through a secure channel. Since our
computation is polynomial-based, we show some extra steps to hide
every coefficient of the resultant polynomial except those coefficients

11

Journal of Information Security and Applications 55 (2020) 102609

which are equal to “0” to provide more security to this protocol. From
the above scenario, the SPM-CW protocol can be described by the
following steps.

1. Charlie packs his text as Poly,(T) and Poly,(T?) using the pack-
ing method in Eq. (16) and uses Alice’s public key to encrypt
Poly,(T) and Poly,(T*) and sends them to Bob.

2. Depending on the compound wildcards appeared in the pattern,
Alice constructs two patterns string P, and P, from P using the
double-query technique and then constructs two integer vectors
P, and P, respectively from them.

3. By utilizing the packing method in Eq. (16), Alice packs P,
(resp., P,) as Poly,(P,), Pol y(P*), and Poly,(P?) (resp., Poly,
(P,), Poly,(P5), and Poly,(P3)).

4. Alice then encrypts Poly,(P,), Poly,(P*), and Poly,(P?) (resp.,
Poly,(P,), Pol y(P5), and Poly,(P3)) for the double-query with
her public key and sends the encrypted patterns to Bob for
performing the pattern matching according to Eq. (26).

5. Now Bob performs the required pattern matching computation
between the encrypted text T and two patterns P, and P, sepa-
rately and adds some random masks R, € Z/ and R, € Z/ to the
results respectively through addition.

6. Bob then returns the two encrypted results to Alice. She then de-
crypts the randomized results and again packs them according to
CRT packing method as mentioned in Eq. (14) in Section 4.2.1.

7. Alice now encrypts them again and sends them to Bob for
component-wise masking.

8. After receiving the encrypted results from Alice, Bob removes
first random mask R, and R, by subtraction with the help of
CRT encoding.

9. Bob again generates two random masks according to CRT pack-

ing method and adds the masking to the results respectively

through multiplication and sends the randomized results back
to Alice.

Finally, Alice uses her keys to decrypt the results and checks all

distances for each 7, separately whether it is “O” or not. Then

she uses our Algorithm 2 to calculate her desired result from the
set difference of two results obtained from two patterns P, and

Py.

10.

Remark 3. Note that our protocols are secure under the assumption
that Bob is semi-honest (also known as honest-but-curious), i.e., Bob
always follows the protocols but tries to learn information from the
protocols.

6. Many inner products computation

As mentioned in our symmetric SPM-RW protocol in Section 4.4.1,
Alice has encrypted pattern P and Bob has the text T in the plaintext
space R,. Here we define packed ciphertext ct,(M) for a plaintext vector
M € R, using our packing method and symmetric encryption scheme
in Section 3.2 as

cty(M) = Enc(Poly,(M), sk) € (R,)” (27)

in which M can be P and P*. Here the following proposition is
required to satisfy to compute the SEDs for the SPM-RW protocol using
symmetric SwHE scheme in Section 3.2. Moreover, we can prove the
proposition with the help of the inner product property in Eq. (22).

Proposition 1. Let T = (ap, a),...,a)_,) € Z! be a vector of text with
|T| = 1. Moreover, P = (bi 9,011, -++ 1,9, -15 42,0 62,15 «++ + ba,py—ds + Dk 0»
bys +++ > Dk p,-1) Is pattern vector with k sub-patterns in which the length of
each sub-pattern is represented by p, with Ye Py <! <n. If the ciphertext
of P is represented by ct,(P) by Eq. (27), under the condition of Lemma 1,
decryption of homomorphic multiplication Poly, (T) ® ct.(P) € (R,)° will
produce a polynomial of R, with x!'’*4 including coefficient (Ty, Py) =
T.K. Saha et al.
-1

an Ag+nby, mod t for | <y<kand0 <d </—p,. Alternatively, we can
say that homomorphic multiplication of Poly,(T) and ct,(P) simultaneously
computes multiple inner products (T,, P,) for1 < y< k and0 <d < (/—p,).

Proof. By the correctness in Eq. (5) and Lemma 1, we can say that
homomorphic multiplication of Poly,(T) and ct,(P) corresponds to
the polynomial multiplication of Poly,(T) and Poly,(P) in the ring
R,. In addition, we already know from the inner product property in
Eq. (22), the polynomial multiplication of Poly,(T) and Poly,(P) pro-
duces many inner products (T,, P,) as the coefficients of x'’*?, which
equals an dg4nbyn for 1 < y< k and 0 <d </~—p,. Consequently,
the proposition holds under the correctness in Eq. (5). 1

For our public-key SPM-RW protocol in Section 4.4.2, Alice has
encrypted pattern of P and Bob has the ciphertext of T in R,. Now we
define packed ciphertext of a vector N € R, using our packing method
and public-key encryption scheme in Section 3.4 for w = {1,2} as

ct,(N) = Enc(Poly,,(N), pk) € (Ry) (28)

in which vector N can be replaced with T, T*, P, and P* separately.
We define another proposition that is also needed to satisfy to compute
the SEDs for SPM-RW protocol based on public-key SwHE scheme in
Section 3.4. In addition, we can prove the following proposition by
using the inner product property in Eq. (22).

Proposition 2. Consider the same text vector T and pattern vector P as
defined in Proposition 1. If the ciphertext of T (resp., P) can be expressed
by ct,(T) (resp., ct>(P)) by Eq. (28), under the condition of Lemma 2,
decryption of homomorphic multiplication ct,(T) Kl ct.(P) € (R,) will
produce a polynomial of R, with x!¥+¢ including coefficient (Ty, Py) =
Ye gnby, modt for 1 < y<k and0 <d <!-»p,. Strictly speaking,
homomorphic multiplication of ct,(T) and ct,(P) simultaneously computes
multiple inner products (Ty, P,) for1 <y<k andO0<d<(/—p,).

Proof. With the help of correctness in Eq. (11) and Lemma 2, we can
say that homomorphic multiplication of ct,;(T) and ct,(P) is comparable
to the polynomial multiplication of Poly,(T) and Poly,(P) in the ring
R,. In addition, we already know from the inner product property
in Eq. (22), the polynomial multiplication of Poly,(T) and Poly,(P)
produces many inner products (T,,P,) as the coefficients of xlytd
which equals LY dgsnbyn for 1 < y<kandO0<d</-p,. Asa
result, the proposition holds under the correctness in Eq. (11). 0

7. Secure computation of pattern matching with repetitive wild-
cards

Through Eq. (24), we have already shown the calculation of many
SEDs in Eq. (12) using our packing method for the SPM-RW problem.
In our symmetric and public-key SPM-RW protocols, Bob calculates
Eq. (24) homomorphically over the packed ciphertexts, which is shown
in the following subsections.

7.1. Symmetric secure pattern matching with repetitive wildcards

As mentioned in our protocol in Section 4.4.1, symmetric SPM-
RW protocol occurs between plaintext T and encrypted pattern P. To
compute the Eq. (24) homomorphically, we construct the ciphertexts
of Poly,(P), Poly,(P?), and Poly,(V,p)) as cty(P), ct>(P*), and ct,(Vp))
that can be obtained by Eq. (27). In addition, the following theorem
requires for this computation.

Theorem 1. Under the condition Lemma 1, the linear combination of
homomorphic operations

Poly, (T7) Rlcty(V; p)) FH Poly, (V;) Rlety(P?) FA (-2 Poly, (T) Rety(P)) (29)

12

Journal of Information Security and Applications 55 (2020) 102609

simultaneously computes multiple values of Eq. (12) using our packing
method and Eq. (27) for0 < d < (I—p,) and 1 < y < k onencrypted data in
which Vip denotes the unit vector (1,1,...,1) of length |P| and V, denotes
another unit vector (1,1,...,1) of length 1. Concretely, the homomorphic
operation in Eq. (29) gives a polynomial of R, in which the coefficient of
x'v+4 is equal to E,, in Eq. (12) for eachO <d <(l-p,) andl <y<k
on encrypted data.

Proof. The property in Eq. (22) and Proposition 1 show that each
x'7+4.th coefficient of Poly, (T*)Rct(V;p|) is equal to the sum (a, Wo
i diyy i) (yh DP = Lyk) a, for 0 < d < (Wp, and
1 < y < k, where A’ denotes the transpose of a vector A. Similarly,
we can say that the homomorphic multiplication of Poly, (V,) Kl ct,(P’)
and (—2Poly,(T) & ct)(P)) computes two polynomials on encrypted

: . : -1
data with the x!*4-th coefficient, which are equal to >, 0 b* , and

—2 an dg+n * by, respectively for each O < d < (/—p,) and 1 <
y < k. Finally, we can say by the correctness in Eq. (5), it proves
that homomorphic operation in Eq. (29) constructs a polynomial of
R, in which the coefficient x!’*4 is equal to E,q in Eq. (12) for each
O<d<(/—p,)and1<y<k onencrypted data. 1

7.2. Public-key secure pattern matching with repetitive wildcards

Since the text T and the pattern P are encrypted in public-key
SPM-RW protocol in Section 4.4.2, we require to state another theorem
than Theorem 1. We construct the ciphertexts of Poly,(T), Poly,(T7),
Poly, (V,), Poly (P), Poly,(P?), and Poly2(V,p)) as ct,(T), ct,(T”),
ct,(V;), ¢t>(P), ct>(P?), and Poly(V,p,) respectively with Eq. (28) to
calculate Eq. (24) homomorphically.

Theorem 2. Under the condition Lemma 2, the linear combination of
homomorphic operations

ct, (T*) KR cty(V,p,) EA ct, (V;)  cty(P*) EA (-2ct (T) RI ct>(P)) (30)

simultaneously computes multiple values of Eq. (12) with the help of
Eq. (28) for 0 < d < (/—p,) and 1 < y < k on encrypted data in which
V, p, denotes the unit vector (1, 1,..., 1) of length | P| and V, denotes another
unit vector (1,1,...,1) of length 1. Precisely, the homomorphic operation in
Eq. (30) gives a polynomial of R, in which the coefficient of x!'?+4 is equal
to E,, in Eq. (12) for each 0 < d < (/—p,) and 1 < y< k on encrypted
data.

Proof. The proof of this theorem is nearly same as Theorem 1.
The inner product property in Eq. (22) and Proposition 2 show that
each x'’+4-th coefficient of ct\(T*) & ct,(Vjp,) is equal to the sum

dey, Usd DT = Diy ay, for 0 < d < U-p,)
and 1 < y < k, where A? denotes the transpose of a vector A.
Similarly, we can say that the homomorphic multiplication of ct,(V,) XK
ct>(P*) and (—2ct,(T)&ct,(P)) computes two polynomials on encrypted

: . : -1
data with the x!*4-th coefficient, which are equal to >, 0 b , and

—2 an dg+n * by, respectively for each O < d < (/—p,) and 1 <
y <_k. Finally, we can say by the correctness (11), it proves that
homomorphic operation in Eq. (30) produces a polynomial of R, in
which the coefficient x/’+4 is equal to E,q in Eq. (12) for each 0 <
d<(/—p,) and 1 <y<k onencrypted data. (

7.3. Random masking

In our SPM-RW protocols, we have already used masking to sup-
press information leakage. Now we discuss the reasons for information
leakage in the protocols and their countermeasures through masking as
follows.
T.K. Saha et al.

7.3.1. Information leakage problem

For the SPM-RW protocols, information leakage problem may occur
if Bob sends an encrypted polynomial to Alice without any masking
after homomorphic calculation. Here our protocols perform the pattern
matching between text T and pattern P. Both of our protocols calculate
the pattern matching in the cloud with the decryption help from
Alice for the decision making. For the two protocols of the SPM-RW
problem, the cloud calculates the SED E,, in Eq. (12) by engaging
the arithmetic computations in Eqs. (29) and (30) for symmetric and
public-key case respectively. From these computations in Eqs. (29) and
(30), it is obvious that Bob obtains cr(E,,) using three polynomial
multiplications and two additions homomorphically. Moreover, the
polynomial multiplication produces a large polynomial; Alice uses a
sub-polynomial of the large polynomial to get all E,, , as the coefficients
of x!*4, In our protocols, if Bob would send the encrypted polynomial
to Alice after the homomorphic computation without any masking,
Alice can get some extra information from that polynomial, whereas
she requires only the coefficients of x!’+¢.

7.3.2. Countermeasures
To suppress the information leakage problem mentioned in Sec-
tion 7.3.1, we can use two countermeasures as follows.

Random polynomial addition. In our SPM-RW protocols, we can hide
the extra information from leakage to Alice by using some random
masks at the cloud (Bob) ends. Bob adds a random polynomial r to
ct(E, ,) for masking extra information since Alice needs to check only
the coefficient of x'’t? from the large polynomial ct(E,,,) produced by
Bob. The random polynomial in the ring R can be represented by the
following equation:

l-1

r=¥r,

i=0

k Py-l

+) 2 Vy+1)I-j

y=l j=

x OtD Ij

We can use the above random mask to hide all coefficient of ct(E, )
except the coefficients x!’+4. Here ct(E, ,) consists of three ciphertext
components as ct(E, 4) = (co, ¢),¢). Now Bob adds r to the ciphertext
as cE, p= Ct Ey a) Ar = (co rc), ¢9). Then the resulting ciphertext
ct(E’ D ‘contains all required information as the coefficients of x!’*+4
and hide all other coefficients using the random mask r. In this way,
we can protect cf(E,,) from leaking any information to Alice except
the coefficients of x!’*4.

Random vector multiplication. As we know from our protocols, Alice
needs to find out only the coefficients of x!’+4 with having “0” from
the degree n—1 polynomial ct(E, ,) produced by Bob after decryption.
Here we can hide all the n coefficients except “O” by multiplying a
small random r; € Z* with every coefficient through component-wise
multiplication for 0 < i < n— 1. Now we represent n coefficients of
the polynomial ct(E, ;) as a vector C = (0, 6), ...,¢,-;) and the random

vector as R = (ro, r),.--,/,-1)- Then the masking can be represented by
the equation as follows:
CX R= (C9 +1000, ys e605 Sua  n-1) (31)

To achieve the above masking over the encrypted polynomial, we can
use the CRT packing as mentioned in Eq. (14) in Section 4.2.1. By
using CRT packing, we can perform the masking of the results for two
protocols using the component-wise homomorphic operations over the
ciphertexts by the following steps.

1. Bob adds the random mask R, € Z/ to the encrypted result
through addition.

2. Bob then returns the encrypted results to Alice, and she then
decrypts the randomized results and again packs them according
to CRT packing method in Eq. (14).

3. Alice now encrypts them again and sends them to Bob for
component-wise masking.

13

Journal of Information Security and Applications 55 (2020) 102609

4. After receiving the encrypted results from Alice, Bob removes
first random mask R, by subtraction with the help of CRT
packing.

5. Bob again constructs another random mask in Z/ with the help
CRT packing method to allow component-wise masking.

6. Now Bob adds the masking to the result through multiplication
and sends the randomized results back to Alice.

Using the above technique, the computation time of masking will be
increased slightly due to using new packing. In addition, the multi-
plication technique reveals the coefficients containing “O” only, which
occurs at some coefficients of x!/’+?. On the contrary, the random poly-
nomial addition method reveals all SEDs appeared at the coefficients
of x'’+4, but the technique does not reveal any information regarding
actual data. Therefore, the random vector multiplication approach can
hide more information than the random polynomial addition method.
However, both methods of masking secure actual data regarding the
pattern and the text.

Now we can use any of the above solutions to accomplish the
masking mentioned in our SPM-RW protocols in order to suppress
the information leakage. However, we follow the random polynomial
addition to add masking in the SPM-RW protocols for the efficiency.

7.4. An example of symmetric secure pattern matching

After the computation of many SEDs for each sub-pattern, we give
an example to show how the pattern matching is performed on the
text by using Algorithm 1 by maintaining the sequence of sub-patterns.
The text and the pattern along with sub-pattern matching indices are
depicted in the table of computation (ToC) which is shown in Fig. 4.
Suppose that Bob has the plaintext T = AAGTGCTGCCAGTCGT such
that |T| = 16 and Alice has the pattern P = GTGCT*CC*GT*T with
k = 4. Here we get the sub-patterns as P, = (GTGCT), P, = (COC),
P; = (GT), and P, = (T). Then the length vector (p,, py, p3, p4) of sub-
patterns is (5,2,2,1). We get our parameters for the pattern matching
as 0 <d < (16—p,) and 1 < y < 4. Furthermore, we represent the
alphabet 2 = {A,G,C,T} as {1,2,3, 4} to encode the text and the pattern
using non-binary vectors. By encoding algorithm, the text T can be
represented as T = (1124234233124324). We also encode all the sub-
patterns as P,; = (24234), P, = (83), P; = (24), and P, = (4). Next,
we concatenate all the sub-patterns as P = {(24234), (33), (24), (4)}. By
using our packing method in Eq. (16), Bob will have the text Poly,(T)
and Poly,(T*). Next, Alice encrypts all sub-patterns using her key into
a single polynomial by Poly,(P) and Poly,(P*). Finally, she encrypts
Poly(P) and Poly,(P*) as ct)(P) and ct,(P*) respectively and sends
them to Bob for pattern matching computation. Bob accomplishes the
pattern matching according to Theorem 1 to compute EF, , in Eq. (12).
He also adds some random masks to the polynomial coefficients with
the degree other than /y + d. Then Bob returns the result to Alice
in encrypted form. Alice then decrypts the result and finds out the
coefficients of x!?+4 and determines the indices where each sub-pattern
matches the actual text using Algorithm 1 as shown in Fig. 4.

Here sub-patterns P,, P,, and P; match at the indices 2, 8, and 11
respectively. However, sub-pattern P, matches at the four indices 3, 6,
12, and 15. Now Alice considers only that index which is greater than
the sum of the matched index of P; and p; — 1 (> 11+2-1 = 12).
Hence, the index will be 15. Finally, she computes the gaps between
sub-patterns and matches the wildcards between sub-patterns. In this
way, Alice finds her desired result using our protocol. Moreover, our
algorithm does not match a pattern like “CC*GT*GTGCT*T” with
given plaintext T though every sub-pattern exists in the plaintext. This
mismatch happens because all sub-patterns do not occur sequentially
in the text. Therefore, this algorithm accepts only sub-strings with
the same order as in the main string. Furthermore, this algorithm
determines only the single occurrence of the pattern P in the text T
to reduce the complexity of computation.
T.K. Saha et al.

Text =
X = Sub-Pattern Matches Index

| Index |0]1{ 2 [3/4] 5/6|7|8| 9/10] 11] 12/13] 14]15|

| Pattem | | [ G[t/G/c)t] - [cle] - |G] TI - | - | 7

 

Journal of Information Security and Applications 55 (2020) 102609

AAGTGCTGCCAGTCGT, Pattern = GTGCT*CC*GT*T

se J 2 a | 0] [ne

 

Sobpattern 1
Poe attern-2

| Subpattern-3 | attern-3

 

rsabeatene Catt DT te

Fig. 4. Table of computation for finding pattern matching results.

8. Secure computation of pattern matching with compound wild-
cards

For the sake of our computation in Eq. (26) over the encrypted text
T and the encrypted pattern P, we need to define another theorem
than Theorem 2 for the SPM-CW protocol as mentioned in Section 5.3.
By using Eq. (28), the packed ciphertexts of Poly,(T), Poly,(T?),
Poly,(Vjq)), Poly(P), Poly,(P*), and Poly,(P*) are obtained as cr,(T),
ct\(T*), cty(Vjyz)), ct2(P), ct,(P*), and ct,(P*) respectively.

Theorem 3. Under the condition Lemma 2, the linear combination of
homomorphic operations

ct) (Vir)) Kl ety (P*) BA ct, (1?) & cty(P) A (-2er, (T) & ct(P*))

simultaneously computes multiple values of Eq. (25) with the help of
Eq. (28) for0 < d < g-—8and1 <1 < y on the encrypted data,
where Vy, denotes the unit vector (1,1,...,1) of length |T|. Concretely, the
homomorphic operation in Eq. (32) gives a polynomial of R, in which the
coefficient of x®'*4 is equal to E,4 in Eq. (25) for each 0 < d < y—9 and
1 <1 <y onencrypted data.

(32)

Proof. We can prove this theorem, which is nearly similar to The-
orem 2. The inner product property in Eq. (22) and Proposition 2
show that each x?"*4-th peer of cty(Viny) XX ct,(P?) is equal to
the sum (p},p;.---»P_,) (1. =r 0 P;,, Where A’ denotes the
transpose of a vector A. Similarly, we can say that the homomorphic
multiplication of ct, (T*) Rct,(P) and (—2ct,(T) Rct,(P*)) computes two
polynomials on encrypted data with the x?'*4-th coefficient, which are
equal to >) 4 ayn’ Ph and —2 Dn Anat * PZ respectively for each
0<d<(g-9%) and 1 <: </y. Finally, we can say by the correctness
in Eq. (11), it proves that homomorphic operation in Eq. (32) produces
a polynomial of R, in which the coefficient x?'*4 is equal to E,q in
Eq. (25) for each 0 < d < (g— 8) and 1 <:<y onencrypted data. [J

Here we get each E,, as the coefficient of x?'t’ of the large
polynomial in Eq. (32). For our pattern matching, we constructed two
patterns P, and P, from the pattern P. In our SPM-CW protocol, Alice
will get two pattern matching results cf(A,) and ct(A,) for her two
queries P, and P, according to Eq. (32). Alice then decrypts the results
ct(A,) and ct(A,) using her key to obtain A, and A,. She uses Algorithm 2
to calculate the final result of pattern matching from the set difference
of two results obtained from A, and 4A).

8.1. Random masking

In our SPM-CW protocol, we have already used masking to sup-
press information leakage. Now we discuss the reasons for information
leakage and its countermeasure through masking as follows.

8.1.1. Information leakage problem

The information leakage problem may occur in our SPM-CW pro-
tocol if Bob sends the encrypted polynomial to Alice without any
masking after pattern matching computation. In this protocol, we use
the modified Euclidean distance-based pattern matching technique in
which a pattern can be found in the text if the distance between
them is “0”. Since we use the double-query technique as mentioned in
Section 5.1, Bob calculates A, and A, for matching the pattern P, and
P, with the text according to Eq. (32), which includes three polynomial

14

multiplications and two additions. According to Eq. (32), Bob produces
two large polynomials ct(A,) and ct(A,) which are sent to Alice for
decryption to decide pattern matching. According to inner product
property in Eq. (22), Alice needs a sub-polynomial to get the result
as the coefficients of x?"*?. Therefore, Alice can get more information
than she requires for the pattern matching if Bob does not use masking.

8.1.2. Countermeasure

To provide additional security due to the information leakage as
mentioned in Section 8.1.1, we used the technique of random vec-
tor multiplication of Section 7.3.2 using CRT packing that is already
mentioned in our SPM-CW protocol.

Remark 4. To achieve efficiency, we follow the semi-honest model for
our protocols. To get maliciously secure protocols, we can convert them
using existing compilers [33,34] which will cause a certain cutback in
their performances.

9. Performance analysis

We discuss the performances of the SPM-RW and SPM-CW protocols
along with their security in the following subsections.

9.1. Security weaknesses and countermeasures

Here we show the probable security weaknesses of our protocols
and their possible countermeasures.

9.1.1. Security weaknesses

We have already said that our protocols are secure in the semi-
honest model. Here we mean that Bob tries to learn information from
the protocols but follows the protocols. We consider two weaknesses
for our protocols. Firstly, in the asymmetric versions of the SPM-RW
and SPM-CW protocols, Charlie cannot disclose his data to Alice but
sends his data to Bob using Alice’s public-key. Moreover, Bob being
a semi-honest party can collude with Alice to bypass the computation
of the SPM to Alice. Now, both Alice and Bob can be benefited from
the collusion. For instance, Bob can save its computing power, and
Alice can get access to the data that she has no permission to access.
Secondly, our protocols are unable to prevent the more real-world
attacks by the malicious adversaries because we follow the semi-honest
model for protocols’ security.

9.1.2. Countermeasures against the weaknesses

To solve the first weakness, we can add a trusted third party (TTP)
as a service provider with our asymmetric protocol scenario. Further-
more, TTP in our protocol will be responsible to generate keys, provide
the keys to Alice and Bob, decrypt the results after computation by Bob,
and send the results to Alice. Here Charlie and Bob will have the same
role, but Alice will lose his power of key generation and decryption.
After the addition of TTP in our protocols, Bob tries to collude with
Alice but fails because Alice has no secret key to decrypt Charlie’s data.
To solve the second weakness, we can convert the protocols to become
maliciously secure using some existing compilers [33,34]. In the second
case, we need to compromise the performances of the protocols due to
adding malicious security to them.
T.K. Saha et al.

Table 1
Performance comparison for SPM-RW protocols.
Encryption Parameters Yasuda et Our
type al.’s method
method [6]
Both No. of homomorphic 3k 3
multiplications
Cost of homomorphic OBK[1/n] - OB([1/n] -
multiplication [|P|/n])) [|P|/n]))
Symmetric Communication complexity O(kKC, + C,) O(C, + Cy)
Public-Key Communication complexity O(kC, + C3) O(C, + C3)

n = lattice dimension;

|P| = total length of sub-patterns, k = number of sub-patterns in a query.

C,; = communication cost for each query and its answer between Alice and Bob.
C, = communication cost for sending the text from Alice to Bob.

C; = communication cost for sending the text from Charlie to Bob.

9.2. Theoretical evaluation

To present the efficiency of our packing method, we evaluate the
performance of the SPM-RW protocols theoretically, which are shown
in Table 1. Let us consider a performance parameter “number of homo-
morphic multiplications” due to cryptographic perspective and “cost of
homomorphic multiplication” to differentiate our method and Yasuda
et al.’s method [6] to calculate pattern matching for our protocols.
Moreover, recall the same text T and pattern P with k sub-patterns.
In addition, let C; be the communication cost for each query and its
answer between Alice and Bob. Furthermore, C, defines the commu-
nication cost for sending the text from Alice to Bob for the SPM-RW
protocol using symmetric encryption. Also, C3; defines the communi-
cation cost for sending the text from Charlie to Bob for the SPM-RW
protocol using the public-key encryption. Now we compare our method
and the method in [6] to evaluate the SPM-RW protocols with the
symmetric and public-key encryption as shown in Table 1. Now we
show the comparison between Yasuda et al.’s method [6] and our
method regarding the cost of homomorphic multiplications and the
communication complexity to solve the SPM-RW problem. For both
symmetric and public-key case, the cost of homomorphic multiplication
using Yasuda et al.’s method is O(3k([1/n]-[|P|/n])), whereas the cost of
homomorphic multiplication using our method is O(3([1/n] - [|P|/n])).
In case of symmetric SPM-RW protocol, the communication complexity
of Yasuda et al.’s method is O(kKC, + C,), whereas the communication
complexity of our method is O(C; + C,). In case of public-key SPM-RW
protocol, the communication complexity of Yasuda et al.’s method is
O(kC, + C3), whereas the communication complexity of our method is
O(C,+C;). As a result, we have been able to reduce the communication
complexity of [6] by a factor near about k. Due to using our packing
method, we have been able to handle k sub-patterns in three multipli-
cations instead of 3k multiplications if we follow the method in [6].
Therefore, a simplification of multiplication is done here.

Besides, we show the functional difference between the SPM-RW
protocol and Yasuda et al.’s protocol [6] as shown in Table 2. Here
the pattern in our SPM-RW protocols contains repetitive wildcards,
whereas pattern in Yasuda et al.’s protocol contains a single wildcard.
Furthermore, a wildcard in the pattern replaces with one letter in the
text using Yasuda et al.’s protocol [6], whereas the same replaces with
zero or many letters in the text using our protocols as shown in Table 2.
Moreover, our protocols suppress the information leakage, which is
absent in Yasuda et al.’s protocol [6].

Remark 5. We observed that our method has a computation over-
head of doing large polynomial multiplication of dimension n, whereas
we require a sub-polynomial of the multiplication result to find the
required inner products according to Eq. (22). The overhead is unavoid-
able in our method due to using polynomial ring-based SwHE for the
protocols’ security.

15

Journal of Information Security and Applications 55 (2020) 102609

Table 2
Functional difference between SPM-RW protocols and Yasuda et al.’s protocol [6].

Yasuda et al.’s SPM-RW protocols

protocol [6]

Parameters

Nature of pattern
Text replacing behavior by a wildcard
Information leakage

Single wildcard Repetitive wildcards
One letter Zero or many letters
Yes No

9.3. Security level

Before we estimate the values of the parameters, we consider the
security of our schemes from decoding attack [35] and distinguishing
attack [36]. According to Lindner and Peikert [35], we consider every
parameter setting to provide more than 80-bit security level to secure
our protocols against the distinguishing attack and more powerful
decoding attack in which the adversarial advantage « = 2-*+. In ad-
dition, Chen and Nguyen [37] estimated in lattice-based cryptographic
schemes that it is required to have the root Hermite factor 6 < 1.0050 to
achieve an 80-bit security level. As discussed in [21], the running time
tady 1S defined as log(t,,,) = 1.8/log(6) — 110 in which the root Hermite
factor 6 is expressed as c - g/o = 27V™ 1084) log) |

9.4. Parameter settings

Here we provide the parameter settings of the SPM-RW protocols
for searching DNA sequences and the SPM-CW protocol for processing
PDBOQ.

9.4.1. Secure pattern matching with repetitive wildcards

In our SPM-RW protocols, we set the parameters (n,q,t,o,k) to
perform the experiments. We encoded the DNA alphabet » = {A,G,C, T}
as » = {1,2,3,4} for simplifying our pattern matching computation.
For our experiments, we implemented the SPM-RW protocols using our
method and Yasuda et al.’s methods [6] in C programming language
with Pari C library (version 2.7.5) [38] and ran on a computer with
Intel® Core i7-4790 CPU with 3.60 GHz and 8 GB RAM. We compiled
our C code using gcc 5.4.0 in Linux environment.

As mentioned in Section 4.2.4, since n > (k + 1)/ and degree of
second polynomial of our packing method increases with the increase
of /, we perform our experiments by setting the value of n and / as
small as possible to achieve a better performance than the existing
method. Moreover, we found in [2] that the value of n should be
at least 2048 to make the encryption secure. Then we consider n =
2048 for all experiments to achieve more than 80-bit security level
for the experiments to protect our protocols from some distinguishing
attacks. We also keep same lattice dimension for the experiments using
Yasuda et al.’s method [6]. We have chosen the values of our required
parameters (q, t,o, k) carefully to comply with our method. We set o = 8
and vary other parameters (t,q,k) for our experimental evaluations of
symmetric and public-key case.

In the symmetric case, according to work in [6], the value of 1
should satisfy t > 28n to avoid carry operation since the SED requires
two additions as mentioned in Eq. (29). Moreover, g > 2!!nto = 2!!.2!!.
2!9.23 = 2™ for the ciphertext space R,. Therefore, we set q = 45 bits
for the results shown in Table 3. In the public-key case, we set t = 2048
and q > 16n7t?7o4 = 27.27% .272.2!? = 2% according to work in [2].
Therefore, we set g = 61 bits for the results shown in Table 4.

To evaluate the SPM-RW protocols, we considered several texts of
the lengths from 128 to 512. For / = 512, we took 2 (resp., 3) sub-
patterns of length 6 (resp., 9) characters. Moreover, we took 5 (resp.,
7) sub-patterns of length 15 (resp., 21) characters for / = 256. Also, we
took 11 (resp., 15) sub-patterns of length 33 (resp., 45) characters for
/ = 128. Furthermore, we limit the value of / from 128 to 512 to keep
the lattice dimension n = 2048 to realize the benefits of our scheme. In
addition, we believe that high lattice dimension and more text length
can be supported if the experiments are conducted in real cloud server
where the ciphertext sending cost through a network is more realized.
T.K. Saha et al.

Table 3

Journal of Information Security and Applications 55 (2020) 102609

Experimental comparison for symmetric SPM-RW protocol.

Text length No. of Pattern Total time (ms*) Time of Hom.Op.” (ms*) Improvement Security level
(1) sub-patterns (k) length |P| factor (Hom.Op.”) — log(t 4,,)
Yasuda et al.’s method [6] Our method Yasuda et al.’s method [6] Our method

512 2 6 125 62 110 60 1.83

3 204 78 141 63 2.24

5 15 203 46 170 31 5.48

2

256 7 21 312 47 210 31 6.77 34
128 11 33 328 31 235 31 7.98

15 45 453 31 297 31 9.58

4ms: milliseconds.

bHom.Op: Homomorphic operations.

9.4.2. Secure pattern matching with compound wildcards

We set (n,t,g,0) = (2048, 262144, 75 bits, 8) for the experiments of
processing PDBQ regarding the SPM-CW protocol. Moreover, we used
the encoding of input alphabet = {a — z} as the integers in Z—{0} and
the wildcard “$” is encoded as zero. Here we implemented our protocol
in C++ programming language using Pari C library (version 2.9.1) [38]
and ran on a computer with Intel® Core i5-4590 CPU@3.30 GHz and
4 GB RAM in Linux environment.

9.5. Experiments

Here we show the experimental results regarding the SPM-RW
protocols for searching DNA sequences and the SPM-CW protocol for
processing PDBQ.

9.5.1. Results of secure pattern matching with repetitive wildcards

In the settings mentioned earlier, we implemented both of our
protocols using our method and Yasuda et al.’s method [6] to solve
the SPM-RW problem and compare their performances as shown in
Tables 3 and 4. Here we computed the total time for both methods in
milliseconds (ms) required by the protocols including key generation,
encryption, query transmission, pattern matching, result transmission,
and decryption. In addition, we show the time of homomorphic oper-
ations in milliseconds, that is required by Bob in the cloud for both
protocols. Furthermore, we considered six different settings (/,k) for
the experiments of both protocols such that they satisfy n > (k + 1)/.
We demonstrate the comparative experimental results of the SPM-RW
protocol using the symmetric encryption in Table 3. When we set / =
512, k = 2, and |P| = 6, our method took about 62 ms (60 ms for
homomorphic operations), whereas the method of Yasuda et al. took
125 ms (110 ms for homomorphic operations) for total pattern match-
ing. In addition, our method took about 78 ms (63 ms for homomorphic
operations), whereas the method of Yasuda et al. took 204 ms (141 ms
for homomorphic operations) for pattern matching with the settings / =
512, k =3, and |P| = 9. Moreover, we present the experimental results
for the settings (J = 256,k = 5,|P| = 15), (J = 256,k = 7,|P| = 21),
(J = 128,k = 11,|P| = 33), and (J = 128,k = 15,|P| = 45) in Table 3.
For every setting, we show the performance improvement factors of
the homomorphic operations between our method and Yasuda et al.’s
method. Improvement factors are 1.83, 2.24, 5.48, 6.77, 7.58, and
9.58 when the values of k are 2, 3, 5, 7, 11, and 15 respectively.
We observe that the factors are mostly near about k highlighted by
boldface column in Table 3 except the cases k > 10. Therefore, our
method is about k times faster than that of Yasuda et al. [6] for
performing homomorphic operations. For our protocol, we measured
the timings of pattern encryption, key generation, and decryption at
the client which are very small (sometimes ~ 0 ms) as compared to
pattern matching time of our method. Consequently, we do not mention
the timings separately in our experimental results. Furthermore, we
need to achieve more than 80-bit security for protecting the protocols
from some distinguishing attacks. As shown in Table 3, we achieve the
security level of 234 bits for our parameter settings and root Hermite

16

factor 6 = 1.00363 < 1.0050. Therefore, our settings are able to provide
security from some distinguishing attacks.

In Table 4, we show the comparative results of the SPM-RW protocol
using the public-key encryption. The total time taken by Yasuda et al.’s
method [6] was 126 ms (62 ms for homomorphic operations), whereas
our method took only 78 ms (31 ms for homomorphic operations) to
match 2 sub-patterns of length 6 with our text length 512 as shown
in Table 4. For the settings / = 512, k = 3, and |P| = 9, the method
of Yasuda et al. took 187 ms (95 ms for homomorphic operations),
whereas our method took 78 ms (31 ms for homomorphic operations).
In addition, we show more results for the settings (J = 256,k =
5,|P| = 15), (7 = 256,k = 7,|P] = 21), (J = 128,k = 11,|P| = 33),
and (J = 128,k = 15,|P| = 45) in Table 4. For every setting, the
performance improvement factor of homomorphic operations is shown
by the boldface column in Table 4. Improvement factors are 2, 3.06,
4.55, 6.88, 10.58, and 12.66 when the values of k are set to 2, 3,
5, 7, 11, and 15 respectively. It is easy to see that the factors are
mostly near around k. Therefore, our method is near about k times as
fast as the method of Yasuda et al. [6] for performing homomorphic
operations. As shown in Table 4, we achieve the security level of 140
bits for our different parameter settings along with root Hermite factor
6 = 1.00498 < 1.0050. As a result, our protocol is safe from some
distinguishing attacks. For this protocol, we measured the encryption
time of text which varies between 15 and 16 ms. Here we also measured
the times taken by key generation and decryption for every parameter
setting of our method which are near about 0 ms for most of the cases,
that is not mentioned in experimental results.

Remark 6. We observe that both of our SPM-RW protocols are near
about k-times as fast as the method in [6] for performing homomorphic
operations. In addition, our code is not fully optimized, and the system
has a low configuration as compared to a current high-performance ma-
chine. Consequently, an optimized code running on a highly configured
machine can produce better results than our results.

9.5.2. Results of secure pattern matching with compound wildcards

To evaluate the SPM-CW protocol, we compare our results with
that Kim et al. [5] for processing PDBQ with compound wildcards. We
took the same database settings as Kim et al. took. Here we match
a single pattern of length 10 with compound wildcards with a set of
texts. Therefore, we made three datasets of size 51, 40, and 32 in
which the length of each text is 35, 45, and 55 bytes respectively. The
performances of the SPM-CW protocol for PDBQ processing are shown
in Table 5. For instance, to find a pattern with compound wildcards in
the 51 texts of length 35 bytes each, we required 2.590 s, whereas Kim
et al. took 100.91 s for doing the same pattern matching. Furthermore,
to handle a data set of 40 texts with 45 bytes each, our method required
2.605 s, whereas Kim et al. required 120.96 s for the same pattern
matching with the same settings. Also, to process a data set of 32 texts
with 55 bytes each, our method required 2.605 s, whereas Kim et al.
required 153.21 s for the same settings. Besides, we show amortized
T.K. Saha et al.

Table 4
Experimental comparison for public-key SPM-RW protocol.

Journal of Information Security and Applications 55 (2020) 102609

Text length No. of Pattern Total time (ms*) Time of Hom.Op.° (ms*) Improvement Security level
(/) sub-patterns (k) length |P| factor (Hom.Op.”) — log(t 4,,)
Yasuda et al.’s method [6] Our method Yasuda et al.’s method [6] Our method

512 2 6 126 78 62 31 2.00

3 9 187 78 95 31 3.06

5 15 297 62 141 31 4.55

1

256 7 21 407 63 220 32 6.88 40
128 11 33 641 62 328 31 10.58

15 45 860 62 405 32 12.66

@ms: milliseconds.
bHom.Op: Homomorphic operations.

Table 5

Experimental comparison for public-key SPM-CW protocol for processing PDBQ.

Total time (s)
Kim et al. [5]?

String length (Bytes) Number of string

35 51 100.91 2.590
45 40 120.96 2.605
55 32 153.21 2.605

Our method?

Amortized time (s) Security level

Kim et al. [5]? Our method> Kim et al. [5] Our method
1.98 0.051

3.02 0.065 83-bit 92-bit

4.78 0.081

@Experiment platform: a local server equipped with Intel® Xeon E5-2620 CPU@2.40 GHz with 24 threads and 64 GB RAM.
>Experiment platform: a desktop with Intel® Core i5-4590 CPU@3.30 GHz and 4 GB RAM.

time’ for the comparison. For our three settings as mentioned earlier,
the amortized time of our method is as low as 0.051 s and as high as
0.081 s for the SPM-CW protocol, whereas the amortized time of the
method of Kim et al. required as low as 1.98 s and as high as 4.78 s
for the pattern matching. In addition, we achieve a better security level
of 92 bits than that of Kim et al. of 83 bits as shown in Table 5. From
these performances, it is obvious that our method is practical to solve
the SPM-CW problem.?

10. Conclusions

In this paper, we have discussed two problems of pattern matching:
the SPM-RW problem and the SPM-CW problem. For the SPM-RW prob-
lem, we propose two efficient protocols using symmetric and public-key
SWHE respectively in the semi-honest model and a packing method to
achieve the efficiency of the two protocols. In addition, we applied
our packing method in pattern matching to non-binary vectors. The
packing method is also applicable to a binary vector with multiple
queries. Here our packing method enables us to perform homomor-
phic multiplications about k times faster than that in [6]. Through
our protocols, we have been able to show the repetitive-wildcards
pattern matching in a precise manner than [6]. For the SPM-CW
problem, we propose another efficient protocol using the double-query
technique with public-key SwHE in the semi-honest model. For the
SPM-CW protocol, our experiments for the PDBQ processing exhibit
the performances that are practically usable. Furthermore, our packing
method is not only applicable to the SPM but also applicable to other
secure computation fields. We surmise that our experimental results
and packing method will inspire future researchers to perform the
large polynomial computation in a few multiplications. In addition,
we consider only three types of wildcard symbols “$”, “*”, and “!”
for our pattern matching. If we want to support other symbols, it will
increase time complexity of the method. There is a scope to improve our

2 Amortized time is defined by the time required for a single pattern
matching per record in the database.

3 Here we compare the two performances in dissimilar configuration of two
PCs between two experiments, in which our PC has lower configuration than
that of Kim et al. [5] (See Table 5 for the details). Their test platform is a
local server with LAN and all the algorithms are performed on the server [39].
Moreover, they did not consider the time required to send ciphertexts through
a network [39] similar to our experiments.

17

technique of the SPM-RW protocols in large settings, whereas we have
shown our experimental in small settings. Note that our protocols do
not provide security against malicious adversaries dealt with the more
real-world scenario, which we keep as our future work.

CRediT authorship contribution statement

Tushar Kanti Saha: Conceptualization, Methodology, Software,
Formal analysis, Investigation, Resources, Data curation, Validation,
Writing - original draft, Visualization. Deevashwer Rathee: Software,
Formal analysis, Investigation, Data curation. Takeshi Koshiba: Su-
pervision, Writing - review & editing, Project administration, Funding
acquisition.

Declaration of competing interest

The authors declare that they have no known competing finan-
cial interests or personal relationships that could have appeared to
influence the work reported in this paper.

Acknowledgments

This work is supported in part by JSPS Grant-in-Aids for Scientific
Research (A) JP16HO01705 and for Scientific Research (B) JP17H01695.
The authors would like to thank Masaya Yasuda and many anonymous
reviewers for their helpful comments which helps us to improve the
presentation of the paper.

References

[1] Clancy TC, Kiyavash N, Lin DJ. Secure smartcard based fingerprint authentica-
tion. In: Proceedings of the 2003 ACM SIGMM workshop on biometrics methods
and applications. ACM Press; 2003, p. 45-52.

Yasuda M, Shimoyama T, Kogure J, Yokoyama K, Koshiba T. Secure pattern
matching using somewhat homomorphic encryption. In: ACM workshop on cloud
computing security workshop, CCSW 2013. ACM Press; 2013, p. 65-76.
Troncoso-Pastoriza JR, Katzenbeisser S, Celik M. Privacy preserving error re-
silient DNA searching through oblivious automata. In: Proceedings of the 14th
ACM conference on computer and communications security. ACM Press; 2007,
p. 519-28.

Defrawy EK, Faber S. Blindfolded Data Search via Secure Pattern Matching.
Computer 2013;46(12):68-75, IEEE.

Kim M, Lee HT, Ling S, Tan BHM, Wang H. Private compound wildcard queries
using fully homomorphic encryption. IEEE Trans Dependable Secure Comput
2017;16(5):743-56. http://dx.doi.org/10.1109/TDSC.2017.2763593.

[2]

[3]

[4]

[5]
T.K. Saha et al.

[6]

[7]

[8]

[9]

[10]

[11]

[12]

[13]

[14]

[15]

[16]

[17]

[18]

[19]

[20]

[21]

[22]

Yasuda M, Shimoyama T, Kogure J, Yokoyama K, Koshiba T. Privacy-preserving
wildcards pattern matching using symmetric somewhat homomorphic encryption.
In: Susilo W, Mu Y, editors. ACISP 2014. LNCS, vol. 5844, Switzerland: Springer;
2014, p. 338-53.

Baron J, Defrawy EK, Minkovich K, Ostrovsky R, Tressler E. 5pm: Secure pattern
matching. In: Security and cryptography for networks 2012. LNCS, vol. 7485,
Heidelberg: Springer; 2012, p. 222-40.

Blanton M, Aliasgari M. Secure outsourcing of DNA searching via finite automata.
In: Foresti S, Jajodia S, editors. Data and applications security XXIV. LNCS, vol.
6166, Heidelberg: Springer; 2010, p. 49-64.

Hazay C, Toft T. Computationally secure pattern matching in the presence of
malicious adversaries. J Cryptol 2014;27(2):358-95.

Frikken KB. Practical private DNA string searching and matching through
efficient oblivious automata evaluation. In: Data and applications security 2009.
LNCS, vol. 5645, Heidelberg: Springer; 2009, p. 81-94.
Chase M, Shen E. Substring-searchable symmetric
2015;2015(2):263-81.

Faber S, Jarecki S, Krawczyk H, Nguyen Q, Rosu M, Steiner M. Rich queries on
encrypted data: Beyond exact matches. In: European symposium on research in
computer security —-ESORICS 2015 part II. LNCS, vol. 9327, Cham: Springer;
2015, p. 123-45.

Goldwasser S, Micali S. Probabilistic encryption & how to play mental poker
keeping secret all partial information. In: Proceedings of the fourteenth annual
ACM symposium on theory of computing. ACM Press; 1982, p. 365-77.
ElGamal T. A public key cryptosystem and a signature scheme based on discrete
logarithms. In: Advances in cryptology, vol. 196, Heidelberg: Springer; 1985, p.
10-8.

Cohen JD, Fischer MJ. A robust and verifiable cryptographically secure election
scheme. In: 26th annual symposium on foundations of computer science, 1985.
IEEE; 1985, p. 372-82.

Paillier P. Public-key cryptosystems based on composite degree residuos-
ity classes. In: Advances in cryptology—-EUROCRYPT’99. LNCS, vol. 1592,
Heidelberg: Springer; 1999, p. 223-38.

Boneh D, Goh EJ, Nissim K. Evaluating 2-DNF formulas on ciphertexts. In: Theory
of cryptography—TCC 2005. LCNS, vol. 3378, Springer; 2005, p. 325-41.
Gentry C. Fully homomorphic encryption using ideal lattices. In: Symposium on
theory of computing — STOC 2009. ACM Press; 2009, p. 169-78.

Hu Y. Improving the efficiency of homomorphic encryption schemes (PhD diss.),
Worcester Polytechnic Institute, Massachusetts; 2013.

Brakerski Z, Vaikuntanathan V. Fully homomorphic encryption from Ring-LWE
and security for key dependent messages. In: Rogaway P, editor. CRYPTO 2011.
LNCS, vol. 6841, Heidelberg: Springer; 2011, p. 505-24.

Lauter K, Naehrig M, Vaikuntanathan V. Can homomorphic encryption be
practical?. In: ACM workshop on cloud computing security workshop, CCSW
2011. ACM Press; 2011, p. 113-24.

Yasuda M, Shimoyama T, Kogure J, Yokoyama K, Koshiba T. Secure statistical
analysis using RLWE-based homomorphic encryption. In: Information security
and privacy. Switzerland: Springer; 2015, p. 471-87.

encryption. PoPETs

18

[23]

[24]

[25]

[26]

[27]

[28]

[29]

[30]

[31]

[32]

[33]

[34]

[35]

[36]

[37]

[38]

[39]

Journal of Information Security and Applications 55 (2020) 102609

Saha TK, Koshiba T. Outsourcing private equality tests to the cloud. J Inf Secur
Appl 2018;43:83-98.

Saha TK, Koshiba T. An enhancement of privacy-preserving wildcards pattern
matching. In: F. Cuppens, Wang L, Cuppens-Boulahia N, Tawbi N, Garcia-
Alfaro J, editors. Foundations and practice of security. FPS 2016. LNCS, vol.
10128, Cham: Springer; 2017, p. 145-60.

Yao AC. Protocols for secure computations. In: 23rd annual symposium on
foundations of computer science. IEEE; 1982, p. 160-4.

Jha S, Kruger L, Shmatikov V. Towards practical privacy for genomic
computation. In: IEEE symposium on security and privacy. IEEE; 2008, p.
216-30.

Katz J, Malka L. Secure text processing with applications to Private DNA
Matching. In: Proceedings of the 17th ACM conference on computer and
communications security. ACM Press; 2010, p. 485-92.

Beck M, Kerschbaum F. Approximate two-party privacy-preserving string match-
ing with linear complexity. In: IEEE international congress on big data. IEEE;
2013, p. 31-7.

Lyubashevsky V, Peikert C, Regev O. On ideal lattices and learning with errors
over rings. In: Gilbert H, editor. EUROCRYPT 2010. LNCS, vol. 6110, Heidelberg:
Springer; 2010, p. 1-23.

Yasuda M, Shimoyama T, Kogure J, Yokoyama K, Koshiba T. Practical packing
method in somewhat homomorphic encryption. In: DPM 2013 and SETOP 2013.
LNCS, vol. 8247, Heidelberg: Springer; 2014, p. 34-50.

Smart NP, Vercauteren F. Fully Homomorphic SIMD operations. Des Codes
Cryptogr 2014;71(1):57-81. http://dx.doi.org/10.1007/s10623-012-9720-4.
Rivest RL, Adleman L, Dertouzos ML. On data banks and privacy homomorphism.
In: Foundations of secure computation. Academia Press; 1978, p. 169-77.
Goldreich O, Micali S, Wigderson A. How to play any mental game. In:
Proceedings of the nineteenth annual ACM symposium on theory of computing.
ACM Press; 1987, p. 218-29.

Ishai Y, Prabhakaran M, Sahai A. Founding cryptography on oblivious transfer
- efficiently. In: Advances in cryptology - CRYPTO 2008. CRYPTO 2008. LNCS,
vol. 5157, Heidelberg: Springer; 2008, p. 572-91.

Lindner R, Peikert C. Better key sizes (and attacks) for LWE-based encryption.
In: Topics in cryptology — CT-RSA 2011, vol. 6558, Heidelberg: Springer; 2011,
p. 319-39.

Micciancio D, Regev O. Lattice-based cryptography. In: Post-quantum cryptogra-
phy. Heidelberg: Springer; 2009, p. 147-91.

Chen Y, Nguyen PQ. BKZ 2.0: Better lattice security estimates. In: Advances in
cryptology — ASIACRYPT 2011. LNCS, vol. 7073, Heidelberg: Springer; 2011,
p. 1-20.

PARI/GP version 291. The PARI Group; Univ. Bordeaux. 2018, Available from
http://pari.math.u-bordeaux.fr/.

Tan BHM. Private communication.
