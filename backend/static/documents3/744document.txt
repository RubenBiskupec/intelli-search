Sun et al. Cybersecurity (2020) 3:12
https://doi.org/10.1186/s42400-020-00054-6

Cybersecurity

RESEARCH Open Access

Server-aided immediate and robust user
revocation mechanism for SM9

Check for
updates

 

Shuzhou Sun!?, Hui Mal”, Rui Zhang!? and Wenhan Xu!

Abstract

As the only approved Identity-Based Encryption scheme in China that is also standardized by ISO, SM9-IBE has been
widely adopted in many real-world applications. However, similar to other IBE standard algorithms, SM9-IBE currently
lacks revocation mechanism, which is vital for a real system. Worse still, we find that existing revocable techniques
may not be suitable and efficient when applying to SM9-IBE. Given the widespread use of SM9-IBE, an efficient and
robust user revocation mechanism becomes an urgent issue.

In this work, we propose a dedicated server-aided revocation mechanism, which for the first time achieves the secure,
immediate and robust user revocation for SM9-IBE. Provided with a compact system model, the proposed method

leverages an existing server to perform all heavy workloads during user revocation, thus leaving no communication
and computation costs for the key generation center and users. Moreover, the mechanism supports key-exposure
resistance, meaning the user revocation mechanism is robust even if the revocation key leaks. We then formally define
and prove the security. At last, we present theoretical comparisons and an implementation in terms of computational
latency and throughput. The results indicate the efficiency and practicability of the proposed mechanism.

Keywords: Identity-based encryption, SM9, Server-aided immediate and robust revocation, Chinese cryptography

standard, Security proof, Performance evaluation

Introduction
Identity-Based Encryption (IBE) is a special kind of pub-
lic key encryption, where a user utilizes a unique string
(e.g., an email address or a phone number) as the pub-
lic key. Data senders do not have to obtain receivers’
public key certificates, thus eliminating the Public Key
Infrastructure (PKI). In the past decades, IBE has been
thoroughly studied and many practical IBE schemes have
been proposed, e.g., (Boneh and Franklin 2001; Cocks
2001; Canetti et al. 2004; Boneh and Boyen 2004a; 2004b;
Waters 2005). Further, some of the proposed schemes
were standardized in a number of globally recognized
standards (Boyen and Martin 2007; Martin et al. 2009;
Martin and Schertler 2009; IEEE 2013; Iso/iec 2015).

SM9 (Gm/t 2016a) is a Chinese national cryptography
standard for Identity-Based Cryptography, which consists

 

*Correspondence: mahui@iie.ac.cn

'State Key Laboratory of Information Security, Institute of Information
Engineering, Chinese Academy of Sciences, Beijing 100093, China
Full list of author information is available at the end of the article

o) Springer Open

 

of 3 cryptographic primitives: a digital signature scheme,
a key agreement scheme and an encryption scheme. The
SM9 encryption scheme (denoted as SM9-IBE) is also
standardized in ISO 18033-5 (Iso/iec 2015). After its stan-
dardization, SM9-IBE has been extensively applied in
many scenarios, including encrypted emails, electronic
government systems and commercial products.

Though SM9-IBE is proposed as a standard algorithm,
it does not specify any user revocation mechanisms in
the standards (Iso/iec 2015) and (Gm/t 2016a). However,
since SM9-IBE is practice-oriented, it is desirable to deal
with the realistic problem of user revocation. On the
other hand, although a large body of the previous work
(Boldyreva et al. 2008; Libert and Vergnaud 2009; Seo
and Emura 2013; Li et al. 2013; Qin et al. 2015; Ge and
Wei 2019) has been done for efficient IBE user revoca-
tion, all these known techniques are not generic, namely,
they cannot be applied to SM9-IBE. The major technical

© The Author(s). 2020 Open Access This article is licensed under a Creative Commons Attribution 4.0 International License, which
permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit
to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The

images or other third party material in this article are included in the article’s Creative Commons licence, unless indicated
otherwise in a credit line to the material. If material is not included in the article’s Creative Commons licence and your intended
use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the
copyright holder. To view a copy of this licence, visit http://creativecommons.org/licenses/by/4.0/.
Sun et al. Cybersecurity (2020) 3:12

challenge is that SM9-IBE has a different mathemati-
cal structure compared with the existing revocable IBE
schemes, which were construed with certain IBE schemes
and relied on their concrete mathematical structures, thus
adopting these solutions will face with the difficulties in
both the construction and the security proof.

As a result, the problem of efficient SM9-IBE user
revocation is still open. As a national and international
standard for IBE, it is desirable to have a practical user
revocation mechanism for SM9-IBE.

Our Contributions. Aiming at solving the revocation
problem of SM9-IBE, we propose a dedicated Server-
Aided Immediate and Robust Revocable Identity-Based
Encryption scheme (denoted as SA-IR-RIBE), which
can be effortlessly integrated into the existing systems.
Remarkably, our methodology achieves direct user revo-
cation by performing simple operations in the server. Our
results lie in the following aspects:

e A Compact System with Revocation. In this paper,
we present a practical revocation mechanism for
SM9-IBE. To the best of our knowledge, this is the
first specific solution to the revocation problem for
SM9-IBE. By introducing a helping server, the
proposed mechanism has a compact system model
and does not introduce additional entities. The heavy
workloads of user revocation are all performed by the
server, leaving no communication and computation
costs for both the key generation center (KGC) and
users.

e Efficient and Immediate Revocation. Unlike most
of the existing revocable IBE schemes, our scheme
enjoys instant revocation, in the sense that a user
cannot decrypt ciphertexts at the same moment
when he is revoked. In our scheme, all ciphertexts
have to be partially decrypted by the server before it
is decrypted by a user. Therefore, a user can be
immediately revoked from the system by taking
simple operations on the server side.

e Server Side Key-Exposure Resistance. In an
ordinary scheme, once the server secret key is
revealed, the revocation mechanism no longer works.
Our mechanism achieves robustness for such
key-exposure: Even if the server secret key is leaked, a
revoked user still cannot decrypt any data. In
particular, the server secret key and ciphertexts are
updated periodically or in emergency situations, e.g.
when the server secret key is stolen by hackers.

e Provable Security. The proposed scheme does not
affect the security of SM9-IBE, which is provably
secure against adaptive-ID Chosen Ciphertext
Attacks. Furthermore, for the security of revocation,
we formally define a concrete security property called

Page 2 of 13

user revocation validity where a revoked user cannot
decrypt any ciphertexts without the help of the server.
e Performance Evaluation. We conduct theoretical
comparison between the proposed mechanism and
related works, showing the advantage and efficiency
of SA-IR-RIBE. Moreover, we present comprehensive
experimental evaluations by implementing the
proposed mechanism. We benchmark our
implementations on a high concurrency scenario,
where tens of thousands users upload and download
data from the server simultaneously. The obtained
results indicate that the proposed mechanism is
practical for real-world application scenarios.

Limitation. The proposed method deals with the prob-
lem of user revocation. It does not directly support key
revocation. However, key revocation can be achieved in
the cost of changing identities. Specifically, in our system,
when a user lost his key, he/she informs the key genera-
tion center to revoke his/her key and applies for a new key
under a new identity.

Related work

Numerous revocation techniques have been developed in
the IBE setting. In this section, we review some existing
solutions and identify the problems when they are applied
to SM9-IBE.

Generic Time-Concatenated Solution. The first revo-
cable IBE scheme is proposed by Boneh and Franklin
(2001) (BF-IBE). At each time period t, KGC issues secret
keys SKjp,|jt to all non-revoked users for identities ID;||t.
The data owners encrypt messages under the new con-
catenated identities ID;||t. Thus, if a user is revoked in time
period t, he/she cannot access the messages encrypted
in t. However, this mechanism does not scale well, since
KGC must re-generate a large number of secret keys and
re-distribute them to users at the beginning of each time
period. The complexity of KGC is linear in the number of
non-revoked users.

Tree-Based Solutions. Boldyreva, Goyal and Kumar
(2008) (BGK-RIBE) gave their security notion for revo-
cable IBE (RIBE), and constructed an efficient revocable
IBE scheme from the fuzzy IBE scheme (Sahai and Waters
2005) with binary tree structure (Naor et al. 2001) in the
selective-ID security model. In the BGK method, each
user has a tuple of long term secret keys. KGC publicly
broadcasts a small set of key updates in each time period,
so that only non-revoked users can construct new decryp-
tion keys from their long term secret keys and the key
updates. BGK-RIBE significantly reduces the total size
of key updates from linear to logarithmic in the num-
ber of non-revoked users. Following work by Libert and
Vergnaud (2009) proposed an adaptive secure revocable
IBE scheme based on the variant of Waters IBE (Waters
Sun et al. Cybersecurity (2020) 3:12

2005) and Gentry IBE (Gentry 2006). Recently, Seo and
Emura (2013) revisited the security notation of RIBE by
presenting the decryption key exposure attack, and pro-
posed a notable scheme based on Libert and Vergnaud
(2009). However, above approaches have two limitations:
(1) all non-revoked users have to download public key
updates from KGC periodically; and (2) the sizes of both
users’ secret keys and public key updates grow logarithmi-
cally in the number of non-revoked users.

Server-Aided Solutions. Several works adopted a third
party to achieve revocation in the IBE setting. Boneh et al.
(2001); Libert and Quisquater (2003) employed a trusted
party called mediator that holds all users’ secret keys and
helps users to decrypt all ciphertexts. Ifa user is revoked,
the mediator stops helping the user. This model is imprac-
tical since users have to fully trust the mediator and they
need to communicate with it for each decryption. The
work (Li et al. 2013) showed how to outsource workload
of the KGC to a semi-trusted server, which they referred
as outsourced KGC. In their approach, a secret key is split
into two shares held by a user and the server. For a revoked
user, the server refuses to collaborate. A disadvantage of
(Li et al. 2013) is that the sever needs to maintain all users’
secret key shares. Another work (Qin et al. 2015) adapted
the scheme of Seo and Emura (2013) to delegate public
key update workload from KGC to an untrusted server.
Each user keeps one short secret key and does not com-
municate with the KGC or the server during key updating.
Their scheme is provably secure against adaptive-ID cho-
sen ciphertext attacks under the DBDH assumption in the
standard model.

Broadcast Encryption. Identity-Based Broadcast
Encryption (IBBE) (Delerablée 2007) is a natural general-
ization of broadcast encryption (BE) in the IBE setting.
While adopting BE schemes to support user revocation
has been well studied (Naor et al. 2001; Kogan et al. 2006),
the IBBE primitive itself does not imply a solution for
the user revocation problem. Until very recently, Ge and
Wei (2019) formally studied scalable revocation method-
ology for IBBE schemes. Following the binary tree data
structure in Boldyreva et al. (2008), they gave a concrete
revocable IBBE scheme, which is semi-adaptively secure
under Chosen Plaintext Attacks (CPA) in the standard
model. However, the size of the secret keys is linear in
the number of maximum size of the recipients in one
encryption.

Limitations when Applying These Approaches to
SM9-IBE. According to Boyen (2007), known construc-
tions of pairing-based IBE schemes can be classified into
3 families: “Full Domain Hash” IBE (e.g., BF-IBE), “Expo-
nent Inversion” IBE (e.g., SK-IBE (Sakai and Kasahara
2003)) and “Commutative Blinding” IBE (e.g., Waters
IBE). A fact must be noted is that all above revocation
mechanisms are construed using “Full Domain Hash” IBE

Page 3 of 13

or “Commutative Blinding” IBE schemes. While the time-
concatenated solution (i.e., BF-IBE) is a generic technique
that can be applied to all above 3 families of IBE, other
revocation mechanisms (Boldyreva et al. 2008; Libert and
Vergnaud 2009; Seo and Emura 2013; Li et al. 2013; Qin et
al. 2015; Ge and Wei 2019) relied on the concrete struc-
ture of the underlying IBE schemes more or less. How-
ever, SM9-IBE is actually an “Exponent Inversion’-like IBE
scheme. Therefore, all mentioned revocation mechanisms
(except BF-IBE) cannot be trivially adopted for SM9-IBE.
As for BF-IBE, it has an unaffordable burden for both KGC
and users.

We note that all the above-mentioned revocation mech-
anisms only achieve indirect user revocation, which
means that the revocation needs time to take effect.
In such a situation, hackers may have downloaded and
decrypted all data during the time period.

Preliminary

Notations. Let || and © denote bitwise operations con-
catenation and XOR, respectively. We call a function negl
negligible in A, if for every positive polynomial poly(-)
there exists an N such that for all A > N, negl(A) <
1/poly(A). A probabilistic polynomial-time (PPT) algo-
rithm A is an algorithm that on input x, computes
A(x) using randomness and its running time is bounded
by poly(A). Following primitives are used in both the
SM9 and this work. One may refer to ISO/IEC 18033-2
(Shoup 2006) and (Cheng 2017) for detailed definitions.

e BITS(m): Count the bit length of a bit string m.

e EC2OSP(P): Convert an elliptic curve point P to an
octet string.

e FE2OSP(W): Convert a field element W to an octet
string.

e KDF2(H,, m, 1): Given a hash function H, with v-bit
output, a bit string m and a non-negative integer |,
the algorithm derives a |-bit key string.

e H2RF;(H,, m,n): Given a hash function H, with v-bit
output, a bit string m, a non-negative integer n anda
non-negative integer i, the algorithm outputs an
integer h; where 1 < hj <n —1.

Bilinear Pairing. Let GP be an algorithm that takes
as input a security parameter A and outputs a tuple
(G1, Go, Gr, p, e), where G1, G2 and G7 are multiplicative
cyclic groups of prime order p, ande : Gj x Gz > Gr isan
admissible bilinear map if: 1) Bilinearity: for all g; € Gi,
go € G anda,b € Z), we have e(g%, g) = e(g1, 22)”. 2)
Non-Degeneracy: e(g1,g2) # 1 whenever gj # 1g, and
82 F |e.

Gap-t-Bilinear Collision Attack Assumption (Gap-
t-BCAAI;;) (Cheng 2017). For a bilinear pairing
(G1, G, GT,Dp, e); aE Zo Z1 € G and g2€ Go, given
Sun et al. Cybersecurity (2020) 3:12

(21, 22,87", ho; (hig: ), 2.4 1g **)) for some values
i,j € {1,2} where h; € Zy, and different from each other

Y
for 0 < i < T, computing e(g1,.g2) 0+” is hard.

The SM9 identity-based encryption
The SM9 encryption (SM9-IBE) (Gm/t 2016a; Cheng
2017) is a hybrid encryption scheme that follows
the Key/Data Encapsulation Mechanism (KEM/DEM)
paradigm (Shoup 2001) in the IBE setting (Bentahar et
al. 2008). We first introduce the SM9 key encapsula-
tion mechanism (SM9-KEM), and then present the hybrid
encryption scheme. There are four algorithms in SM9-
KEM:

Setupsmo-KEM(A) —> (MPKsmg,MSKsmyg). On input a
security parameter A, the algorithm runs as follows:

1 Choose G = (G1, Go, Gr, p,e) — BP(A). Pick
random generators g € G1,h € Gg. Pick a random
y € Z,, compute w = g” and u = e(g,h)”.

2 Let F(ID;) = H2RF, (Aj, |ID;||hid, p), where hid = 3
and Hy, is a cryptographic hash function with v-bit
output.

3 Output MPKsmyo = (9, g,h, u, w, F) and MSKsmo = y.

Extractsijmo-Kem(MPKsmo, MSKsm9, 1D) > SKip;- On input
a master public key MPKsyo, a master secret key MSKsmo
and an identity ID;, the algorithm outputs a secret key
SKip, = AVFAOOD

Encapsmo-Kem(MPKsmg,!D;) — (CTip,, K). On input a
master public key MPKsyg, an identity ID; and a message
m, the algorithm runs as follows:

1 Select a random z € Z*. Compute
Q=w- gFiD) — gyt+FID) C= Q t=.

2 Derive a session key
K = KDF2(A,, EC2OSP(C1)||FE2OSP(£)||IDj, k)
where k is the key length of the DEM part.

3 Output (CTip, = Ci, K).

Decapsmo-Kem(MPKsyo, SKip,;, CTip,;) — K. On input a
master public key MPKsyg, a secret key SKip, and a cipher-
text CTjp,, the algorithm runs as follows:

1 Compute ¢t = e(CTjp;, SKip,;) = uv’.
2 Derive the encapsulated key

K = KDF2(Hy, EC2OSP(CTip,)||[EE2ZOSP(£)||ID;, k).
3 Output the key K.

Let Esym = (ENnCsym,DeCsym) denote a symmetric
encryption scheme that consists of an encryption algo-
rithm Encsym and a decryption algorithm Dec.ym, where:
(1) Encsym takes input a key and a message, and outputs a
ciphertext; and (2) Decsym takes input a key and a cipher-
text, and outputs a message. The full SM9-IBE encryption
scheme is constructed as follows:

Page 4 of 13

Setupsyo(A) — (MPKsi9, MSKsmo). It is the same as the
algorithm Setupsiy9o-Kem in SM9-KEM.

Extractsmo(MPKsmo, MSKsmo, 1D) — SKip,. It is the same
as the algorithm Extractsjo_Kem in SM9-KEM.

Encsmo(MPKsmo,!Di,m) — CTip,. On input a master
public key MPKsmg, an identity ID; and a message m,
the algorithm runs Encapsyo_Key(MPKsmg,!D;) to obtain
(C,,K). Further, the message is encrypted using the sym-
metric encryption algorithm: Cy = Encsym(K,m). The
algorithm outputs CTip, = (Ci, C2).

Decsmo(MPKsmo, SKip,,CTip;) —-  m. On input a
master public key MPKsyg, a secret key SKip, and
a ciphertext CTjp, = (Ci,C2), the algorithm runs
Decapsmo-Kem(MPKsmo, SKip,, Ci) to obtain the encapsu-
lated K. The DEM part is decrypted using the symmetric
decryption algorithm: m = DeCcsym(K, C2). The algorithm
outputs the message m.

Chosen Ciphertext Security of SM9-IBE. In the
identity-based hybrid encryption setting, Bentahar et al.
(2008) proved that a hybrid IBE scheme is secure against
adaptive-ID Chosen Ciphertext Attacks (ID-IND-CCA), if
the underlying KEM part is ID-IND-CCA secure and the
DEM part is a one-time symmetric encryption scheme
that can resistant Find-Guess (FG) Chosen Ciphertext
Attacks (FG-CCA) (cf. Theorem 1 in Bentahar et al. (2008)).
Following this framework, (Cheng 2017) first proved
that SM9-KEM is ID-IND-CCA secure with the Gap-p-
BCAA1,, assumption in the random oracle model, and
then stated that SM9-IBE is IND-ID-CCA secure giving an
FG-CCA secure DEM.

The model of SA-IR-RIBE
In this section, we present the system model and the
security definitions.

System model

In the proposed mechanism, there are four parties
involved: a key generation center (KGC), a server, data
owners and data receivers. The compact system model is
illustrated in Fig. 1. All acronyms used in this paper are
listed in Table 1.

KGC is responsible for generating and distributing sys-
tem parameters to other entities, including the master
public key, the master secret key, the server secret key
and users’ secret keys. Besides, it maintains a revoca-
tion list for realizing user revocation. The server provides
computing and storage resources for users. It gets cipher-
texts from data owners and pushes the ciphertexts to
data receivers. Most importantly, the server accomplish
the user revocation functionality according to the revoca-
tion list that provided by KGC. We note that an existing
server can be adopted to play the role of the server in our
system, e.g.,a SMTP server in an email system. Data own-
ers encrypt messages under data receivers’ identities and
Sun et al. Cybersecurity (2020) 3:12

Page 5 of 13

 

 
 
 
 

61101016
10101016
10101116

CT p, oD

“

 

 

Data Owner

Fig. 1 System model of the proposed server-aided revocation mechanism

 

 

Key Generation Center

L | MPK, CSK,,,

 

Server

 
 
 

61101016

19101618
10161116

TCT yp, 3
OO Ww
eo

Data Receiver

 

 

uploads ciphertexts to the server. Data receivers obtain
ciphertexts from the server and decrypt them with their
secret keys.

The Server-Aided Immediate and Robust Revocable
Identity-Based Encryption (SA-IR-RIBE) scheme consists
of 9 algorithms:

e Setup(A) — (MPK, MSK, SSK, L). On input a
security parameter A, the algorithm (run by KGC)
outputs a master public key MPK, a master secret key
MSK, an initial server secret key SSKct anda
revocation list L.

e Extract(MPK, MSK, ID;) — SKip,;. On input a master
public key MPK, a master secret key MSK, and an
identity ID;, the algorithm (run by KGC) outputs a
secret key SKip,.

e Enc(MPK, ID;, 77) — CTip,. On input a master public
key MPK, an identity ID; and a message m, the
algorithm (run by a data owner) outputs a ciphertext
CT)p;-

© CTInit(MPK, CTip,, SSKetr) = CTip, ctr. On input a
master public key MPK, a ciphertext CTjp, anda
server secret key SSK, the algorithm (run by the
server) outputs an updated CTjp, ctr.

Table 1 Acronyms used in this paper

e SSKUpdate(MPK, SSK) > SSK. On input a
master public key MPK and a server secret key SSKctr,
the algorithm (run by the server) outputs an updated
server secret key SSK ty’.

e CTUpdate(MPK, CTip; ctr, SSKetr, SSKctr’) = CTip,,ctr’-
On input a master public key MPK, a ciphertext
CTip,,ctr, and two server secret keys SSKctr, SSK’, the
algorithm (run by the server) outputs an updated
ciphertext CTip, ctr’.

e Transform(MPK, CTip, ctr; SSKetr, L) — TCTip,. On
input a master public key MPK, a ciphertext CTjp, ctr, a
server key SSKe and a list L, the algorithm (run by
the server) outputs a transformed ciphertext TCTjp,.

e Dec(MPK, TCTip;, SKip;) — m. On input a master
public key MPK, a transformed ciphertext TCTip,, and
a secret key SKip,, the algorithm (run by a data
receiver) outputs a message m.

e Revoke(ID;, LL) — L’. On input an identity ID; anda
revocation list L, the algorithm (run by KGC) outputs
an updated revocation list L’. The new list L’ is
further distributed to the server.

The players in the system may conduct the following
interactions (cf. Fig. 1):

 

 

 

 

Acronym Description Acronym Description

MPK master public key MSK master secret key

ID; the i-th user's identity SKip, the i-th user's secret key

ctr the time counter SSKctr the server secret key related to ctr

L the user revocation list m message to be encrypted

K the derived symmetric key CTip; ciphertext that sent to the /-th user

CT ip, ctr ciphertext that sent to i-th user related to ctr TCTip, transformed ciphertext that sent to i-th user

 
Sun et al. Cybersecurity (2020) 3:12

Page 6 of 13

 

Symmetric

   
  

Conceal L
KEM part | C! | Cl

 

 

Encryption Ciphertext initialization

 

Fig. 2 Overview of the proposed server-aided revocation mechanism

Portree ee ee ee een, ore

 
  
  
  
   

a

 

 

 

 

Symmetric !
decryption Ld

 
   
 

 

| K Data
Key
+ ; SKip,;
Cy Cy | | decapsulation Di
Ciphertext update Ciphertext transformation Decryption

 

 

System initialization: PKG runs the algorithms Setup
and Extract to generate system parameters and all users’
secret keys. It then distributes MPK to all other parties,
SSKcr and L to the server and SKijp, to users. Initially, the
user revocation list L is empty.

Message encryption: A data owner runs the algorithm
Enc to encrypt a message under an identity ID;, and
obtains a ciphertext CTip,. The ciphertext CTjp, is uploaded
to the server and then concealed by the server with the
algorithm CTInit using the server secret key SSKctr.

Server key evolution: To resist exposure of the server
secret key, the server updates the server secret key SSKct
and all stored ciphertexts periodically or when the server
secret key leaks. When the server secret key SSKctr is
demands to be updated, a new server secret key SSK,
is randomly sampled by calling the algorithm SSKUp-
date. Meanwhile, all stored ciphertext are updated with
the algorithm CTUpdate using the two server secret keys
SSKetr, SSKctr, Le. CTip,,ctr is updated to CTip, ctr. Once all
ciphertexts have been updated, SSK¢t; becomes the cur-
rent server secret key. Meanwhile, all ciphertexts in time
ctr and SSK, are erased from the server’s storage.

Message decryption: Before pushing a stored cipher-
text to a data receiver, the server runs Transform to obtain
a transformed ciphertext TCTip,. On receiving TCTjp,, the
receiver decrypts it with the algorithm Dec using his/her
secret key. Note that the algorithm Transform takes the
revocation list L as its input, thus the ciphertext TCT)p,
is computed in a manner that only non-revoked receivers
can decrypt the ciphertext successfully.

User revocation: When a user is required to be revoked,
KGC updates the list L by running the algorithm Revoke
and sends the updated list L to the server.

Security definition

Adversarial Model. KGC generates user secret keys, and
are assumed to be honest. Data owners are trusted and we
do not consider the data they own as correct or incorrect.
The server is honest-but-curious (Li et al. 2012), mean-
ing that it will honestly follow the protocol but try to
learn as much information as possible. This assumption
is realistic, since the server will be a service provider that
cares its reputation and thus restricted by user contrast.
While most of data receivers are trusted, some of them are

corrupt and share their secret keys in the collusion. This
collusion may gives the adversary more power.

Chosen Ciphertext Security. We give the semantic
security against adaptively chosen-ID and Chosen Cipher-
text Attacks for server-aided revocable IBE scheme (in
short, SA-IND-ID-CCA).

The adversary is able to obtain a set of corrupted users’
secret keys {SKip,,SKip,,...} (except the target), and all the
server secret keys, i.e., SSK], SSK2,..., SSKctr. The security
is defined with the following game:

Setup: The challenger C takes a security parameter
AX and runs Setup algorithm. It gives MPK,SSKct, to the
adversary A and keeps MSK to itself. The current time
counter ctr is set to 1. C periodically updates the counter
to ctr’ and sends the new server secret key SSK, to A.

Phase 1: A adaptively issues queries to following three
oracles:

© Obxtract(IDj): C sends a secret key SKip, to A, where
SKip, is generated with the algorithm Extract.

© Opbec(IDj, CTip,,ctr): C obtains SKip, by running
algorithm Extract. It then decrypts CT)p, ctr by
running algorithms Transform and Dec to obtain the
plaintext m. C outputs m to A.

e Ossx(ctr;): If the server secret key SSKctr, has not
been generated, C randomly samples SSK, and
stores SSKctr,. Otherwise, C recalls SSKc,, from its
storage. C outputs SSK, to A.

Challenge: Once A decides that Phase 1 is over, it out-
puts a challenge identity ID*, a challenge time counter ctr*
and two equal length messages mo, 7m ,. Note that ID* did
not appear in the previous queries to Oextract. If SSKctr*
has not been generated, B randomly samples SSKc,«. The
challenger C chooses a fair coin jz € {0,1} and runs algo-
rithm Enc(MPK, ID*,m,,) to obtain CT,,.. Further, it runs
CTInit(MPK,CT)., SSKetrs) to obtain CT ips ctr: The chal-
lenger returns CTjp« 44,« as the challenge ciphertext to the
adversary A.

Phase 2: A adaptively issues more queries to the three
oracles:

© Oextract(ID;) where ID; 4 ID*: The challenger
responds as in Phase 1.
© Opbec(ID;, CTip,,ctr) where
Sun et al. Cybersecurity (2020) 3:12

(ID;, CTip;,ctr) A (ID*, CTips ctx): The challenger
responds as in Phase 1.
e Ossx(ctr;): The challenger responds as in Phase 1.

Guess: Finally, the adversary A outputs a guess pu’ €
{0, 1} and wins the game if uw = pw’.

Definition 1 (SA-IND-ID-CCA Security) We say that a
SA-IR-RIBE scheme is SA-IND-ID-CCA secure if for any PPT
adversary A the function Adv y is negligible:

1
Adv. = [Pru = w!]—5| < negl().

User Revocation Validity. An important security prop-
erty of a SA-IR-RIBE scheme is user revocation validity.
Namely, if a user is revoked in time ctr*, he/she cannot
decrypt all ciphertexts that encrypted to his/her identity.
In this situation, the adversary is the revoked user with the
challenge identity ID*, and holds the corresponding secret
key SKip». Meanwhile, the adversary is allowed to obtain
a set of corrupted users’ secret keys, i.e., {SKip,,SKip,, . . -}.
Besides, in time ctr*, the server may discard all previous
server secret keys, i.e., SSK1,SSK2,..., SSKctr*_1 and only
protect its current secret key SSKcy«. Thus, the adver-
sary may obtain all previous server secret keys except the
one in the challenge time counter, i.e., SSKctr«. We remark
that this assumption gives the adversary maximum power
to attack the system. Semantic security against adaptive-
ID Chosen Plaintext Attacks (CPA) for User Revocation
Validity is defined with the following game:

Setup: The challenger C takes a security parameter A
and runs Setup algorithm. It gives MPK to the adversary
A and keeps SSK<t; and MSK to itself. The current time
counter ctr is set to 1. C periodically updates the counter
to ctr’ and keeps SSK; to itself.

Phase 1: A adaptively issues queries to following two
oracles:

© Oeéxtract(IDj): C sends a secret key SKip, to A, where
SKip, is generated with algorithm Extract.

e Ossx(ctr;): If the server secret key SSK; has not
been generated, C randomly samples SSK, and
stores SSK¢;,. Otherwise, C recalls SSKq,, from its
storage. C outputs SSK, to A.

Challenge: Once A decides that Phase 1 is over, it out-
puts a challenge identity ID*, a challenge time counter
ctr* and two equal length messages mo, m ,. Note that two
constraints must be satisfied: (1) ID* cannot appear in pre-
vious queries to Oextract; and (2) ctr* cannot appear in
previous queries to Ossx. If the server secret key SSKctr*
has not been generated, C randomly samples SSKct« and
keeps the key to itself. C chooses a fair coin w € {0,1},
runs algorithm Enc(MPK, ID*, m,,) to obtain CT)... Further,

Page 7 of 13

it runs CTInit(MPK, CTips, SSKetr«) to obtain CTip» oy. The
challenger returns CTipx ¢4;. as the challenge ciphertext to
the adversary A.

Phase 2: A adaptively issues more queries to the three
oracles:

© Oextract(ID;): The challenger responds as in Phase 1.
e Ossk(ctr;) where ctr; 4 ctr*: The challenger responds
as in Phase 1.

Guess: Finally, the adversary A outputs a guess wu’ €
{0, 1} and wins the game if uw = w’.

Definition 2 (User Revocation Validity) We say that a
SA-IR-RIBE scheme is adaptive-ID CPA-secure for User
Revocation Validity if for any PPT adversary A the func-
tion Adv , is negligible:

1
Adva = |Prl w= 1] — 5! S negl().

Server-aided immediate and robust revocation for
SM9-IBE

In this section, we present the proposed revocation mech-
anism, which is illustrated in Figs. 2 and 3.

A data owner encrypts data under an identity ID;, and
obtains a ciphertext CTip, = (Ci,C2). The encryption
algorithm works in the KEM/DEM setting, where Cj is
the KEM part and C2 is the DEM part. On receiving the
ciphertext CTjp,, the server takes the following actions:
(1) derives a mask A from SSK; and C2 using a pseudo-
random function PRF, (2) masks C; to C} using A, and
(3) stores (C}, Cz) as CTip, ctr. Note that the server does not
store the original ciphertext CTip,. When updated to anew
server secret key SSK’, all stored ciphertext are updated
using the two server secret keys SSKctr, SSK. On pushing
ciphertext to a data receiver, if the receiver is not revoked,
the server transforms ciphertext CTip, ctr to TCTip,; using
SSKar and outputs TCTip, thus the receiver can decrypt
TCTip,; to get the plaintext; otherwise, the server returns
the concealed ciphertext CT)p, ctr’.

The identity space, message space, and ciphertext space
are {0,1}*, {0,1}* and (Gr x {0,1}*), respectively. The
proposed SA-IR-RIBE scheme consists of the following
algorithms:

Setup(A) — (MPK, MSK, SSK, L). On input a security
parameter A, the algorithm does the following:

1 Choose G = (Gj, Go, G7, p,e) < BP(A). Choose
random generators g € G),h € G2 and random
elements y € Z,. Set u = e(g,h)” and w = g”.

2 Let F(ID;) = H2RF, (Aj, |ID;||hid, p), where hid = 3,
and Hy, is a cryptographic hash function of v-bit
output. Choose a collision resistant hash function
H : {0,1}* — {0,1}2. Choose a pseudo-random
function PRF: {0, 1}/! x {0,1} — Zé.
 

 

Sun et al. Cybersecurity (2020) 3:12 Page 8 of 13
4 sskUpdate | —- ~—-| sskUpdate | —+ ss Kj4 SSK cer ~—+4 88K Update | > SSK ctr
CTip oe / CTUpdate / CTUpdate / CTUpdate
CTip,,j CTip, j+1 CTip, ,ctr CTip, ,ctr+1

 

Fig. 3 Overview of the server key evolution and ciphertext update

 

3 Choose an FG-CCA secure one-time symmetric
encryption scheme Esym = (Encsym, Decsym). The
key length of Esym is k.

4 Choose a random SSK € {0,1}” and set the counter
ctr = 1.

5 Return MPK = (G,g,h,u, w, F, H, PRF, Esym);

MSK = y, SSKetr = (sskj, ctr) and L = @.

Extract(MPK, MSK, ID;) — SKjp,. On input a master pub-
lic key MPK, a master secret key MSK, and an identity IDj,

the algorithm outputs a secret key SKip, = 1 7FRD) .

Enc(MPK, ID;, 72) — CTjp,;. On input a master public key
MPK, an identity ID; and a message m, the algorithm does
the following:

1 Choose a random z € Z*. Compute

Q=w- gh) — gvt+FiID) Cc, = t= v%.
2 Derive a symmetric key

K = KDF2(A,, EC2OSP(C}j)||FE2ZOSP(é)||IDj, k).
3 Compute C2 = EnCcym(K, m).

The algorithm outputs CTjp, = (C1, C2).

CTInit(MPK, CTip,, SSKctr) — CTip,,ctr- On input a master
public key MPK, a ciphertext CTip, = (Cj, C2) and a server
secret key SSKo, = (Sske,, ctr), the algorithm outputs
CTip,,ctr = (C}, C2), where:

A = PRE(ssker, H(C2)), Ci = Ch.

SSKUpdate(MPK, SSK) — SSKet. On input a mas-
ter public key MPK and a server secret key SSKay =
(sskctr, ctr), the algorithm sets a new counter ctr’ = ctr+1
and chooses a random sskcy € {0,1}. The algorithm
outputs an updated secret key SSK = (SSk¢ty’, ctr’).

CTUpdate(MPK, CTjp,,ctr, SSKetr, SSKetr’) => = CTip, ctr’.
On input a master public key MPK, a ciphertext
CTip,,ctr = (C1, C2), and two server secret keys SSKa, =
(sSketr, Ctr), SSK = (SSket;, ctr’), the algorithm com-

putes:
A = PRF(sskctr, H(C2)), A’ = PRE(ssketr’, H(C2)),

C, = ce ZS

The algorithm outputs an updated ciphertext CTip,carn =
(Ci, C2).

Transform(MPK, CTip, ctr, SSKetr, L) — TCTip,. On input
a master public key MPK, a ciphertext CTip, ctr = (Ci, C2),
a server secret key SSKcty = (Sskctr, ctr) and a revocation
list L, if ID; € L, the algorithm returns CTip, ctr as TCTip;;
otherwise it computes:

A = PRE(ssketr, H(C2)), Ci = = gly FFD)
The algorithm outputs a transformed ciphertext TCTip, =
(Cj, Co).

Dec(MPK, TCTip,, SKip,) —- m. On input a mas-
ter public key MPK, a ciphertext TCTip, = (Ci,C2),
and a secret key SKjp,, the algorithm computes t =
e(C1, SKip;) = e(g, 4)”* = u*. The encapsulated key is K =
KDF2(H,, EC2OSP(C1)||FE2OSP(£)||ID;,k). The cipher-
text Cy is decrypted to m with the symmetric decryption
algorithm: m = DeCsym(K, C2).

Revoke(ID;,L) — L’. On input an identity ID; and
a revocation list L, the algorithm outputs an updated
revocation list L’ = L U {ID;}.

c/*

Security proof

Theorem 1 The proposed server-aided Identity-Based
Encryption scheme achieves SA-IND-ID-CCA security with
respect to Definition 1, if the SM9-IBE scheme is \ND-ID-
CCA secure.

Proof Suppose the adversary A can break the proposed
SA-IR-RIBE scheme with a non-negligible advantage, we
build a simulator 6 to break the security of the SM9-IBE
scheme with a non-negligible advantage. B interacts with
A as the challenger. Let C be the challenger in the IND-ID-
CCA secure game of the SM9-IBE scheme. It provides two
oracles to B:

O2Me -(ID;): C runs Extractsyo(ID;) and returns the

secret key SK\jp;.
e ORM? (ID;, CTip,): C runs Extractsy9(ID;) to obtain

SKip;. It then runs Decsimo(MPK, SKjp,, CTip,) to
decrypt CTjp,. The resulting plaintext is sent to B.

 
Sun et al. Cybersecurity (2020) 3:12

The simulator B works by interacting with the chal-
lenger C and the adversary A as follows:

Setup. C sends MPKsm9 = (G,g,h,u,w,F, Esym) to B.
The unknown master secret key MSKsyg is y. B selects a
collision resistant hash function H and a pseudo-random
function PRE. Further, B chooses a random ssk; € {0,1}
and sets SSK; = (sskj, ctr = 1). Finally, B sends the mas-
ter public key MPK = (G,g,h,u, w, F,H,PRF, Esym), and
the initial server secret key SSK; to A. The simulator B
updates the server secret key periodically and it will send
all updated server secret keys to A.

Phase 1: A adaptively issues queries to following three
oracles:

© Oebxtract(ID;): B sends the query to O2M? et (IDi) and
forwards the obtained secret key SKip, to A.

© Opdec(IDj, CTip,,ctr): B runs
Transform(MPK, CTip, ctr, SSKctr, J) to obtain TCT)p,. It
then issues a query to OMS on (ID;, TCTip,). C returns
a plaintext. B forwards the plaintext to A.

e Ossx(ctr;): If the server secret key SSKq,, has not
been generated, B randomly samples SSKetr, € {0, 1}4
and stores SSKct,;. Otherwise, C recalls SSKctr; from its

storage. B outputs SSKctr; to A.

Challenge: A outputs a challenge identity ID*, a chal-
lenge time counter ctr* and two equal length messages
mo,m, € {0,1}*. Note that ID* cannot appear in previ-
ous queries to Oextract. If SSKctr*« has not been generated,
B randomly samples SSK¢tr*. B forwards ID* and mo, m1
to C. On receiving the challenge, C chooses a fair coin uw €
{0,1}, runs Encsjyygo(MPKsyg, !D;, My) to obtain CT ip» and
sends CT,). to B. Finally, B runs CTInit(MPK, CT,5», SSKctr*)
to obtain CTip: ¢«, and sends CTip« cpp. to A.

Phase 2: A adaptively issues more queries to following
three oracles:

© Oekxtract(ID;) where ID; 4 ID*: B responds as in Phase
1.

© Opec(IDi; CTip, ctr) where
(IDj, CTip,,ctr) # (ID*, CTip» et): B responds as in
Phase 1.

e Ossx(ctr;): B responds as in Phase 1.

Guess: A outputs a guess ww’ of w. B forwards yu’ to C.

As shown above, the master public key, the server secret
key, secret keys and ciphertexts generated by B is of
identical distribution to those of the proposed SA-IR-
RIBE scheme. If A successfully guesses which message is
encrypted in the challenge ciphertext, B also outputs the
right guess. Therefore, if A can break the proposed SA-IR-
RIBE scheme with probability «(A), 6 can break SM9-IBE
with the same probability. This completes the proof of
Theorem 1. LI

Page 9 of 13

Theorem 2 The proposed server-aided Identity-Based
Encryption scheme is adaptive-ID CPA-secure for User
Revocation Validity with respect to Definition 2.

The Theorem 2 is proved briefly as follows.

Proof Let ID* be the identity of the revoked user. Let
ctr* be the challenge time counter and CTip: (4. be the
challenge ciphertext. The adversary A (the revoked user)
holds the secret key SKip+, and queries on Oeytract (ID;) and
Ossx (ctr;) with the constraint that ctr; 4 ctr*.

In the Challenge phase, A receives the challenge
ciphertext CTips ct == (Cs)4, C3) where A =
PRF(SSKetr#, H(C3)). In this case, e(SKipx,(C*)4) =
e(g,h)’74. Let t = e(g,h)”%, which is required to derive
the encapsulated key K. Provided that A is randomly gen-
erated by the PRF, (e(g, h)’24,t) can be viewed as an
ElGamal KEM instance (u74,u7), where u = e(g,h)’.
Therefore, if the adversary A can break the User Revo-
cation Validity security of the proposed scheme, we can
build a simulator 6 to break the security of EIGamal KEM.
Thus, Theorem 2 is proved. LJ

Performance evaluation
In this section, we give thorough performance analyses of
the proposed scheme.

Theoretical Analysis. As shown in Table 2, we com-
pare our revocation mechanism with many existing works
(Boneh and Franklin 2001; Boldyreva et al. 2008; Libert
and Vergnaud 2009; Seo and Emura 2013; Li et al. 2013;
Qin et al. 2015) in terms of functionality, security model,
communication costs and computation costs. Note that
we do not include schemes with impractical assumptions,
e.g., (Boneh et al. 2001; Libert and Quisquater 2003). The
comparison is performed on the symmetric pairing set-
ting: G x G — Gr. Meanwhile, only operations of the
KEM part are measured.

The works (Boneh and Franklin 2001; Boldyreva et al.
2008; Libert and Vergnaud 2009; Seo and Emura 2013;
Qin et al. 2015) provide indirect revocation of users’ secret
keys meaning that the revocation needs a period of time
to take effect. Our scheme and (Li et al. 2013) achieve
direct user revocation by adopting a semi-trusted server.
In our proposed SA-IR-RIBE scheme, the sizes of master
public key, secret key and ciphertext are all constant, i.e.,
O(1). Libert and Vergnaud (2009); Seo and Emura (2013);
Qin et al. (2015) adopted Waters IBE (Waters 2005) as the
underlying IBE scheme thus had long master public keys,
i.e., O(log N). (Boldyreva et al. 2008; Libert and Vergnaud
2009; Seo and Emura 2013) followed the BGK approach
(Boldyreva et al. 2008) resulting long secret keys, i.e.,
O(log N). Compared with all listed schemes (Boneh and
Franklin 2001; Boldyreva et al. 2008; Libert and Vergnaud
Sun et al. Cybersecurity

Table 2 Comparisons with revocable IBE schemes

(2020) 3:12

Page 10 of 13

 

 

(Boneh and (Boldyreva et (Libert and (Seo and (Li et al. 2013) (Qin et al. 2015) Ours
Franklin al. 2008) Vergnaud Emura 2013)
2001) 2009)
Revocation Mode Indirect Indirect Indirect Indirect Direct Indirect Direct
Server Semi-trusted Untrusted Semi-trusted
Master Public Key 2|G| 6|G| (6 + (6 + 3|G| (6 + log N)|G| A\G|
Size log N)|G| log N)|G|
Secret Key Size |G| 2 log N|G| log N(2|G| + 2 log N|G| A\G| 2|G| |G|
|Zp|)
Ciphertext Size |G| 3|G| + |Gr| 3|G| + 2|G7| 3|G| + |Gr| 3|G| 3|G| + |Gr| |G|
N N N N
Key Update Size (N — r)|G| 2rlog > |G| rlog —Q\|G|+ 2rlog > |G| 2(N—1n|G| 2rlog = |G| 0
IZp|)
Key Generation 1Exp 12Exp Alog NExp 3log NExp 6Exp 3Exp 1Exp
Cost
Encryption Cost 2Exp + 1P 7 log NExp 5Exp + 2P 5Exp 3Exp 5Exp 3Exp
Decryption Cost TExp + 1P 2Exp + 4P TExp + 3P 3P 4P 3P 1P
N N N N
Key Update Cost (N — ryExp 7rlog = Exp Ar log Exp 3rlog —Exp 3(N — NExp 3rlog + Exp nExp

 

*Exp and P denote a module exponentiation and a pairing computation, respectively. N, rand n indicate the numbers of users, revoked users and ciphertexts stored in the

server, respectively

2009; Seo and Emura 2013; Li et al. 2013; Qin et al. 2015),
the key generation, encryption, and decryption algorithms
in our scheme are efficient. The key generation algo-
rithm takes only 1 exponentiation, which is better than
(Boldyreva et al. 2008; Libert and Vergnaud 2009; Seo
and Emura 2013; Li et al. 2013; Qin et al. 2015) and
equal with (Boneh and Franklin 2001). The encryption
algorithm takes 3 exponentiations, which is better than
(Boneh and Franklin 2001; Boldyreva et al. 2008; Libert
and Vergnaud 2009; Seo and Emura 2013; Qin et al. 2015)
and equal with (Li et al. 2013). The decryption algorithm
costs only 1 pairing, which is better than all listed works
(Boneh and Franklin 2001; Boldyreva et al. 2008; Libert
and Vergnaud 2009; Seo and Emura 2013; Li et al. 2013;
Qin et al. 2015). When a user is revoked, (Boneh and
Franklin 2001; Boldyreva et al. 2008; Libert and Vergnaud
2009; Seo and Emura 2013; Li et al. 2013; Qin et al.
2015) had large communication costs and computation
costs for key update. In contrast, our scheme does not
have communication costs and only performs ciphertext
updates on the server side. Above theoretical discus-
sions show the advantage and efficiency of the proposed
scheme.

Experimental Analysis. To validate the reality of our
ideas, we instantiate and implement the proposed scheme
following the standard (Gm/t 2016b). The primitives
EC2OSP, FE2OSP, KDF2 and H2RF; are constructed as
Shoup (2006); Cheng (2017). The bilinear pairing is the
standard 256-bit BN curve as specified in Gm/t (2016b).
The hash functions H, and H are implemented using the
SM3 hash algorithm (Wang and Yu 2016), which takes

input a message m of length / (J < 2%), and outputs a 256-
bit hash. Thus, /; = /2 = v = 256. The PRF is instantiated
as follows:

PRE(a, b) = HMAC-SM3(a, b) =SM3((a ® opad)||
SM3((a ® ipad)||b))

where ipad is the byte 0x36 repeated 64 times and opad
is the byte Ox5C repeated 64 times. For the symmetric
encryption primitive Esym, we use the DEM construction
in Gm/t (2016b), where the message is encrypted using
XOR encryption. Concretely, the DEM part is computed
as follows:

K,||Ko = KDF2(A,, EC2OSP(C,)||FE2OSP(4)||IDj, || + v),
C=k,@m, C.=(C,H,(C'||K2)).

We implement the proposed SA-IR-RIBE scheme on
top of the GmSSL library !. We conduct comprehensive
benchmark on one core of an Intel Xeon CPU E5-2609 v4
@1.70 GHz and 128GB RAM running Ubuntu 16.04 LTS
64-bit. Since the network speed changes according to the
user, only the running time of each algorithm is measured.
The size of the message is set to 75 KB, which is a typi-
cal size of an email file’. Each algorithm is executed 100
times. The average running results are taken as the final
results. The detailed result is shown in Table 3. It takes

 

‘http://gmssl.org/
“https://www.lifewire.com/what-is-the-average-size-of-an-email-message-
1171208
Sun et al. Cybersecurity (2020) 3:12

Table 3 Performance evaluation of the proposed mechanism

Page 11 of 13

 

Algorithm Setup Extract Enc CTInit

SSKUpdate CTUpdate Transform Dec

 

Time (ms) 0.76 26.99 405.68 1.73

645 x 107° 3.36 1.78 351.34

 

405.68 ms and 351.34 ms for user-side message encryp-
tion and decryption, while algorithms CTInit, SSKUpdate,
CTUpdate running on the server only cost 1.73 ms, 6.45 x
10~° ms and 3.36 ms, respectively.

As our revocation scheme adds additional overhead
on the server side, we further measure performance of
the server with the following procedures: 1) On time
ctr}, N users in the system encrypt their messages and
send the encrypted payloads to the server. Upon receiv-
ing a user’s upload request, the server runs the algo-
rithm CTInit with its server secret key SSK, to gen-
erate the new ciphertext CTip,ctr;, and stores it on the
disk. 2) When updated to time ctro, the server first
updates its server secret key SSK, to SSK, with algo-
rithm SSKUpdate, then runs CTUpdate to update all stored
ciphertexts. 3) N valid users send download requests to
the server, the server runs Transform with SSK¢,, and
sends the transformed ciphertexts to the users. Note
that for simplicity, we do not consider network latency
and disk I/O time in this benchmark, so only the server
processing time is measured. We set the message size
sent by each user to 75 KB, and increase N from 0 to
10,000. To fully leverage server’s computational power,
we integrate OpenMP (Dagum and Menon 1998) to sup-
port parallel executions and compare with non-parallel
ones.

In Fig. 4 and Table 4, we present the experiment result.
The integration of OpenMP has significantly reduced

latency and improved throughput of the server. With
OpenMP disabled, the processing time is about tens of
seconds. The algorithm CTlnit takes 18.43 seconds to
initialize 10,000 users’ uploaded messages. The algorithm
CTUpdate takes 35.57 seconds to update all the stored
ciphertexts. The algorithm Transform costs 19.56 sec-
onds to transform the stored ciphertexts for 10,000
users’ requests. With OpenMP enabled, the obtained
performance is satisfactory. CTInit only takes 2.91 sec-
onds to initialize 10,000 users’ uploaded messages. CTUp-
date takes 4.85 seconds to update all the stored cipher-
texts. Transform costs 2.68 seconds to transform the
stored ciphertexts for 10,000 users’ requests. During
the experiment, algorithms CTInit, SsKUpdate, CTUpdate
reach throughput of 269 MB/s, 151 MB/s and 277 MB/s
respectively. The statistics show that the proposed scheme
is practical for real-world systems.

Conclusion

In this paper, focusing on the problem of SM9-IBE revoca-
tion, we proposed a server-aided revocation mechanism.
Our model has three desirable properties: (1) Compact
system model: an existing server is adopted to perform all
heavy workloads during user revocation; (2) Efficient and
immediate revocation: the revocation takes effect imme-
diately by taking simple operations in the server; and
(3) Key-exposure resistance: even if the server secret key
is leaked, a revoked user still cannot decrypt any data. We

 

(a) CTlnit time

 

 

OpenMP Enabled —*— 35
OpenMP Disabled —*—

OpenMP Enabled —*—
OpenMP Disabled —*—

 

 

 

 

 

 

 

(b) CTUpdate time

 

(c) Transform time

  
 

 

18 OpenMP Enabled —*—
16 OpenMP Disabled —*—

 

 

 

 

 

2000 4000 6000

Number of user requests

8000 10000 2000 4000

(d) CTInit throughput

600 600

OpenMP Enabled —*—
OpenMP Disabled —*—

 

 

OpenMP Enabled —*—
OpenMP Disabled —*—

a
So
Oo
a
So
Oo

 

 

 

 

 

 

i
oO
oO
aN
oO
oO

=
°o
oO
=
°
o Oo

t

Throughput (MB/s)
NO oO
oO oO
Oo oO
Throughput (MB/s)
nm
So 8
So 8

 

+ + + + + +>
o—>—+ +

Number of stored ciphertexts

(e) CTUpdate throughput

i oe ee oe

 

 

 

 

 

 

@ 12
© 10
E 8
6
4
= —* 2 o- “-?
Qe — a
6000 8000 10000 2000 4000 6000 8000 10000
Number of user requests
(f) Transform throughput
600
OpenMP Enabled —*—
@ 500 | openmp Disabled —-—
co
= 400
2 300
2 Zoo —- —_¢ __*——_~+- ~ *
Do
5 200
<—
F 100

o—+ + + + + -—- + + + + >

 

 

o

2000 4000 6000 8000

Number of user requests

10000 2000

Fig. 4 Performance evaluation of the server

 

4000
Number of stored ciphertexts

+ + >

8000 10000

oO

6000 2000 4000 6000 8000

Number of user requests

10000

 
Sun etal. Cybersecurity (2020) 3:12

Table 4 Performance evaluation of the server

Page 12 of 13

 

 

 

 

 

#Users CTInit CTUpdate Transform
OpenMP*
Time Throughput Time Throughput Time Throughput
100 N 0.18 40.63 0.34 21.11 0.19 38.46
Y 0.03 275.99 0.05 153.42 0.03 257.31
500 N 0.90 40.90 1.76 20.89 0.96 38.37
Y 0.11 342.12 0.21 170.68 0.12 313.51
+000 N 1.81 40.43 3.57 20.53 1.90 38.70
: Y 0.21 351.81 0.44 167.30 0.27 273.58
N 3.60 40.76 7.14 20.56 3.76 39.06
2,000
Y 0.42 348.42 1.05 140.09 0.48 305.55
N 5.53 39.82 10.57 20.83 5.79 38.03
3,000
Y 0.80 273.93 1.50 147.24 0.85 258.03
N 7.31 40.16 14.02 20.92 7.65 38.33
4,000
Y 1.12 262.84 2.19 133.82 1.08 270.54
N 9.10 40.32 17.78 20.63 9.68 37.90
5,000
Y 2.02 181.82 2.38 154.01 1,31 280.72
N 11.05 39.81 21.33 20.64 11.64 37.82
6,000
Y 1.69 261.18 2.90 151.68 1.65 266.10
7 000 N 12.89 39.82 24.80 20.70 13.55 37.90
Y 1.97 260.82 3.50 146.89 1.81 283.20
N 14.77 39.73 28.57 20.54 15.57 37.68
8,000
Y 2.78 210.70 4.06 144.58 2.19 268.05
N 16.71 39.5] 32.16 20.53 17.57 37.57
9,000
Y 3.06 215.96 4.40 150.07 2.33 283.38
18.43 39.81 35.57 20.62 19.57 37.49
10,000
Y 2.98 246.49 4.85 151.20 2.68 273.60

 

* Metrics are collected on an Ubuntu 16.04 server with 8 Intel E5-2609 v4 @1.70 GHz cores. Note that time in the table above is given in seconds (s). Throughputs are
measured by evaluating the average size of data (in megabytes) processed per second (MB/s)

“In this column, Y means OpenMP is enabled where N means OpenMP is not enabled

further prove that the proposed mechanism is adaptive-ID
chosen ciphertext secure. Finally, we present both theoret-
ical and experimental analyses showing that the proposed
mechanism is practical and efficient.

Acknowledgements
The authors would like to thank the anonymous reviewers for their valuable
comments.

Authors’ contributions

Shuzhou Sun and Hui Ma proposed the revocation mechanism for SM9, and
drafted the manuscript. Rui Zhang participated in problem discussions and
improvements of the manuscript. Wenhan Xu implemented and benchmarked
the proposed scheme. All authors read and approved the final manuscript.

Funding

This work was partially supported by National Natural Science Foundation of
China (Nos. 61772520, 61802392, 61972094, 61472416, 61632020), Key
Research and Development Project of Zhejiang Province (Nos. 2017C01062,
2020C01078), Beijing Municipal Science & Technology Commission (Project
Number. Z191100007119007, Z191100007119002).

Availability of data and materials
Not applicable.

Competing interests
The authors declare that they have no competing interests.

Author details

'State Key Laboratory of Information Security, Institute of Information
Engineering, Chinese Academy of Sciences, Beijing 100093, China. *School of
Cyber Security, University of Chinese Academy of Sciences, Beijing 100049,
China.

Received: 3 September 2019 Accepted: 26 April 2020
Published online: 13 May 2020

References

Bentahar K, Farshim P, Malone-Lee J, Smart NP (2008) Generic constructions of
identity-based and certificateless kems. J Cryptol 21(2):178-199

Boldyreva A, Goyal V, Kumar V (2008) Identity-based encryption with efficient
revocation. In: Proceedings of the 15th ACM Conference on Computer and
Communications Security. ACM. pp 417-426. https://doi.org/10.1145/
1455770.1455823
Sun et al. Cybersecurity (2020) 3:12

Boneh D, Boyen X (2004) Efficient selective-id secure identity-based
encryption without random oracles. In: International Conference on the
Theory and Applications of Cryptographic Techniques. Springer.
pp 223-238. https://doi.org/10.1007/978-3-540-24676-3_14

Boneh D, Boyen X (2004) Secure identity based encryption without random
oracles. In: Annual International Cryptology Conference. Springer.
pp 443-459. https://doi.org/10.1007/978-3-540-28628-8_27

Boneh D, Ding X, Tsudik G, Wong C-M (2001) A method for fast revocation of
public key certificates and security capabilities. In: USENIX Security
Symposium. p 22

Boneh D, Franklin M (2001) Identity-based encryption from the weil pairing. In:
Annual International Cryptology Conference. Springer. pp 213-229.
https://doi.org/10.1137/s0097539701398521

Boyen X (2007) General ad hoc encryption from exponent inversion ibe. In:
Annual International Conference on the Theory and Applications of
Cryptographic Techniques. Springer. pp 394-411. https://doi.org/10.1007/
978-3-540-72540-4_23

Boyen X, Martin L (2007) Identity-based cryptography standard (ibcs)# 1:
Supersingular curve implementations of the bf and bb1 cryptosystems.
Technical report, RFC 5091, December. https://doi.org/10.17487/rfc5091

Canetti R, Halevi S, Katz J (2004) Chosen-ciphertext security from
identity-based encryption. In: International Conference on the Theory and
Applications of Cryptographic Techniques. Springer. pp 207-222. https://
doi.org/10.1007/978-3-540-24676-3_13

Cheng Z (2017) The SM9 Cryptographic Schemes. Cryptol ePrint Arch. Report
2017/117. https://eprint.iacr.org/2017/117

Cocks C (2001) An identity based encryption scheme based on quadratic
residues. In: IMA International Conference on Cryptography and Coding.
Springer. pp 360-363. https://doi.org/10.1007/3-540-45325-3_32

Dagum L, Menon R (1998) Openmp: An industry-standard api for
shared-memory programming. Comput Sci Eng 1:46-55

Delerablée C (2007) Identity-based broadcast encryption with constant size
ciphertexts and private keys. In: International Conference on the Theory
and Application of Cryptology and Information Security. Springer.
pp 200-215. https://doi.org/10.1007/978-3-540-76900-2_12

Ge A, Wei P (2019) Identity-based broadcast encryption with efficient
revocation. In: IACR International Workshop on Public Key Cryptography.
Springer. pp 405-435. https://doi.org/10.1007/978-3-030-17253-4_14

Gentry C (2006) Practical identity-based encryption without random oracles.
In: Annual International Conference on the Theory and Applications of
Cryptographic Techniques. Springer. pp 445-464. https://doi.org/10.1007/
11761679_27

Gm/t (2016) 0044.1-2016 identity-based cryptographic algorithms sm9-part 1:
General. Technical report

Gm/t (2016) 0044.5-2016 identity-based cryptographic algorithms sm9-part 5:
Parameter definition. Technical report

IEEE (2013) std 1363.3-2013 ieee standard for identity-based cryptographic
techniques using pairings. Technical report. IEEE Comput Soc

Iso/iec (2015) 18033-5:2015 information technology — security techniques —
encryption algorithms — part 5: Identity-based ciphers. Technical report,
ISO/IEC

Kogan N, Shavitt Y, Wool A (2006) A practical revocation scheme for broadcast
encryption using smartcards. ACM Trans Inf Syst Secur (TISSEC)
9(3):325-35]

LiJ, Jia C, Li J, Chen X (2012) Outsourcing encryption of attribute-based
encryption with mapreduce. In: International Conference on Information
and Communications Security. Springer. pp 191-201. https://doi.org/10.
1007/978-3-642-34129-8_17

LiJ, LiJ, Chen X, Jia C, Lou W (2013) Identity-based encryption with outsourced
revocation in cloud computing. IEEE Trans Comput 64(2):425-437

Libert B, Quisquater J-J (2003) Efficient revocation and threshold pairing based
cryptosystems. In: Proceedings of the Twenty-second Annual Symposium
on Principles of Distributed Computing. ACM. pp 163-171. https://doi.org/
10.1145/872035.872059

Libert B, Vergnaud D (2009) Adaptive-id secure revocable identity-based
encryption. In: Cryptographers’ Track at the RSA Conference. Springer.
pp 1-15. https://doi.org/10.1007/978-3-642-00862-7_1

 

 

 

 

 

Page 13 of 13

Martin L, Appenzeller G, Schertler M (2009) Identity-based encryption
architecture and supporting data structures. Identity. https://doi.org/10.
17487/rfc5408

Martin L, Schertler M (2009) Using the boneh-franklin and boneh-boyen
identity-based encryption algorithms with the cryptographic message
syntax (cms). https://doi.org/10.17487/rfc5409

Naor D, Naor M, Lotspiech J (2001) Revocation and tracing schemes for
stateless receivers. In: Annual International Cryptology Conference.
Springer. pp 41-62. https://doi.org/10.1007/3-540-44647-8_3

Qin B, Deng RH, Li Y, Liu S (2015) Server-aided revocable identity-based
encryption. In: European Symposium on Research in Computer Security.
Springer. pp 286-304. https://doi.org/10.1007/978-3-319-24174-6_15

Sahai A, Waters B (2005) Fuzzy identity-based encryption. In: Annual
International Conference on the Theory and Applications of Cryptographic
Techniques. Springer. pp 457-473. https://doi.org/10.1007/11426639_27

Sakai R, Kasahara M (2003) Id based cryptosystems with pairing on elliptic
curve. [ACR Cryptol ePrint Arch 2003:54

Seo JH, Emura K (2013) Revocable identity-based encryption revisited: Security
model and construction. In: International Workshop on Public Key
Cryptography. Springer. pp 216-234. https://doi.org/10.1007/978-3-642-
36362-7_14

Shoup V (2001) A proposal for an iso standard for public key encryption
(version 2.1). IACR e-Print Arch 112

Shoup V (2006) ISO/IEC 18033-2: 2006. Information Technology—Security
Techniques—Encryption Algorithms—Part 2

Wang X, Yu H (2016) Sm3 cryptographic hash algorithm. J Inf Secur
Res:983-994

Waters B (2005) Efficient identity-based encryption without random oracles. In:
Annual International Conference on the Theory and Applications of
Cryptographic Techniques. Springer. pp 114-127. https://doi.org/10.1007/
11426639_7

Publisher’s Note
Springer Nature remains neutral with regard to jurisdictional claims in
published maps and institutional affiliations.

 

Submit your manuscript to a SpringerOpen”®
journal and benefit from:

> Convenient online submission

> Rigorous peer review

> Open access: articles freely available online
> High visibility within the field

> Retaining the copyright to your article

 

Submit your next manuscript at > springeropen.com

 

 

 
